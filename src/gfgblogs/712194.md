---
id: "712194"
title: "Maximum point you can obtain from cards"
slug: "maximum-point-you-can-obtain-from-cards"
difficulty: "Medium"
companyTags: []
tags: ["sliding-window", "Arrays", "Data Structures", "Algorithms"]
---

**Maximum point you can obtain from cards**
=========================================

## Summary
Given a set of cards with certain points, we need to find the maximum possible total point that can be obtained by taking at most three cards. The point values are given in an array.

This problem involves arrays and sliding window techniques. We'll use two pointers to solve this problem efficiently.

## Detailed Explanation

We start by iterating over all cards. For each card, we consider the maximum score we can get by including it in our selection (at most three cards). To do this, we maintain a sliding window of size 3 and keep track of the maximum score we've seen so far within this window.

Here's a step-by-step breakdown:

1. Initialize two pointers `left` and `right` to 0.
2. Iterate over all cards from left to right (inclusive). For each card, calculate the maximum score that can be obtained by including it in our selection (at most three cards).
3. To do this, maintain a sliding window of size 3 centered at the current card. The window is defined as `left` to `right`.
4. Calculate the maximum score within this window. If adding the current card gives us a higher score than what we have seen so far, update our maximum score.
5. Move the right pointer one step to the right and incrementally calculate the new maximum score by considering the cards that were previously in the sliding window but are now outside it.
6. Repeat steps 2-5 until all cards have been processed.

Time complexity: O(n), where n is the number of cards, since we process each card once.
Space complexity: O(1), as we only use a constant amount of space to store our pointers and variables.

## Optimized Solutions

### Java
```java
int maxPoints(int[] points) {
    int n = points.length;
    if (n <= 3) return Arrays.stream(points).sum();
    
    int maxScore = 0, left = 0, right = 0, windowSum = 0;
    for (right = 1; right < n; right++) {
        windowSum += points[right];
        
        while (windowSum > points[left] + points[left+1] + points[left+2]) {
            windowSum -= points[left];
            left++;
        }
        
        maxScore = Math.max(maxScore, windowSum);
    }
    
    return maxScore;
}
```

### Python
```python
def max_points(points):
    n = len(points)
    if n <= 3: return sum(points)
    
    max_score = 0; left = 0; right = 0; window_sum = 0
    for right in range(1, n):
        window_sum += points[right]
        
        while window_sum > points[left] + points[left+1] + points[left+2]:
            window_sum -= points[left]; left += 1
        
        max_score = max(max_score, window_sum)
    
    return max_score
```

### C++
```cpp
int maxPoints(int* points, int n) {
    if (n <= 3) return accumulate(points, points+n, 0);
    
    int maxScore = 0, left = 0, right = 0, windowSum = 0;
    for (right = 1; right < n; right++) {
        windowSum += points[right];
        
        while (windowSum > points[left] + points[left+1] + points[left+2]) {
            windowSum -= points[left]; left++;
        }
        
        maxScore = max(maxScore, windowSum);
    }
    
    return maxScore;
}
```

### JavaScript
```javascript
function maxPoints(points) {
    let n = points.length;
    if (n <= 3) return points.reduce((a, b) => a + b, 0);
    
    let maxScore = 0; let left = 0; let right = 0; let windowSum = 0;
    for (right = 1; right < n; right++) {
        windowSum += points[right];
        
        while (windowSum > points[left] + points[left+1] + points[left+2]) {
            windowSum -= points[left]; left++;
        }
        
        maxScore = Math.max(maxScore, windowSum);
    }
    
    return maxScore;
}
```

Note: The code blocks are formatted in Markdown and should be readable.