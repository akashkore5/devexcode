---
id: "876764"
title: "Word Search II"
slug: "word-search-ii"
difficulty: "Hard"
companyTags: []
tags: ["Trie", "DFS", "Backtracking", "Advanced Data Structure"]
---

**Word Search II**
==================

**Slug:** word-search-ii
**Difficulty:** Hard
**Id:** 876764
**Topic Tags:** Trie, DFS, Backtracking, Advanced Data Structure
**Company Tags:** None

## Summary
The Word Search II problem involves finding all possible words in a given 2D grid of characters. The grid contains some hidden words that can be formed by connecting adjacent cells horizontally or vertically. The goal is to find all these hidden words using an efficient algorithmic approach.

## Detailed Explanation
To solve this problem, we will use a combination of Trie data structure and Depth-First Search (DFS) with backtracking. We will first create a Trie from the given list of words. Then, for each cell in the grid, we will perform DFS to find all possible words that can be formed starting from that cell.

Here's a step-by-step breakdown of the solution:

1. Create a Trie from the given list of words.
2. Iterate over each cell in the grid.
3. For each cell, use DFS to explore all possible paths starting from that cell.
4. At each node in the DFS traversal, check if it matches any word in the Trie. If it does, add that word to the result set.
5. Backtrack and continue exploring other paths until all possible words have been found.

Here's an ASCII art diagram of the Trie data structure:
```
     +---+
     |  A  |
     +---+
       /   \
    +-----+-----+
    |  B  |  C  |
    +-----+-----+
      /     \   /
    +-------+-------+
    |  D  |  E  |  F  |
    +-------+-------+
```
Time complexity: O(M * N), where M is the number of words and N is the size of the grid.
Space complexity: O(M), where M is the number of words.

## Optimized Solutions

### Java
```java
import java.util.*;

public class WordSearchII {
    public List<String> findWords(char[][] board, String[] wordDict) {
        TrieNode root = new TrieNode();
        for (String word : wordDict) {
            insertWord(root, word);
        }

        Set<String> result = new HashSet<>();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                dfs(board, root, result, i, j);
            }
        }
        return new ArrayList<>(result);
    }

    private void insertWord(TrieNode root, String word) {
        TrieNode curr = root;
        for (char c : word.toCharArray()) {
            if (!curr.children.containsKey(c)) {
                curr.children.put(c, new TrieNode());
            }
            curr = curr.children.get(c);
        }
        curr.isEndOfWord = true;
    }

    private void dfs(char[][] board, TrieNode root, Set<String> result, int i, int j) {
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) {
            return;
        }
        char c = board[i][j];
        if (!root.children.containsKey(c)) {
            return;
        }
        TrieNode next = root.children.get(c);
        board[i][j] = '\0'; // mark as visited
        if (next.isEndOfWord) {
            result.add(String.valueOf(c));
        }
        dfs(board, next, result, i - 1, j); // up
        dfs(board, next, result, i + 1, j); // down
        dfs(board, next, result, i, j - 1); // left
        dfs(board, next, result, i, j + 1); // right
        board[i][j] = c; // backtrack
    }
}
```

### Python
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isEndOfWord = False

def insert_word(root, word):
    curr = root
    for c in word:
        if c not in curr.children:
            curr.children[c] = TrieNode()
        curr = curr.children[c]
    curr.isEndOfWord = True

def dfs(board, root, result, i, j):
    if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):
        return
    c = board[i][j]
    if c not in root.children:
        return
    next_node = root.children[c]
    board[i][j] = '\0'  # mark as visited
    if next_node.isEndOfWord:
        result.append(c)
    dfs(board, next_node, result, i - 1, j)  # up
    dfs(board, next_node, result, i + 1, j)  # down
    dfs(board, next_node, result, i, j - 1)  # left
    dfs(board, next_node, result, i, j + 1)  # right
    board[i][j] = c  # backtrack

def find_words(board, word_dict):
    root = TrieNode()
    for word in word_dict:
        insert_word(root, word)
    result = set()
    for i in range(len(board)):
        for j in range(len(board[0])):
            dfs(board, root, result, i, j)
    return list(result)
```

### C++
```cpp
#include <unordered_map>
#include <vector>

class TrieNode {
public:
    std::unordered_map<char, TrieNode*> children;
    bool isEndOfWord = false;

    TrieNode() {}
};

void insertWord(TrieNode* root, const std::string& word) {
    TrieNode* curr = root;
    for (char c : word) {
        if (!curr->children.count(c)) {
            curr->children[c] = new TrieNode();
        }
        curr = curr->children[c];
    }
    curr->isEndOfWord = true;
}

void dfs(char** board, TrieNode* root, std::set<std::string>& result, int i, int j) {
    if (i < 0 || i >= 10 || j < 0 || j >= 16) {
        return;
    }
    char c = board[i][j];
    if (!root->children.count(c)) {
        return;
    }
    TrieNode* next = root->children[c];
    board[i][j] = '\0'; // mark as visited
    if (next->isEndOfWord) {
        result.insert(std::string(1, c));
    }
    dfs(board, next, result, i - 1, j); // up
    dfs(board, next, result, i + 1, j); // down
    dfs(board, next, result, i, j - 1); // left
    dfs(board, next, result, i, j + 1); // right
    board[i][j] = c; // backtrack
}

std::vector<std::string> findWords(char** board, const std::vector<std::string>& wordDict) {
    TrieNode* root = new TrieNode();
    for (const auto& word : wordDict) {
        insertWord(root, word);
    }

    std::set<std::string> result;
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 16; j++) {
            dfs(board, root, result, i, j);
        }
    }
    return std::vector<std::string>(result.begin(), result.end());
}
```

### Java
```java
class TrieNode {
    Map<Character, TrieNode> children;
    boolean isEndOfWord;

    public TrieNode() {
        children = new HashMap<>();
        isEndOfWord = false;
    }
}

public class Solution {
    public List<String> findWords(char[][] board, String[] wordDict) {
        TrieNode root = new TrieNode();
        for (String word : wordDict) {
            insertWord(root, word);
        }

        Set<String> result = new HashSet<>();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                dfs(board, root, result, i, j);
            }
        }
        return new ArrayList<>(result);
    }

    private void insertWord(TrieNode root, String word) {
        TrieNode curr = root;
        for (char c : word.toCharArray()) {
            if (!curr.children.containsKey(c)) {
                curr.children.put(c, new TrieNode());
            }
            curr = curr.children.get(c);
        }
        curr.isEndOfWord = true;
    }

    private void dfs(char[][] board, TrieNode root, Set<String> result, int i, int j) {
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) {
            return;
        }
        char c = board[i][j];
        if (!root.children.containsKey(c)) {
            return;
        }
        TrieNode next = root.children.get(c);
        board[i][j] = '\0'; // mark as visited
        if (next.isEndOfWord) {
            result.add(String.valueOf(c));
        }
        dfs(board, next, result, i - 1, j); // up
        dfs(board, next, result, i + 1, j); // down
        dfs(board, next, result, i, j - 1); // left
        dfs(board, next, result, i, j + 1); // right
        board[i][j] = c; // backtrack
    }
}
```

Note: The above code is just an example and may not be perfect. You can modify it as per your requirements.