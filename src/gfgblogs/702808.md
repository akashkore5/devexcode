---
id: "702808"
title: "Equal Sum and Product"
slug: "equal-sum-and-product2057"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "subset", "Data Structures"]
---

**Equal Sum and Product**
===============

**Slug:** equal-sum-and-product2057
**Difficulty:** Easy
**Id:** 702808
**Topic Tags:** Arrays, subset, Data Structures
**Company Tags:** None

## Summary
Given an array of integers, the problem is to find all unique quadruplets (four-element subsets) where the sum of their elements is equal and the product of their elements is also equal. This problem involves arrays, subsets, and data structures.

## Detailed Explanation
To solve this problem, we can start by iterating over the array and considering each element as a starting point for our quadruplet. We then need to find three more elements that have the same sum and product as the first four elements. Since the sum and product must be equal, we can create a hashmap to store the sums and products we encounter, along with their indices.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty hashmap.
2. Iterate over the array, considering each element as a starting point for our quadruplet.
3. For each element, calculate its sum and product by considering it with all previous elements.
4. Check if the calculated sum and product already exist in the hashmap. If they do, add their indices to the result set.
5. Continue iterating over the array until we have considered all possible quadruplets.

Time complexity analysis: The time complexity of this solution is O(n^3), where n is the length of the input array. This is because we are iterating over the array and considering each element as a starting point for our quadruplet, which takes O(n) time. For each element, we are calculating its sum and product by considering it with all previous elements, which also takes O(n) time.

Space complexity analysis: The space complexity of this solution is O(n^2), where n is the length of the input array. This is because we are storing the sums and products in a hashmap, along with their indices, which requires O(n^2) space.

## Optimized Solutions

### Java
```java
import java.util.*;

public class EqualSumAndProduct {
    public static List<List<Integer>> findQuadruplets(int[] arr) {
        Map<Integer, List<Integer>> map = new HashMap<>();
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < arr.length; i++) {
            int sum = 0;
            int product = 1;

            for (int j = i; j < arr.length; j++) {
                sum += arr[j];
                product *= arr[j];

                if (map.containsKey(sum) && map.get(sum).contains(product)) {
                    result.addAll(map.get(sum));
                }

                map.computeIfAbsent(sum, k -> new ArrayList<>()).add(product);
            }
        }

        return result;
    }
}
```

### Python
```python
def find_quadruplets(arr):
    sum_product_map = {}

    for i in range(len(arr)):
        sum_product = 0
        product = 1

        for j in range(i, len(arr)):
            sum_product += arr[j]
            product *= arr[j]

            if sum_product in sum_product_map and product in sum_product_map[sum_product]:
                result.extend(sum_product_map[sum_product])

            if sum_product not in sum_product_map:
                sum_product_map[sum_product] = []

            sum_product_map[sum_product].append(product)

    return result
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

std::vector<std::vector<int>> findQuadruplets(std::vector<int>& arr) {
    std::unordered_map<int, std::vector<int>> sumProductMap;
    std::vector<std::vector<int>> result;

    for (int i = 0; i < arr.size(); i++) {
        int sum = 0;
        int product = 1;

        for (int j = i; j < arr.size(); j++) {
            sum += arr[j];
            product *= arr[j];

            if (sumProductMap.count(sum) && std::find(sumProductMap[sum].begin(), sumProductMap[sum].end(), product) != sumProductMap[sum].end()) {
                result.insert(result.end(), sumProductMap[sum].begin(), sumProductMap[sum].end());
            }

            if (!sumProductMap.count(sum)) {
                sumProductMap[sum] = {};
            }

            sumProductMap[sum].push_back(product);
        }
    }

    return result;
}
```

### JavaScript
```javascript
function findQuadruplets(arr) {
    let sumProductMap = {};

    for (let i = 0; i < arr.length; i++) {
        let sum = 0;
        let product = 1;

        for (let j = i; j < arr.length; j++) {
            sum += arr[j];
            product *= arr[j];

            if (sumProductMap[sum] && sumProductMap[sum].includes(product)) {
                result.push(...sumProductMap[sum]);
            }

            if (!sumProductMap[sum]) {
                sumProductMap[sum] = [];
            }

            sumProductMap[sum].push(product);
        }
    }

    return result;
}
```