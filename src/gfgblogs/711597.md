---
id: "711597"
title: "Path With Minimum Effort"
slug: "path-with-minimum-effort"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "DFS", "BFS"]
---

**Path With Minimum Effort**
=====================================

## Summary

Given a connected graph, find the path that requires minimum effort to traverse. The effort required to traverse an edge is equal to its weight. We are allowed to visit each edge at most once.

The problem can be solved using DFS (Depth-First Search) or BFS (Breadth-First Search) algorithm with slight modifications. The main idea is to keep track of the minimum effort path and update it whenever a better path is found.

## Detailed Explanation

To solve this problem, we will use a priority queue where each node represents an edge in the graph along with its weight. We will start from any arbitrary node (say 0) and try to traverse all possible paths from that node. For each path, we calculate its total effort required to traverse it and add it to our priority queue.

We then pop out the edge with the minimum effort from the priority queue, mark it as visited, and update our result if this edge is part of a better path than what we have found so far.

We keep doing this until all nodes are visited. The final result will be the minimum effort required to traverse the graph.

Here is the step-by-step breakdown:

1.  Initialize an empty priority queue.
2.  Start from any arbitrary node (say 0) and add it to our priority queue with a weight of 0.
3.  Pop out the edge with the minimum effort from the priority queue, mark it as visited, and update our result if this edge is part of a better path than what we have found so far.
4.  For each neighbor of the current node that has not been visited yet:
    *   Add its edge to the priority queue along with its weight (which is equal to the total effort required to traverse from the starting node to this edge).
5.  Repeat steps 3 and 4 until all nodes are visited.

Time Complexity: O(E + V log E) where E is the number of edges in the graph, V is the number of vertices, and log E is the time complexity for extracting the minimum element from the priority queue.

Space Complexity: O(V) to store the visited status of each node and O(E) to store the priority queue.

## Optimized Solutions

### Java
```java
import java.util.*;

class Solution {
    public int minEffortPath(int[][] edges, int[] effort, int n) {
        List<Edge> edgeList = new ArrayList<>();
        for (int i = 0; i < n - 1; i++) {
            edgeList.add(new Edge(i, i + 1, effort[i]));
        }
        
        Collections.sort(edgeList);
        
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> a - b);
        pq.add(0);
        
        int minEffort = 0;
        while (!pq.isEmpty()) {
            int currentEffort = pq.poll();
            if (currentEffort > minEffort) {
                return -1;
            }
            
            for (Edge edge : edgeList) {
                if (edge.effort + currentEffort <= minEffort) {
                    minEffort = edge.effort + currentEffort;
                    pq.clear();
                    pq.add(minEffort);
                }
            }
        }
        
        return minEffort;
    }

    static class Edge implements Comparable<Edge> {
        int from, to, effort;

        public Edge(int from, int to, int effort) {
            this.from = from;
            this.to = to;
            this.effort = effort;
        }

        @Override
        public int compareTo(Edge o) {
            return Integer.compare(effort, o.effort);
        }
    }
}
```

### Python
```python
class Solution:
    def minEffortPath(self, edges, effort, n):
        edgeList = [(i, i+1, effort[i]) for i in range(n-1)]
        
        edgeList.sort(key=lambda x: x[2])
        
        pq = []
        heapq.heappush(pq, 0)
        
        minEffort = 0
        while pq:
            currentEffort = heapq.heappop(pq)
            if currentEffort > minEffort:
                return -1
            
            for edge in edgeList:
                if edge[2] + currentEffort <= minEffort:
                    minEffort = edge[2] + currentEffort
                    pq.clear()
                    heapq.heappush(pq, minEffort)
       
        
        return minEffort
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <queue>

class Solution {
public:
    int minEffortPath(std::vector<std::pair<int, int>>& edges, std::vector<int>& effort, int n) {
        std::vector<Edge> edgeList;
        for (int i = 0; i < n - 1; i++) {
            edgeList.push_back({i, i + 1, effort[i]});
        }
        
        std::sort(edgeList.begin(), edgeList.end(), [](const auto& a, const auto& b) { return a.effort < b.effort; });
        
        std::priority_queue<int> pq;
        pq.push(0);
        
        int minEffort = 0;
        while (!pq.empty()) {
            int currentEffort = pq.top();
            pq.pop();
            if (currentEffort > minEffort) {
                return -1;
            }
            
            for (const auto& edge : edgeList) {
                if (edge.effort + currentEffort <= minEffort) {
                    minEffort = edge.effort + currentEffort;
                    pq.clear();
                    pq.push(minEffort);
                }
            }
        }
        
        return minEffort;
    }

private:
    struct Edge {
        int from, to, effort;
    };
};
```

### JavaScript
```javascript
class Solution {
    minEffortPath(edges, effort, n) {
        let edgeList = [];
        for (let i = 0; i < n - 1; i++) {
            edgeList.push({from: i, to: i + 1, effort: effort[i]});
        }
        
        edgeList.sort((a, b) => a.effort - b.effort);
        
        let pq = new PriorityQueue();
        pq.enqueue(0);
        
        let minEffort = 0;
        while (!pq.isEmpty()) {
            let currentEffort = pq.dequeue().value;
            if (currentEffort > minEffort) {
                return -1;
            }
            
            for (let edge of edgeList) {
                if (edge.effort + currentEffort <= minEffort) {
                    minEffort = edge.effort + currentEffort;
                    pq.clear();
                    pq.enqueue(minEffort);
                }
            }
        }
        
        return minEffort;
    }
}

class PriorityQueue {
    constructor() {
        this.heap = [];
    }

    enqueue(value) {
        this.heap.push({value});
        this._heapifyUp(this.heap.length - 1);
    }

    dequeue() {
        let value = this.heap[0].value;
        this.heap[0] = this.heap.pop();
        this._heapifyDown(0);
        return {value};
    }

    _heapifyUp(index) {
        while (index > 0) {
            let parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[parentIndex].value <= this.heap[index].value) {
                break;
            }
            [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];
            index = parentIndex;
        }
    }

    _heapifyDown(index) {
        let leftChildIndex = 2 * index + 1;
        let rightChildIndex = 2 * index + 2;

        if (leftChildIndex >= this.heap.length) return;
        if (rightChildIndex >= this.heap.length || this.heap[leftChildIndex].value <= this.heap[rightChildIndex].value) {
            if (this.heap[index].value < this.heap[leftChildIndex].value) {
                [this.heap[index], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[index]];
                _heapifyDown(leftChildIndex);
            }
        } else {
            [this.heap[index], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[index]];
            _heapifyDown(rightChildIndex);
        }
    }
}
```