---
id: "710293"
title: "Sort a k sorted doubly linked list"
slug: "sort-a-k-sorted-doubly-linked-list"
difficulty: "Medium"
companyTags: []
tags: ["Linked List", "Data Structures"]
---

# Sort a k sorted doubly linked list
## Slug: sort-a-k-sorted-doubly-linked-list
## Difficulty: Medium
## Id: 710293
## Topic Tags: Linked List, Data Structures
## Company Tags: None


### Summary
Given a doubly linked list where each node contains at most `k` nodes in sorted order, the task is to sort the entire list. This problem involves manipulating a linked list and can be solved using various algorithms.

### Detailed Explanation
To solve this problem, we'll use a simple merge sort approach. Since we have k-sorted lists, we can take advantage of this property by merging adjacent lists in sorted order. We start by splitting the input list into smaller segments of size `k` each. Each segment is already sorted, so we can simply merge these segments together to form the final sorted list.

Here's a step-by-step breakdown of the solution:

1. Split the input list into segments of size `k`. This will give us an array of linked lists, where each linked list contains at most `k` nodes.
2. For each segment, we'll create a new node that contains the smallest element from all the linked lists in that segment. We can do this by iterating through the linked lists and keeping track of the minimum value seen so far.
3. Add the new node to our result list and remove it from its original position in the segment.
4. Repeat steps 2-3 until we've processed all segments.
5. The final sorted list will be the concatenation of the nodes in each segment, with the smallest element first.

Time complexity: O(n log k) where `n` is the total number of nodes and `k` is the maximum size of a segment.

Space complexity: O(n) since we need to store the result list.

### Optimized Solutions

#### Java
```java
public Node sortKSortedDoublyLinkedList(Node head, int k) {
    List<Node> segments = new ArrayList<>();
    Node current = head;
    while (current != null) {
        Node next = current.next;
        if (next == null || current.data.compareTo(next.data) > 0) {
            // Start a new segment
            segments.add(current);
            current = next;
        } else {
            current = next;
        }
    }
    
    Node result = new Node();
    while (!segments.isEmpty()) {
        Node minNode = segments.get(0);
        for (int i = 1; i < segments.size(); i++) {
            if (minNode.data.compareTo(segments.get(i).data) > 0) {
                minNode = segments.get(i);
            }
        }
        result.next = minNode;
        segments.remove(minNode);
    }
    
    return result.next;
}
```

#### Python
```python
def sort_k_sorted_doubly_linked_list(head, k):
    segments = []
    current = head
    while current:
        next_node = current.next
        if not next_node or current.data > next_node.data:
            # Start a new segment
            segments.append(current)
            current = next_node
        else:
            current = next_node
    
    result = Node()
    while segments:
        min_node = segments[0]
        for i in range(1, len(segments)):
            if min_node.data > segments[i].data:
                min_node = segments[i]
        result.next = min_node
        segments.remove(min_node)
    
    return result.next
```

#### C++
```cpp
Node* sortKSortedDoublyLinkedList(Node* head, int k) {
    vector<Node*> segments;
    Node* current = head;
    while (current) {
        Node* next_node = current->next;
        if (!next_node || current->data > next_node->data) {
            // Start a new segment
            segments.push_back(current);
            current = next_node;
        } else {
            current = next_node;
        }
    }
    
    Node* result = new Node();
    while (!segments.empty()) {
        Node* min_node = segments[0];
        for (int i = 1; i < segments.size(); i++) {
            if (min_node->data > segments[i]->data) {
                min_node = segments[i];
            }
        }
        result->next = min_node;
        segments.erase(segments.begin() + distance(segments.begin(), find(segments.begin(), segments.end(), min_node)));
    }
    
    return result->next;
}
```

#### JavaScript
```javascript
function sortKSortedDoublyLinkedList(head, k) {
    let segments = [];
    let current = head;
    while (current) {
        let nextNode = current.next;
        if (!nextNode || current.data > nextNode.data) {
            // Start a new segment
            segments.push(current);
            current = nextNode;
        } else {
            current = nextNode;
        }
    }
    
    let result = new Node();
    while (segments.length) {
        let minNode = segments[0];
        for (let i = 1; i < segments.length; i++) {
            if (minNode.data > segments[i].data) {
                minNode = segments[i];
            }
        }
        result.next = minNode;
        segments.splice(segments.indexOf(minNode), 1);
    }
    
    return result.next;
}
```