---
id: "714141"
title: "Yet another query problem"
slug: "yet-another-query-problem--170647"
difficulty: "Medium"
companyTags: []
tags: ["prefix-sum", "Arrays", "Data Structures", "Algorithms"]
---

**Yet Another Query Problem**
================================

## Summary
Given an array of integers, your task is to find all pairs that sum up to a given target value. This problem involves using prefix sums and arrays, making it a medium-level difficulty query problem.

## Detailed Explanation
The basic idea is to use the property of prefix sums: if we have two indices `i` and `j`, such that `arr[i] + arr[j] = target`, then their prefix sums should be equal. We iterate over the array once, calculate the prefix sum for each element, and store it in a hash map.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty hash map `prefixSumMap`.
2. Iterate over the array from left to right:
	* Calculate the prefix sum `ps` for each element.
	* Check if there exists another element `j` such that `arr[j] + ps = target`. If found, return the pair `(arr[i], arr[j])`.
3. Return an empty list if no pairs are found.

Time complexity: O(n), where n is the length of the array. We only iterate over the array once.
Space complexity: O(n), for storing the prefix sums in the hash map.

Here's a simple ASCII art diagram to illustrate the process:

```
  arr = [1, 2, 3, 4]
  ps_map = {}
  i = 0
  while i < len(arr):
    ps = sum(arr[:i+1])  # prefix sum up to i
    if target - ps in ps_map:
      return [(arr[i], x) for x in ps_map[target-ps]]
    ps_map[ps] = arr[i]
    i += 1
```

## Optimized Solutions

### Java
```java
public List<int[]> findPairs(int[] arr, int target) {
    Map<Integer, Integer> prefixSumMap = new HashMap<>();
    for (int i = 0; i < arr.length; i++) {
        int ps = 0;
        for (int j = 0; j <= i; j++) {
            ps += arr[j];
        }
        if (prefixSumMap.containsKey(target - ps)) {
            return Arrays.stream(prefixSumMap.get(target - ps)).boxed().collect(Collectors.toList());
        }
        prefixSumMap.put(ps, arr[i]);
    }
    return new ArrayList<>();
}
```

### Python
```python
def find_pairs(arr, target):
    prefix_sum_map = {}
    for i in range(len(arr)):
        ps = sum(arr[:i+1])
        if target - ps in prefix_sum_map:
            return [(arr[i], x) for x in prefix_sum_map[target-ps]]
        prefix_sum_map[ps] = arr[i]
    return []
```

### C++
```cpp
#include <unordered_map>
#include <vector>

std::vector<std::pair<int, int>> findPairs(int* arr, int n, int target) {
    std::unordered_map<int, int> prefixSumMap;
    for (int i = 0; i < n; i++) {
        int ps = 0;
        for (int j = 0; j <= i; j++) {
            ps += arr[j];
        }
        if (prefixSumMap.find(target - ps) != prefixSumMap.end()) {
            return {{arr[i], x} for x in prefixSumMap[target-ps]};
        }
        prefixSumMap[ps] = arr[i];
    }
    return {};
}
```

### JavaScript
```javascript
function findPairs(arr, target) {
  const prefixSumMap = new Map();
  for (let i = 0; i < arr.length; i++) {
    let ps = 0;
    for (let j = 0; j <= i; j++) {
      ps += arr[j];
    }
    if (prefixSumMap.has(target - ps)) {
      return prefixSumMap.get(target - ps).map(x => [arr[i], x]);
    }
    prefixSumMap.set(ps, arr[i]);
  }
  return [];
}
```