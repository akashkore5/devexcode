---
id: "710035"
title: "Array Removals"
slug: "array-removals"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Dynamic Programming", "Data Structures", "Algorithms"]
---

# Array Removals
## Slug: array-removals
## Difficulty: Medium
## Id: 710035
## Topic Tags: Arrays, Dynamic Programming, Data Structures, Algorithms
## Company Tags: None

## Summary
Given an array `arr` of integers and two indices `i` and `j`, the problem is to find the minimum number of elements that need to be removed from the array such that all the elements in the range `[i, j]` are removed. The goal is to minimize the total number of removals while ensuring that all elements in the specified range are removed.

## Detailed Explanation
The problem can be solved by using dynamic programming. We can maintain a 2D table `dp[i][j]` where `dp[i][j]` represents the minimum number of removals needed to remove all elements in the range `[i, j]`. The base case for this recursion is when `i` and `j` are equal, which means we need to remove only one element. In this case, the answer is 1.

For other cases, we can consider two options: either include the current element in our removals or exclude it. If we include the current element, we would have to remove all elements up to `i-1` (since we cannot leave any gaps) and then remove all elements from `j+1` onwards. This would give us a total of `dp[i-1][j] + j-i + 2`.

On the other hand, if we exclude the current element, we can simply use the minimum number of removals needed to remove all elements in the range `[i, j-1]`. This gives us `dp[i][j-1]`.

We then choose the option that results in a smaller total number of removals and add it to our answer. The final answer is stored in `dp[0][n-1]`, where `n` is the length of the array.

Here's a step-by-step breakdown of the solution:

* Initialize the 2D table `dp[i][j]` with all elements set to infinity.
* For each element `arr[k]` in the range `[i, j]`, calculate the minimum number of removals needed by considering two options: including or excluding the current element.
* Choose the option that results in a smaller total number of removals and add it to our answer.
* Store the final answer in `dp[0][n-1]`.

Time complexity: O(n^2), where n is the length of the array.
Space complexity: O(n^2) for storing the 2D table `dp[i][j]`.

## Optimized Solutions

### Java
```java
public int minRemovals(int[] arr, int i, int j) {
    int n = arr.length;
    int[][] dp = new int[n][n];
    
    for (int k = 0; k < n; k++) {
        for (int l = 0; l < n; l++) {
            if (k == l) {
                dp[k][l] = 1;
            } else if (k > l) {
                dp[k][l] = Integer.MAX_VALUE;
            } else {
                if (arr[l] >= i && arr[l] <= j) {
                    dp[k][l] = 1 + dp[k-1][l-1];
                } else {
                    dp[k][l] = Math.min(dp[k-1][l], dp[k][l-1]) + 2;
                }
            }
        }
    }
    
    return dp[0][n-1];
}
```

### Python
```python
def min_removals(arr, i, j):
    n = len(arr)
    dp = [[float('inf')] * n for _ in range(n)]
    
    for k in range(n):
        for l in range(n):
            if k == l:
                dp[k][l] = 1
            elif k > l:
                dp[k][l] = float('inf')
            else:
                if i <= arr[l] <= j:
                    dp[k][l] = 1 + dp[k-1][l-1]
                else:
                    dp[k][l] = min(dp[k-1][l], dp[k][l-1]) + 2
    return dp[0][n-1]
```

### C++
```cpp
int minRemovals(int* arr, int n, int i, int j) {
    int** dp = new int*[n];
    for (int k = 0; k < n; k++) {
        dp[k] = new int[n];
    }
    
    for (int k = 0; k < n; k++) {
        for (int l = 0; l < n; l++) {
            if (k == l) {
                dp[k][l] = 1;
            } else if (k > l) {
                dp[k][l] = INT_MAX;
            } else {
                if (i <= arr[l] && arr[l] <= j) {
                    dp[k][l] = 1 + dp[k-1][l-1];
                } else {
                    dp[k][l] = min(dp[k-1][l], dp[k][l-1]) + 2;
                }
            }
        }
    }
    
    int ans = dp[0][n-1];
    for (int k = 0; k < n; k++) {
        delete[] dp[k];
    }
    delete[] dp;
    
    return ans;
}
```

### JavaScript
```javascript
function minRemovals(arr, i, j) {
    const n = arr.length;
    let dp = new Array(n).fill().map(() => new Array(n).fill(Infinity));
    
    for (let k = 0; k < n; k++) {
        for (let l = 0; l < n; l++) {
            if (k == l) {
                dp[k][l] = 1;
            } else if (k > l) {
                dp[k][l] = Infinity;
            } else {
                if (i <= arr[l] && arr[l] <= j) {
                    dp[k][l] = 1 + dp[k-1][l-1];
                } else {
                    dp[k][l] = Math.min(dp[k-1][l], dp[k][l-1]) + 2;
                }
            }
        }
    }
    
    return dp[0][n-1];
}
```