---
id: "703867"
title: "Longest Increasing Subarray"
slug: "longest-increasing-subarray3811"
difficulty: "Basic"
companyTags: ["Amazon"]
tags: ["Arrays", "Data Structures"]
---

Here is a detailed Markdown blog post for the "Longest Increasing Subarray" problem:

# Longest Increasing Subarray
## Slug: longest-increasing-subarray3811
## Difficulty: Basic
## Id: 703867
## Topic Tags: Arrays, Data Structures
## Company Tags: Amazon

### Summary
Given an array of integers, find the length of the longest increasing subarray. An increasing subarray is a sequence of elements where each element is greater than its previous one.

This problem requires you to understand arrays and data structures, as well as basic algorithmic concepts like loops and conditional statements.

### Detailed Explanation

To solve this problem, we can start by iterating through the array and keeping track of the length of the longest increasing subarray ending at each position. We do this by maintaining a variable `max_length` to keep track of the maximum length found so far, and another variable `current_length` to keep track of the length of the current increasing subarray.

Here's the step-by-step breakdown:

1. Initialize `max_length` to 1 (since a single element is always an increasing subarray) and `current_length` to 1.
2. Iterate through the array, starting from the second element (index 1).
3. For each element, check if it is greater than its previous one. If it is, increment `current_length`.
4. If the current element is not greater than its previous one, update `max_length` to be the maximum of `max_length` and `current_length`, and reset `current_length` to 1.
5. Continue iterating until the end of the array.
6. Return `max_length` as the length of the longest increasing subarray.

Here's a simple ASCII art diagram illustrating this process:
```
1 2 3 4 5 6
^-----^-----^
length: 3, max_length: 3
^-----^
length: 2, max_length: 3
    ^-----^
length: 1, max_length: 3
        ^-----^
length: 1, max_length: 4
            ^-----^
length: 1, max_length: 5
```
Time complexity: O(n), where n is the length of the array. We only need to iterate through the array once.
Space complexity: O(1), since we only use a few variables to keep track of our progress.

### Optimized Solutions

#### Java
```java
public int longestIncreasingSubarray(int[] arr) {
    int max_length = 1;
    int current_length = 1;
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > arr[i - 1]) {
            current_length++;
        } else {
            max_length = Math.max(max_length, current_length);
            current_length = 1;
        }
    }
    return Math.max(max_length, current_length);
}
```

#### Python
```python
def longest_increasing_subarray(arr):
    max_length = 1
    current_length = 1
    for i in range(1, len(arr)):
        if arr[i] > arr[i - 1]:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1
    return max(max_length, current_length)
```

#### C++
```cpp
int longestIncreasingSubarray(int* arr, int n) {
    int max_length = 1;
    int current_length = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] > arr[i - 1]) {
            current_length++;
        } else {
            max_length = std::max(max_length, current_length);
            current_length = 1;
        }
    }
    return std::max(max_length, current_length);
}
```

#### JavaScript
```javascript
function longestIncreasingSubarray(arr) {
    let max_length = 1;
    let current_length = 1;
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > arr[i - 1]) {
            current_length++;
        } else {
            max_length = Math.max(max_length, current_length);
            current_length = 1;
        }
    }
    return Math.max(max_length, current_length);
}
```

Each of these solutions has the same time and space complexity as the original explanation: O(n) time and O(1) space.