---
id: "703111"
title: "Beautiful SubSequence"
slug: "beautiful-subsequence5222"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Dynamic Programming", "Data Structures", "Algorithms"]
---

**Beautiful SubSequence**
===============

**Slug:** beautiful-subsequence5222
**Difficulty:** Medium
**Id:** 703111
**Topic Tags:** Arrays, Dynamic Programming, Data Structures, Algorithms

## Summary
The "Beautiful SubSequence" problem is a dynamic programming challenge that involves finding the longest contiguous subsequence in an array of integers. The subsequence should have at least one element with its value being greater than the previous element's value by 1.

## Detailed Explanation
The approach to solve this problem is to use dynamic programming. Initialize a 2D table `dp` where `dp[i][j]` represents whether the longest beautiful subsequence ending at index `i` has length `j`. Iterate through the array and update the `dp` table accordingly. The maximum value in the last row of the `dp` table will be the length of the longest beautiful subsequence.

Here's a step-by-step breakdown:

1. Initialize the `dp` table with zeros, where `dp[i][0] = 1` for all `i`.
2. Iterate through the array from left to right.
3. For each element at index `i`, update the `dp` table as follows:
	* If the current element is greater than the previous element by 1 (i.e., `arr[i] - arr[i-1] == 1`), then the longest beautiful subsequence ending at `i` can be extended by one element. Update `dp[i][j] = max(dp[i-1][k]) + 1` for all `k <= j`.
	* Otherwise, the longest beautiful subsequence ending at `i` has length 1. Update `dp[i][0] = 1`.
4. The maximum value in the last row of the `dp` table will be the length of the longest beautiful subsequence.

Time complexity: O(n)
Space complexity: O(j) where j is the maximum length of a beautiful subsequence

## Optimized Solutions
### Java
```
java
public int beautifulSubsequence(int[] arr) {
    int n = arr.length;
    int[][] dp = new int[n][n+1];
    for (int i = 0; i < n; i++) {
        dp[i][0] = 1;
    }
    int maxLen = 0;
    for (int i = 1; i < n; i++) {
        for (int j = Math.min(i, maxLen); j > 0; j--) {
            if (arr[i] - arr[i-1] == 1) {
                dp[i][j] = Math.max(dp[i-1][j-1], dp[i-1][j]) + 1;
            } else {
                dp[i][j] = 1;
            }
        }
    }
    return maxLen;
}
```

### Python
```
python
def beautiful_subsequence(arr):
    n = len(arr)
    dp = [[0] * (n+1) for _ in range(n)]
    for i in range(n):
        dp[i][0] = 1
    max_len = 0
    for i in range(1, n):
        for j in range(min(i, max_len), 0, -1):
            if arr[i] - arr[i-1] == 1:
                dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + 1
            else:
                dp[i][j] = 1
    return max_len
```

### C++
```
cpp
int beautifulSubsequence(int* arr, int n) {
    int** dp = new int*[n];
    for (int i = 0; i < n; i++) {
        dp[i] = new int[n+1];
        dp[i][0] = 1;
    }
    int maxLen = 0;
    for (int i = 1; i < n; i++) {
        for (int j = Math.min(i, maxLen); j > 0; j--) {
            if (arr[i] - arr[i-1] == 1) {
                dp[i][j] = std::max(dp[i-1][j-1], dp[i-1][j]) + 1;
            } else {
                dp[i][j] = 1;
            }
        }
    }
    int maxLenResult = 0;
    for (int i = 0; i < n; i++) {
        maxLenResult = std::max(maxLenResult, dp[i][n-1]);
    }
    return maxLenResult;
}
```

### JavaScript
```
javascript
function beautifulSubsequence(arr) {
    let n = arr.length;
    let dp = Array(n).fill().map(() => Array(n+1).fill(0));
    for (let i = 0; i < n; i++) {
        dp[i][0] = 1;
    }
    let maxLen = 0;
    for (let i = 1; i < n; i++) {
        for (let j = Math.min(i, maxLen); j > 0; j--) {
            if (arr[i] - arr[i-1] == 1) {
                dp[i][j] = Math.max(dp[i-1][j-1], dp[i-1][j]) + 1;
            } else {
                dp[i][j] = 1;
            }
        }
    }
    return maxLen;
}
```