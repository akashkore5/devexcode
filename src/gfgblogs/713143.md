---
id: "713143"
title: "Last modified ball"
slug: "last-modified-ball--170645"
difficulty: "Easy"
companyTags: []
tags: ["Mathematical", "Algorithms"]
---

**Last Modified Ball**
=====================

### Summary
Given a sequence of balls, each with its own modification time, find the ball that has been modified most recently. In this problem, we are asked to identify the last modified ball in a given sequence.

### Detailed Explanation
To solve this problem, we can iterate through the sequence and keep track of the maximum modification time seen so far. When we encounter a new ball with a modification time greater than our current maximum, we update our maximum.

Here's a step-by-step breakdown:

1. Initialize `max_time` to 0.
2. Iterate through the sequence of balls:
	* For each ball, check if its modification time is greater than `max_time`.
	* If it is, update `max_time` to be the current ball's modification time.
3. The last modified ball is the one with the maximum modification time.

Time complexity: O(n), where n is the number of balls in the sequence. We need to iterate through each ball once.

Space complexity: O(1), as we only use a constant amount of space to store `max_time`.

### Optimized Solutions

#### Java
```java
public class LastModifiedBall {
    public static Ball findLastModified(Ball[] balls) {
        int maxTime = 0;
        Ball lastModified = null;
        
        for (Ball ball : balls) {
            if (ball.getModificationTime() > maxTime) {
                maxTime = ball.getModificationTime();
                lastModified = ball;
            }
        }
        
        return lastModified;
    }
}
```

#### Python
```python
def find_last_modified(balls):
    max_time = 0
    last_modified = None
    
    for ball in balls:
        if ball.modification_time > max_time:
            max_time = ball.modification_time
            last_modified = ball
            
    return last_modified
```

#### C++
```cpp
class Ball {
public:
    int modificationTime;
};

Ball* findLastModified(Ball* balls, int size) {
    int maxTime = 0;
    Ball* lastModified = nullptr;
    
    for (int i = 0; i < size; i++) {
        if (balls[i].modificationTime > maxTime) {
            maxTime = balls[i].modificationTime;
            lastModified = &balls[i];
        }
    }
    
    return lastModified;
}
```

#### JavaScript
```javascript
function findLastModified(balls) {
    let maxTime = 0;
    let lastModified = null;
    
    for (const ball of balls) {
        if (ball.modificationTime > maxTime) {
            maxTime = ball.modificationTime;
            lastModified = ball;
        }
    }
    
    return lastModified;
}
```
In each solution, we iterate through the sequence of balls and keep track of the maximum modification time seen so far. When a new ball with a modification time greater than our current maximum is found, we update our maximum and store the corresponding ball as the last modified one.