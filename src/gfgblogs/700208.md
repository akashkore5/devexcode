---
id: "700208"
title: "Implement stack using array"
slug: "implement-stack-using-array"
difficulty: "Basic"
companyTags: ["FactSet", "Visa", "Goldman Sachs", "Qualcomm", "Kritikal Solutions"]
tags: ["Arrays", "Stack", "Data Structures"]
---

**Implement Stack using Array**
================================

### Summary
Implement a stack using an array. A stack is a linear data structure that follows the LIFO (Last In First Out) principle, meaning the last element added to the stack will be the first one to be removed. The key concepts involved in this problem are arrays and stacks.

### Detailed Explanation
To implement a stack using an array, we can create an array of a fixed size and use two pointers: `top` and `size`. The `top` pointer points to the top element of the stack, and the `size` pointer keeps track of the number of elements in the stack. When an element is pushed onto the stack, it's stored at the index pointed by `top`, which is then incremented. When an element is popped from the stack, the value at the index pointed by `top` is returned, and `top` is decremented.

Here's a step-by-step breakdown of the solution:

1. Initialize an array with a fixed size.
2. Set `top` to -1 (since arrays are 0-indexed) and `size` to 0.
3. When an element is pushed onto the stack:
	* Store the element at the index pointed by `top`.
	* Increment `top`.
	* Increment `size`.
4. When an element is popped from the stack:
	* Return the value at the index pointed by `top`.
	* Decrement `top`.
	* Decrement `size` if necessary (if the stack becomes empty).
5. Repeat steps 3 and 4 until the stack is empty or we want to check if the stack is full.

### Optimized Solutions

#### Java
```java
class Stack {
    private int[] array;
    private int top;
    private int size;

    public Stack(int capacity) {
        array = new int[capacity];
        top = -1;
        size = 0;
    }

    public void push(int value) {
        if (size == array.length) {
            // Handle stack overflow
        }
        array[++top] = value;
        size++;
    }

    public int pop() {
        if (size == 0) {
            // Handle empty stack
        }
        return array[top--];
    }
}
```

#### Python
```python
class Stack:
    def __init__(self, capacity):
        self.array = [None] * capacity
        self.top = -1
        self.size = 0

    def push(self, value):
        if self.size == len(self.array):
            # Handle stack overflow
        self.array[self.top + 1] = value
        self.top += 1
        self.size += 1

    def pop(self):
        if self.size == 0:
            # Handle empty stack
        return self.array[self.top]
        self.top -= 1
        self.size -= 1
```

#### C++
```cpp
class Stack {
public:
    Stack(int capacity) {
        array = new int[capacity];
        top = -1;
        size = 0;
    }

    void push(int value) {
        if (size == capacity) {
            // Handle stack overflow
        }
        array[++top] = value;
        size++;
    }

    int pop() {
        if (size == 0) {
            // Handle empty stack
        }
        return array[top--];
    }

private:
    int* array;
    int top;
    int size;
};
```

#### JavaScript
```javascript
class Stack {
    constructor(capacity) {
        this.array = new Array(capacity);
        this.top = -1;
        this.size = 0;
    }

    push(value) {
        if (this.size === this.array.length) {
            // Handle stack overflow
        }
        this.array[++this.top] = value;
        this.size++;
    }

    pop() {
        if (this.size === 0) {
            // Handle empty stack
        }
        return this.array[this.top--];
    }
}
```

Time complexity: O(1) for push and pop operations.
Space complexity: O(n), where n is the capacity of the array.