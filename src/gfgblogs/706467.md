---
id: "706467"
title: "First and last occurrences of x"
slug: "first-and-last-occurrences-of-x2041"
difficulty: "Easy"
companyTags: ["Amazon", "Microsoft"]
tags: ["Arrays", "Searching", "Binary Search", "Data Structures", "Algorithms"]
---

# First and Last Occurrences of x

## Summary
Given an array of distinct integers, find the first and last occurrences of a given target integer `x`. This problem involves searching for specific elements in an array, making it a classic problem in algorithmic programming. The key concept involved is binary search, which allows us to efficiently locate the desired elements.

## Detailed Explanation
To solve this problem, we will use binary search to find the first and last occurrences of `x` in the given array. Here's a step-by-step breakdown of the solution:

1. First, sort the input array in ascending order.
2. Initialize two variables `first_occurrence` and `last_occurrence` to negative infinity.
3. Perform a binary search on the sorted array to find the first occurrence of `x`. Start by considering the middle element of the array.
	* If the middle element is equal to `x`, update `first_occurrence` to the current index and move the search range to the left half of the array.
	* If the middle element is less than `x`, move the search range to the right half of the array.
	* If the middle element is greater than `x`, update `first_occurrence` to the current index and move the search range to the left half of the array.
4. Once we find the first occurrence, perform another binary search to find the last occurrence of `x`. Start by considering the middle element of the array.
	* If the middle element is equal to `x`, update `last_occurrence` to the current index and move the search range to the right half of the array.
	* If the middle element is less than `x`, move the search range to the left half of the array.
	* If the middle element is greater than `x`, update `last_occurrence` to the current index and move the search range to the right half of the array.
5. Return the values of `first_occurrence` and `last_occurrence`.

Time complexity: O(log n), where n is the length of the input array.

Space complexity: O(1), as we only use a constant amount of space to store the variables `first_occurrence`, `last_occurrence`, and the search range.

## Optimized Solutions

#### Java
```java
public class Solution {
    public int[] firstAndLastPosition(int[] arr, int x) {
        Arrays.sort(arr);
        int first = binarySearch(arr, x, true);
        int last = binarySearch(arr, x, false);
        return new int[]{first, last};
    }

    private int binarySearch(int[] arr, int x, boolean isFirst) {
        int low = 0;
        int high = arr.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] == x) {
                return isFirst ? mid : high;
            } else if (arr[mid] < x) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1; // not found
    }
}
```

#### Python
```python
def first_and_last_position(arr, x):
    arr.sort()
    first = binary_search(arr, x, True)
    last = binary_search(arr, x, False)
    return [first, last]

def binary_search(arr, x, is_first):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == x:
            return mid if is_first else high
        elif arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1
    return -1  # not found
```

#### C++
```cpp
class Solution {
public:
    vector<int> firstAndLastPosition(vector<int>& arr, int x) {
        sort(arr.begin(), arr.end());
        int first = binarySearch(arr, x, true);
        int last = binarySearch(arr, x, false);
        return {first, last};
    }

    int binarySearch(vector<int>& arr, int x, bool isFirst) {
        int low = 0;
        int high = arr.size() - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] == x) {
                return isFirst ? mid : high;
            } else if (arr[mid] < x) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1; // not found
    }
};
```

#### JavaScript
```javascript
function firstAndLastPosition(arr, x) {
  arr.sort((a, b) => a - b);
  let first = binarySearch(arr, x, true);
  let last = binarySearch(arr, x, false);
  return [first, last];
}

function binarySearch(arr, x, isFirst) {
  let low = 0;
  let high = arr.length - 1;
  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    if (arr[mid] === x) {
      return isFirst ? mid : high;
    } else if (arr[mid] < x) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return -1; // not found
}
```