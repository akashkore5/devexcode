---
id: "711971"
title: "Maximum Connected group"
slug: "maximum-connected-group"
difficulty: "Hard"
companyTags: []
tags: ["BFS", "Graph", "DFS", "Data Structures", "Algorithms"]
---

# Maximum Connected Group

## Summary

The problem is about finding the maximum connected group in a graph. Given an undirected graph and its adjacency list representation, we need to find the maximum connected subgraph (group) where all nodes are reachable from each other. This problem involves concepts like graphs, connectivity, and traversal algorithms.

## Detailed Explanation

To solve this problem, we can use Depth-First Search (DFS) or Breadth-First Search (BFS) algorithm with some modifications to track the connected groups. Here's a step-by-step approach:

1. Initialize an empty list `max_group` to store the maximum connected group.
2. Iterate over each node in the graph using DFS/BFS.
3. For each node, perform a separate traversal to find all reachable nodes (connected subgraph).
4. Calculate the size of the current connected subgraph by counting the number of visited nodes.
5. If the size of the current connected subgraph is greater than the size of `max_group`, update `max_group` with the new group.
6. Continue iterating over each node and updating `max_group` until all nodes have been processed.

Here's an ASCII art diagram illustrating the concept:
```
  A -- B -- C
 /      /\
|  D  |
/______\
```
In this example, the maximum connected group is {A, B, C, D}, which has a size of 4. The algorithm would identify this group and update `max_group` accordingly.

Time complexity: O(V + E), where V is the number of vertices (nodes) and E is the number of edges.
Space complexity: O(V), as we need to store information about each node during traversal.

## Optimized Solutions

### Java
```java
import java.util.*;

class Node {
    int id;
    List<Node> neighbors = new ArrayList<>();
}

public class Main {
    public static void main(String[] args) {
        // Initialize the graph
        Node A = new Node(1);
        Node B = new Node(2);
        Node C = new Node(3);
        Node D = new Node(4);

        A.neighbors.add(B);
        B.neighbors.add(A);
        B.neighbors.add(C);
        C.neighbors.add(B);
        C.neighbors.add(D);
        D.neighbors.add(C);

        // Find the maximum connected group
        int maxSize = 0;
        List<Node> maxGroup = null;

        for (Node node : new ArrayList<>(Arrays.asList(A, B, C, D))) {
            Set<Node> visited = new HashSet<>();
            findMaxConnectedGroup(node, visited);
            if (visited.size() > maxSize) {
                maxSize = visited.size();
                maxGroup = new ArrayList<>(visited);
            }
        }

        System.out.println("Maximum connected group: " + maxGroup);
    }

    private static void findMaxConnectedGroup(Node node, Set<Node> visited) {
        visited.add(node);

        for (Node neighbor : node.neighbors) {
            if (!visited.contains(neighbor)) {
                findMaxConnectedGroup(neighbor, visited);
            }
        }
    }
}
```

### Python
```python
class Node:
    def __init__(self, id):
        self.id = id
        self.neighbors = []

def main():
    # Initialize the graph
    A = Node(1)
    B = Node(2)
    C = Node(3)
    D = Node(4)

    A.neighbors.append(B)
    B.neighbors.extend([A, C])
    C.neighbors.extend([B, D])
    D.neighbors.append(C)

    # Find the maximum connected group
    max_size = 0
    max_group = None

    for node in [A, B, C, D]:
        visited = set()
        find_max_connected_group(node, visited)
        if len(visited) > max_size:
            max_size = len(visited)
            max_group = list(visited)

    print("Maximum connected group:", max_group)

def find_max_connected_group(node, visited):
    visited.add(node)

    for neighbor in node.neighbors:
        if neighbor not in visited:
            find_max_connected_group(neighbor, visited)

if __name__ == "__main__":
    main()
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <set>

using namespace std;

struct Node {
    int id;
    vector<Node*> neighbors;
};

void findMaxConnectedGroup(Node* node, set<Node*>& visited) {
    visited.insert(node);

    for (Node* neighbor : node->neighbors) {
        if (!visited.count(neighbor)) {
            findMaxConnectedGroup(neighbor, visited);
        }
    }
}

int main() {
    // Initialize the graph
    Node A = {1};
    Node B = {2};
    Node C = {3};
    Node D = {4};

    A.neighbors.push_back(&B);
    B.neighbors.push_back(&A);
    B.neighbors.push_back(&C);
    C.neighbors.push_back(&B);
    C.neighbors.push_back(&D);
    D.neighbors.push_back(&C);

    // Find the maximum connected group
    int maxSize = 0;
    set<Node*> maxGroup;

    for (Node* node : {&A, &B, &C, &D}) {
        set<Node*> visited;
        findMaxConnectedGroup(node, visited);
        if (visited.size() > maxSize) {
            maxSize = visited.size();
            maxGroup = visited;
        }
    }

    cout << "Maximum connected group: ";
    for (Node* node : maxGroup) {
        cout << node->id << " ";
    }
    cout << endl;

    return 0;
}
```

### JavaScript
```javascript
class Node {
    constructor(id, neighbors = []) {
        this.id = id;
        this.neighbors = neighbors;
    }
}

function findMaxConnectedGroup(node, visited) {
    visited.add(node);

    for (const neighbor of node.neighbors) {
        if (!visited.has(neighbor)) {
            findMaxConnectedGroup(neighbor, visited);
        }
    }
}

let A = new Node(1);
let B = new Node(2);
let C = new Node(3);
let D = new Node(4);

A.neighbors.push(B);
B.neighbors.push(A);
B.neighbors.push(C);
C.neighbors.push(B);
C.neighbors.push(D);
D.neighbors.push(C);

let maxSize = 0;
let maxGroup = null;

for (const node of [A, B, C, D]) {
    let visited = new Set();
    findMaxConnectedGroup(node, visited);
    if (visited.size > maxSize) {
        maxSize = visited.size;
        maxGroup = Array.from(visited);
    }
}

console.log(`Maximum connected group: ${maxGroup}`);
```

Note that these optimized solutions use the same algorithmic approach as described in the "Detailed Explanation" section.