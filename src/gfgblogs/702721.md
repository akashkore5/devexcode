---
id: "702721"
title: "Professor and Parties"
slug: "professor-and-parties2000"
difficulty: "Easy"
companyTags: ["Amazon"]
tags: ["Arrays", "Data Structures"]
---

Here is a detailed Markdown blog post for the "Professor and Parties" problem:

**Professor and Parties**
=====================

### Summary

The Professor and Parties problem involves a professor who wants to organize parties with his students. The professor has `n` students, each having a unique number of friends they can invite to their party. The goal is to find out how many parties the professor can hold in total if he allows each student to invite as many friends as they want.

### Detailed Explanation

Let's break down this problem step by step:

1. First, we need to understand that each student has a unique number of friends they can invite to their party.
2. We also know that there are `n` students in total.
3. To solve this problem, we can iterate over the students and for each student, find out how many parties he/she can hold considering his/her friend count.
4. For each party, we need to consider only one student's friends (i.e., invitees) as they are not counted again.

We can use a simple array or list in our chosen programming language to solve this problem.

Time complexity: O(n)
Space complexity: O(1)

### Optimized Solutions

Here are the optimized solutions in different programming languages:

#### Java
```java
public class ProfessorAndParties {
    public static int findParties(int[] friends) {
        int totalParties = 0;
        for (int friendCount : friends) {
            totalParties += friendCount;
        }
        return totalParties;
    }
}
```

#### Python
```python
def find_parties(friends):
    total_parties = 0
    for friend_count in friends:
        total_parties += friend_count
    return total_parties
```

#### C++
```cpp
#include <vector>

int findParties(std::vector<int>& friends) {
    int totalParties = 0;
    for (int friendCount : friends) {
        totalParties += friendCount;
    }
    return totalParties;
}
```

#### JavaScript
```javascript
function findParties(friends) {
    let totalParties = 0;
    for (let friendCount of friends) {
        totalParties += friendCount;
    }
    return totalParties;
}
```
These solutions all have the same time and space complexity, as described above.