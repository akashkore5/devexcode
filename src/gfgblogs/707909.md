---
id: "707909"
title: "Find the String"
slug: "find-the-string"
difficulty: "Hard"
companyTags: ["Google"]
tags: ["Strings", "Graph", "Backtracking", "Data Structures", "Algorithms"]
---

# Find the String
## Slug: find-the-string
## Difficulty: Hard
## Id: 707909
## Topic Tags: Strings, Graph, Backtracking, Data Structures, Algorithms
## Company Tags: Google

### Summary
Given a set of strings and their corresponding frequencies, find a string that can be used to create all other strings by replacing certain characters. The frequency of each character in the target string must match its frequency in the original strings.

The problem involves graph traversal, backtracking, and data structures. We will use a combination of these concepts to solve this problem efficiently.

### Detailed Explanation
We start by creating an adjacency list representation of the graph where nodes represent characters and edges represent possible replacements between strings. For each string, we create an edge from its last character to all other characters that have the same frequency in the original strings.

Next, we perform a depth-first search (DFS) starting from any node to traverse the graph. During the traversal, we keep track of the current string and its frequency. When we encounter a node with the same frequency as the current string, we can potentially replace the last character of the current string with this new character.

We use backtracking to explore different replacement options. For each possible replacement, we recursively traverse the graph to check if there's another string that can be created by replacing characters. If not, we backtrack and try another replacement option until we find a solution or exhaust all possibilities.

Time complexity analysis: The time complexity is O(N * M), where N is the number of strings and M is the maximum length of a string.

Space complexity analysis: The space complexity is O(M), as we need to store the frequency of each character in the target string.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class FindTheString {
    public static String findString(String[] strings, int[] frequencies) {
        Map<Character, Integer> graph = new HashMap<>();
        for (int i = 0; i < strings.length; i++) {
            char lastChar = strings[i].charAt(strings[i].length() - 1);
            graph.put(lastChar, frequencies[i]);
        }

        for (int i = 0; i < strings.length; i++) {
            for (char c : strings[i].toCharArray()) {
                if (!graph.containsKey(c)) {
                    graph.put(c, frequencies[i]);
                }
            }
        }

        Set<Character> visited = new HashSet<>();
        String result = "";
        findString(graph, visited, "", result);
        return result;
    }

    private static void findString(Map<Character, Integer> graph, Set<Character> visited, String current, String result) {
        if (graph.isEmpty()) {
            System.out.println(result);
            return;
        }

        for (Map.Entry<Character, Integer> entry : graph.entrySet()) {
            char c = entry.getKey();
            int frequency = entry.getValue();

            if (!visited.contains(c)) {
                visited.add(c);

                // Try replacing the last character with this new character
                String newString = current + c;
                findString(graph, visited, newString, result);

                visited.remove(c);
            }
        }
    }
}
```

#### Python
```python
def find_string(strings, frequencies):
    graph = {}
    for s in strings:
        last_char = s[-1]
        if last_char not in graph:
            graph[last_char] = frequencies[s.index(last_char)]
        else:
            graph[last_char][0] += 1

    for c in set(''.join(strings)):
        if c not in graph:
            graph[c] = [0, frequencies.count(c)]

    visited = set()
    result = ''

    def dfs(graph, visited, current, result):
        nonlocal result
        if not graph:
            print(result)
            return

        for c, freq in graph.items():
            if c not in visited:
                visited.add(c)

                new_string = current + c
                dfs(graph, visited, new_string, result)

                visited.remove(c)

    dfs(graph, visited, '', result)
```

#### C++
```cpp
#include <iostream>
#include <string>
#include <map>
#include <set>

using namespace std;

void findString(map<char, int> graph, set<char> visited, string current, string& result) {
    if (graph.empty()) {
        cout << result << endl;
        return;
    }

    for (auto& entry : graph) {
        char c = entry.first;
        int frequency = entry.second;

        if (!visited.count(c)) {
            visited.insert(c);

            // Try replacing the last character with this new character
            string newString = current + c;
            findString(graph, visited, newString, result);

            visited.erase(c);
        }
    }
}

string findTheString(string[] strings, int[] frequencies) {
    map<char, int> graph;
    for (int i = 0; i < strings.length; i++) {
        char lastChar = strings[i].charAt(strings[i].length() - 1);
        if (!graph.count(lastChar)) {
            graph[lastChar] = frequencies[i];
        } else {
            graph[lastChar][0]++;
        }
    }

    for (char c : set<string>("".join(strings)).toArray()) {
        if (!graph.count(c)) {
            graph[c] = new int[] { 0, frequencies.count(c) };
        }
    }

    set<char> visited;
    string result = "";

    findString(graph, visited, "", result);
    return result;
}
```

#### JavaScript
```javascript
function findTheString(strings, frequencies) {
    const graph = {};
    for (let i = 0; i < strings.length; i++) {
        const lastChar = strings[i].slice(-1);
        if (!graph[lastChar]) {
            graph[lastChar] = frequencies[i];
        } else {
            graph[lastChar][0]++;
        }
    }

    for (let c of new Set(strings.join(''))) {
        if (!graph[c]) {
            graph[c] = [0, frequencies.filter(f => f === c).length];
        }
    }

    let visited = new Set();
    let result = '';

    function dfs(graph, visited, current, result) {
        if (Object.keys(graph).length === 0) {
            console.log(result);
            return;
        }

        for (let [c, freq] of Object.entries(graph)) {
            if (!visited.has(c)) {
                visited.add(c);

                const newString = current + c;
                dfs(graph, visited, newString, result);

                visited.delete(c);
            }
        }
    }

    dfs(graph, visited, '', result);
}
```

Note that the optimized solutions are provided in different programming languages. The main idea is to create a graph representation of the problem and then perform DFS traversal to find the target string.