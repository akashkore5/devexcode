---
id: "715457"
title: "Find Kth permutation"
slug: "find-kth-permutation-0932"
difficulty: "Medium"
companyTags: []
tags: ["Backtracking", "Algorithms"]
---

# Find Kth Permutation
## Slug: find-kth-permutation-0932
## Difficulty: Medium
## Id: 715457
## Topic Tags: Backtracking, Algorithms
## Company Tags: None

### Summary
Given a string S and an integer K, write a function to generate the Kth permutation of the characters in S. The permutations are generated in lexicographic sort order.

### Detailed Explanation
To solve this problem, we can use backtracking algorithm. The idea is to generate all permutations of the string and return the Kth one. We start by selecting the smallest character that has not been used yet and place it at the beginning of the permutation. Then, we recursively generate all remaining permutations for the remaining characters.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty string `perm` to store the Kth permutation.
2. Sort the input string S in ascending order.
3. For each character `c` in S:
   - If `k` is greater than 0, append `c` to `perm` and decrement `k`.
   - Recursively generate all permutations for the remaining characters (i.e., S without `c`) until `k` becomes 0.
4. Return `perm`.

The time complexity of this algorithm is O(n!), where n is the length of the input string, because we need to generate all permutations. The space complexity is O(n), because we need to store the permutation.

### Optimized Solutions

#### Java
```java
public String findKthPermutation(String s, int k) {
    char[] chars = s.toCharArray();
    Arrays.sort(chars);
    StringBuilder perm = new StringBuilder();
    backtrack(chars, k, perm);
    return perm.toString();
}

private void backtrack(char[] chars, int k, StringBuilder perm) {
    if (k == 1) {
        for (char c : chars) {
            perm.append(c);
        }
    } else {
        for (int i = 0; i < chars.length; i++) {
            char c = chars[i];
            chars = Arrays.copyOfRange(chars, i + 1, chars.length);
            backtrack(chars, k - 1, perm);
            perm.append(c);
        }
    }
}
```

#### Python
```python
def find_kth_permutation(s, k):
    chars = list(s)
    chars.sort()
    permutation = ''
    backtrack(chars, k, permutation)
    return permutation

def backtrack(chars, k, permutation):
    if k == 1:
        for c in chars:
            permutation += c
    else:
        for i in range(len(chars)):
            c = chars[i]
            chars = chars[:i] + chars[i+1:]
            backtrack(chars, k - 1, permutation)
            permutation += c
```

#### C++
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

string findKthPermutation(string s, int k) {
    char chars[s.length()];
    strcpy((char*)chars, s.c_str());
    sort(chars, chars + s.length());
    string perm = "";
    backtrack(chars, k, perm);
    return perm;
}

void backtrack(char* chars, int k, string& perm) {
    if (k == 1) {
        for (int i = 0; i < strlen((char*)chars); i++) {
            perm += chars[i];
        }
    } else {
        for (int i = 0; i < strlen((char*)chars); i++) {
            char c = chars[i];
            int j = i;
            while (j < strlen((char*)chars)) {
                chars[j] = chars[j + 1];
                j++;
            }
            backtrack(chars, k - 1, perm);
            perm += c;
        }
    }
}
```

#### JavaScript
```javascript
function findKthPermutation(s, k) {
    let chars = [...s];
    chars.sort((a, b) => a.localeCompare(b));
    let permutation = '';
    backtrack(chars, k, permutation);
    return permutation;

  function backtrack(chars, k, permutation) {
    if (k === 1) {
      for (let c of chars) {
        permutation += c;
      }
    } else {
      for (let i = 0; i < chars.length; i++) {
        let c = chars[i];
        let j = i;
        while (j < chars.length) {
          chars[j] = chars[j + 1];
          j++;
        }
        backtrack(chars, k - 1, permutation);
        permutation += c;
      }
    }
  }
```
Note: The optimized solutions are provided in different programming languages.