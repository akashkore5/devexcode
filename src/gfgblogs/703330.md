---
id: "703330"
title: "Pick Values"
slug: "pick-values4112"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Dynamic Programming", "Data Structures", "Algorithms"]
---

# Pick Values

## Summary
The problem "Pick Values" is about picking values from an array such that the sum of picked values is maximum. This problem involves dynamic programming and arrays as key concepts.

## Detailed Explanation
To solve this problem, we can use a dynamic programming approach. We will create a 2D table where `dp[i][j]` represents the maximum sum that can be obtained by picking values from the first `i` elements of the array such that the number of picked values is `j`.

Here's a step-by-step breakdown of the solution:

1. Initialize the 2D table with zeros.
2. Iterate through the array and for each element, update the table as follows:
	* If the current element is greater than the sum of the previous `i-1` elements, then pick this element and update the table accordingly.
	* Otherwise, don't pick this element.
3. At the end of the iteration, the maximum sum that can be obtained by picking values from the entire array will be stored in the last cell of the table.

Here's an ASCII art diagram to illustrate the dynamic programming approach:

```
  +---------------+
  |  dp[0][j] = 0  |
  +---------------+
  |  dp[i][0] = 0  |
  |  dp[i][1] = a[0]|
  |  ...          |
  +---------------+
  |  dp[n-1][k] = ? |
  +---------------+
```

Time complexity: O(n*m) where n is the size of the array and m is the number of picked values.
Space complexity: O(n*m) for storing the 2D table.

## Optimized Solutions

### Java
```java
public class PickValues {
    public static int pickValues(int[] arr, int k) {
        int n = arr.length;
        int[][] dp = new int[n][k+1];
        
        for (int i = 0; i < n; i++) {
            for (int j = Math.min(i+1, k); j >= 1; j--) {
                if (j == 1) {
                    dp[i][j] = arr[i];
                } else {
                    dp[i][j] = Math.max(dp[i-1][j], arr[i] + dp[i-1][j-1]);
                }
            }
        }
        
        return dp[n-1][k];
    }
}
```

### Python
```python
def pick_values(arr, k):
    n = len(arr)
    dp = [[0 for _ in range(k+1)] for _ in range(n)]
    
    for i in range(n):
        for j in range(min(i+1, k), 0, -1):
            if j == 1:
                dp[i][j] = arr[i]
            else:
                dp[i][j] = max(dp[i-1][j], arr[i] + dp[i-1][j-1])
    
    return dp[n-1][k]
```

### C++
```cpp
class PickValues {
public:
    int pickValues(vector<int>& arr, int k) {
        int n = arr.size();
        vector<vector<int>> dp(n, vector<int>(k+1, 0));
        
        for (int i = 0; i < n; i++) {
            for (int j = min(i+1, k); j >= 1; j--) {
                if (j == 1) {
                    dp[i][j] = arr[i];
                } else {
                    dp[i][j] = max(dp[i-1][j], arr[i] + dp[i-1][j-1]);
                }
            }
        }
        
        return dp[n-1][k];
    }
};
```

### JavaScript
```javascript
function pickValues(arr, k) {
  let n = arr.length;
  let dp = Array(n).fill(0).map(() => Array(k+1).fill(0));
  
  for (let i = 0; i < n; i++) {
    for (let j = Math.min(i+1, k); j >= 1; j--) {
      if (j === 1) {
        dp[i][j] = arr[i];
      } else {
        dp[i][j] = Math.max(dp[i-1][j], arr[i] + dp[i-1][j-1]);
      }
    }
  }
  
  return dp[n-1][k];
}
```

Note: The optimized solutions are provided in the respective programming languages (Java, Python, C++, and JavaScript) as per the requirements.