---
id: "712223"
title: "Combination Sum II"
slug: "combination-sum-ii-1664263832"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Recursion", "Data Structures", "Algorithms", "Backtracking"]
---

**Combination Sum II**
================================

## Summary
Given a set of integers, find all unique combinations that sum up to a given target value. This problem is an extension of the classic "combination sum" problem, where the constraint is added that each combination should be in sorted order.

The key concepts involved are arrays, recursion, and backtracking.

## Detailed Explanation
We can solve this problem by using a recursive approach with backtracking. The basic idea is to start from the smallest number and try to add it to the current combination until we reach the target sum. If adding the current number exceeds the target sum, we backtrack and move on to the next smaller number.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty list `result` to store all unique combinations.
2. Define a recursive function `findCombinations` that takes three parameters: `nums`, `target`, and `start`. `nums` is the set of integers, `target` is the target sum, and `start` is the starting index for the current combination.
3. In the `findCombinations` function:
	* If the current sum exceeds the target sum, return immediately to backtrack.
	* Iterate through the numbers from `start` to the end of the array.
	* For each number, try adding it to the current combination and recursively call `findCombinations` with the updated sum and starting index.
	* If the recursive call returns a valid combination, add it to the result list.
4. Finally, return the result list.

Time complexity: O(N * 2^N), where N is the length of the input array. This is because in the worst case, we might have to explore all possible combinations.

Space complexity: O(N), for storing the result list and recursive call stack.

## Optimized Solutions

### Java
```java
import java.util.*;

public class CombinationSumII {
    public List<List<Integer>> combinationSum2(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        findCombinations(nums, target, 0, new ArrayList<>(), result);
        return result;
    }

    private void findCombinations(int[] nums, int target, int start, List<Integer> combination, List<List<Integer>> result) {
        if (target < 0) return;
        if (target == 0) result.add(new ArrayList<>(combination));
        for (int i = start; i < nums.length; i++) {
            if (i > start && nums[i] == nums[i-1]) continue;
            combination.add(nums[i]);
            findCombinations(nums, target - nums[i], i + 1, combination, result);
            combination.remove(combination.size() - 1);
        }
    }
}
```

### Python
```python
class CombinationSumII:
    def combinationSum2(self, nums: List[int], target: int) -> List[List[int]]:
        nums.sort()
        result = []
        self.findCombinations(nums, target, 0, [], result)
        return result

    def findCombinations(self, nums, target, start, combination, result):
        if target < 0:
            return
        if target == 0:
            result.append(list(combination))
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[i-1]:
                continue
            combination.append(nums[i])
            self.findCombinations(nums, target - nums[i], i + 1, combination, result)
            combination.pop()
```

### C++
```cpp
class CombinationSumII {
public:
    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        findCombinations(nums, target, 0, {}, result);
        return result;
    }

    void findCombinations(vector<int>& nums, int target, int start, unordered_map<int, bool> combination, vector<vector<int>>& result) {
        if (target < 0) return;
        if (target == 0) result.push_back(vector<int>(combination.begin(), combination.end()));
        for (int i = start; i < nums.size(); i++) {
            if (i > start && nums[i] == nums[i-1]) continue;
            combination[nums[i]] = true;
            findCombinations(nums, target - nums[i], i + 1, combination, result);
            combination.erase(combination.find(nums[i]));
        }
    }
};
```

### JavaScript
```javascript
class CombinationSumII {
  combinationSum2(nums, target) {
    nums.sort((a, b) => a - b);
    let result = [];
    this.findCombinations(nums, target, 0, [], result);
    return result;
  }

  findCombinations(nums, target, start, combination, result) {
    if (target < 0) return;
    if (target === 0) result.push([...combination]);
    for (let i = start; i < nums.length; i++) {
      if (i > start && nums[i] === nums[i-1]) continue;
      combination.push(nums[i]);
      this.findCombinations(nums, target - nums[i], i + 1, combination, result);
      combination.pop();
    }
  }
}
```