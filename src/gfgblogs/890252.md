---
id: "890252"
title: "Stable Marriage Problem"
slug: "stable-marriage-problem"
difficulty: "Medium"
companyTags: []
tags: ["Greedy", "Data Structures", "Algorithms"]
---

# Stable Marriage Problem
## Slug: stable-marriage-problem
## Difficulty: Medium
## Id: 890252
## Topic Tags: Greedy, Data Structures, Algorithms
## Company Tags: None


### Summary

The Stable Marriage Problem is a classic problem in computer science that involves matching individuals from two distinct groups based on their preferences. The goal is to find a stable matching between the individuals such that no individual prefers someone they are matched with over their current partner. This problem is known for its greedy algorithmic approach and is often used to model real-world scenarios, such as college admissions or job placements.

### Detailed Explanation

The Stable Marriage Problem can be formulated as follows: we have two groups of people - men (M) and women (W), each with a preference list ranking the individuals in the other group. The goal is to find a matching between the individuals that satisfies certain conditions:

1. Each person is matched with someone they prefer over being unmatched.
2. No individual prefers someone they are matched with over their current partner.

To solve this problem, we use a greedy algorithmic approach that involves iterating through the preference lists and making matches based on the preferences. Here's a step-by-step breakdown of the solution:

1. Initialize an empty matching table.
2. Sort the individuals in each group by their preference scores (i.e., the number of people they prefer over being unmatched).
3. Iterate through the sorted lists:
	* For each man, find the woman he prefers most and hasn't been matched with yet.
	* For each woman, find the man she prefers most and hasn't been matched with yet.
	* If a man is already matched with someone he prefers less than his current partner, move him to his preferred partner. Similarly, if a woman is already matched with someone she prefers less than her current partner, move her to her preferred partner.
4. Repeat step 3 until no more moves can be made.

The time complexity of this algorithm is O(n log n), where n is the number of individuals in each group. The space complexity is O(n), as we need to store the matching table.

### Optimized Solutions

#### Java
```java
public class StableMarriage {
    public static void findMatching(int[][] men, int[][] women) {
        // Sort the preference lists for each individual
        Arrays.sort(men);
        Arrays.sort(women);

        // Initialize the matching table
        boolean[][] matches = new boolean[men.length][women.length];

        // Iterate through the sorted lists and make matches
        for (int i = 0; i < men.length; i++) {
            int manPref = men[i][0];
            int womanPref = women[manPref][1];
            if (!matches[manPref][womanPref]) {
                matches[manPref][womanPref] = true;
                // Update the preference lists
                for (int j = 1; j < men.length; j++) {
                    manPref = men[j][0];
                    womanPref = women[manPref][1];
                    if (!matches[manPref][womanPref]) {
                        matches[manPref][womanPref] = true;
                        break;
                    }
                }
            }
        }
    }
}
```

#### Python
```python
def find_matching(men, women):
    # Sort the preference lists for each individual
    men.sort()
    women.sort()

    # Initialize the matching table
    matches = [[False for _ in range(len(women))] for _ in range(len(men))]

    # Iterate through the sorted lists and make matches
    for manPref, womanPref in zip(*men):
        if not matches[manPref][womanPref]:
            matches[manPref][womanPref] = True
            # Update the preference lists
            for i in range(1, len(men)):
                manPref, womanPref = men[i]
                if not matches[manPref][womanPref]:
                    matches[manPref][womanPref] = True
                    break

    return matches
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

void findMatching(vector<vector<int>>& men, vector<vector<int>>& women) {
    // Sort the preference lists for each individual
    sort(men.begin(), men.end());
    sort(women.begin(), women.end());

    // Initialize the matching table
    vector<vector<bool>> matches(men.size(), vector<bool>(women.size()));

    // Iterate through the sorted lists and make matches
    for (int i = 0; i < men.size(); i++) {
        int manPref = men[i][0];
        int womanPref = women[manPref][1];
        if (!matches[manPref][womanPref]) {
            matches[manPref][womanPref] = true;
            // Update the preference lists
            for (int j = 1; j < men.size(); j++) {
                manPref = men[j][0];
                womanPref = women[manPref][1];
                if (!matches[manPref][womanPref]) {
                    matches[manPref][womanPref] = true;
                    break;
                }
            }
        }
    }
}
```

#### JavaScript
```javascript
function findMatching(men, women) {
  // Sort the preference lists for each individual
  men.sort((a, b) => a[0] - b[0]);
  women.sort((a, b) => a[1] - b[1]);

  // Initialize the matching table
  let matches = new Array(men.length).fill().map(() => new Array(women.length).fill(false));

  // Iterate through the sorted lists and make matches
  for (let i = 0; i < men.length; i++) {
    let manPref = men[i][0];
    let womanPref = women[manPref][1];
    if (!matches[i][womanPref]) {
      matches[i][womanPref] = true;
      // Update the preference lists
      for (let j = 1; j < men.length; j++) {
        manPref = men[j][0];
        womanPref = women[manPref][1];
        if (!matches[j][womanPref]) {
          matches[j][womanPref] = true;
          break;
        }
      }
    }
  }

  return matches;
}
```