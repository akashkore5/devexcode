---
id: "713152"
title: "Maximum Weight Node"
slug: "maximum-weight-node--170645"
difficulty: "Easy"
companyTags: ["JUSPAY"]
tags: ["Arrays", "Graph", "Data Structures"]
---

**Maximum Weight Node**
=====================

**Slug:** maximum-weight-node--170645
**Difficulty:** Easy
**Id:** 713152
**Topic Tags:** Arrays, Graph, Data Structures
**Company Tags:** JUSPAY

## Summary
Given a connected graph and its weights, find the node with the maximum weight. The graph is represented as an adjacency list, where each node is associated with its neighbors and their corresponding weights.

The key concepts involved in this problem are arrays, graphs, and data structures.

## Detailed Explanation
To solve this problem, we can use a simple approach: iterate through all nodes, calculate the total weight of each node by summing up the weights of its neighbors, and keep track of the node with the maximum weight.

Here's a step-by-step breakdown of the solution:

1. Initialize a variable `max_weight` to store the maximum weight found so far.
2. Iterate through all nodes in the graph.
3. For each node, calculate its total weight by summing up the weights of its neighbors.
4. If the calculated weight is greater than `max_weight`, update `max_weight`.
5. After iterating through all nodes, return the node with the maximum weight.

The time complexity of this solution is O(n + m), where n is the number of nodes and m is the total number of edges in the graph. The space complexity is O(1) since we only need to keep track of a single variable `max_weight`.

Here's an ASCII art diagram representing the graph:
```
A -- 2 --> B
|    |
C -- 3 --> D
|    |
E -- 4 --> F
```
In this example, the maximum weight node is E with a total weight of 7 (4 + 3).

## Optimized Solutions

### Java
```java
public int maxWeightNode(int[][] graph) {
    int maxWeight = 0;
    for (int i = 0; i < graph.length; i++) {
        int weight = 0;
        for (int j = 0; j < graph[i].length; j++) {
            if (graph[i][j] > 0) {
                weight += graph[i][j];
            }
        }
        if (weight > maxWeight) {
            maxWeight = weight;
        }
    }
    return maxWeight;
}
```

### Python
```python
def max_weight_node(graph):
    max_weight = 0
    for node in graph:
        weight = sum(neighbor for neighbor, edge_weight in node.items() if edge_weight > 0)
        if weight > max_weight:
            max_weight = weight
    return max_weight
```

### C++
```cpp
int maxWeightNode(int** graph, int n) {
    int maxWeight = 0;
    for (int i = 0; i < n; i++) {
        int weight = 0;
        for (int j = 0; j < n; j++) {
            if (graph[i][j] > 0) {
                weight += graph[i][j];
            }
        }
        if (weight > maxWeight) {
            maxWeight = weight;
        }
    }
    return maxWeight;
}
```

### JavaScript
```javascript
function maxWeightNode(graph) {
    let maxWeight = 0;
    for (let node in graph) {
        let weight = 0;
        for (let neighbor in graph[node]) {
            if (graph[node][neighbor] > 0) {
                weight += graph[node][neighbor];
            }
        }
        if (weight > maxWeight) {
            maxWeight = weight;
        }
    }
    return maxWeight;
}
```

Note that the optimized solutions are provided in different programming languages, but the algorithm remains the same.