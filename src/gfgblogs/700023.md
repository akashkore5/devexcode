---
id: "700023"
title: "Rotate a Linked List"
slug: "rotate-a-linked-list"
difficulty: "Medium"
companyTags: ["Accolite", "Amazon", "Microsoft", "MakeMyTrip"]
tags: ["Linked List", "Data Structures"]
---

Here is a detailed Markdown blog post for the problem "Rotate a Linked List" on GeeksforGeeks:

# Rotate a Linked List
## Slug: rotate-a-linked-list
## Difficulty: Medium
## Id: 700023
## Topic Tags: Linked List, Data Structures
## Company Tags: Accolite, Amazon, Microsoft, MakeMyTrip

## Summary
Rotate a linked list by k steps is a common problem in computer science. Given the head of a singly linked list and an integer k, return the head of the rotated linked list.

## Detailed Explanation
To solve this problem, we will first analyze the problem statement and understand what it means to rotate a linked list. Rotating a linked list by k steps essentially means that we are moving the last k nodes to the front of the list. For example, if the original list is 1 -> 2 -> 3 -> 4 -> 5 and we want to rotate it by 2 steps, the resulting list will be 4 -> 5 -> 1 -> 2 -> 3.

Here's a step-by-step breakdown of the solution:

* First, we need to find the new tail of the rotated list. This is the node that was previously at position k.
* Next, we need to update the next pointer of the new tail to point to the original head of the list. This effectively moves the last k nodes to the front of the list.
* Finally, we return the new head of the rotated list, which is the node that was previously at position k-1.

Here's a diagram illustrating the rotation:
```
  Original List:   1 -> 2 -> 3 -> 4 -> 5
  Rotation by 2:   4 -> 5 -> 1 -> 2 -> 3

```

The time complexity of this solution is O(n), where n is the length of the linked list, because we need to traverse the entire list once. The space complexity is O(1) because we only use a constant amount of space to store the new head and tail.

## Optimized Solutions

### Java
```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null) {
            return head;
        }

        int len = 0;
        ListNode curr = head;
        while (curr != null) {
            len++;
            curr = curr.next;
        }

        k = k % len;

        ListNode newTail = head;
        for (int i = 0; i < len - k - 1; i++) {
            newTail = newTail.next;
        }

        ListNode newHead = newTail.next;
        newTail.next = null;

        return newHead;
    }
}
```

### Python
```python
class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if not head or not head.next:
            return head

        len = 0
        curr = head
        while curr:
            len += 1
            curr = curr.next

        k %= len

        new_tail = head
        for _ in range(len - k - 1):
            new_tail = new_tail.next

        new_head = new_tail.next
        new_tail.next = None

        return new_head
```

### C++
```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }

        int len = 0;
        ListNode* curr = head;
        while (curr != nullptr) {
            len++;
            curr = curr->next;
        }

        k = k % len;

        ListNode* newTail = head;
        for (int i = 0; i < len - k - 1; i++) {
            newTail = newTail->next;
        }

        ListNode* newHead = newTail->next;
        newTail->next = nullptr;

        return newHead;
    }
};
```

### JavaScript
```javascript
class Solution {
  rotateRight(head, k) {
    if (!head || !head.next) {
      return head;
    }

    let len = 0;
    let curr = head;
    while (curr) {
      len++;
      curr = curr.next;
    }

    k = k % len;

    let newTail = head;
    for (let i = 0; i < len - k - 1; i++) {
      newTail = newTail.next;
    }

    let newHead = newTail.next;
    newTail.next = null;

    return newHead;
  }
}
```

Note that the optimized solutions in each language are similar, with some minor differences due to language-specific syntax and semantics.