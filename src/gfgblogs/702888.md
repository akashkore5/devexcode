---
id: "702888"
title: "Bird and maximum fruit gathering"
slug: "bird-and-maximum-fruit-gathering0509"
difficulty: "Easy"
companyTags: ["Facebook"]
tags: ["Arrays", "Data Structures", "sliding-window", "two-pointer-algorithm"]
---

**Bird and maximum fruit gathering**
===============================

## Summary
The problem is to find the maximum number of fruits that can be gathered by a bird from a series of trees, given the positions and types of fruits on each tree. The bird can only gather one type of fruit at a time and must move to an adjacent tree after gathering the current fruit.

## Detailed Explanation

To solve this problem, we will use a sliding window approach with two pointers. We will maintain two pointers, `left` and `right`, that represent the start and end of our current window. Initially, both pointers are set to 0, indicating the first tree.

We iterate through the trees, moving the right pointer to the next tree when we gather a fruit from the current tree. When we gather a fruit, we check if it is the same type as the previous fruit gathered. If not, we move the left pointer to the current tree and update the count of fruits gathered.

Here's a step-by-step breakdown:

1. Initialize `left` and `right` pointers to 0.
2. Iterate through the trees:
	* For each tree, check if it has fruits of the same type as the previous tree (if `left` pointer is not at the start).
	* If yes, move the `right` pointer to the next tree.
	* If no, move the `left` pointer to the current tree and update the count of fruits gathered.
3. Repeat step 2 until all trees have been processed.

The time complexity of this approach is O(n), where n is the number of trees, since we only need to iterate through each tree once. The space complexity is O(1) as we are not using any extra space that scales with the input size.

Here's a diagram illustrating the sliding window approach:

```
          +---------------+
          |  Tree 0     |
          +---------------+
                  ^
                  | (left pointer)
          +---------------+
          |  Tree 1     |
          +---------------+
                  ^
                  | (right pointer)
          +---------------+
          |  Tree 2     |
          +---------------+
                  ...
```

## Optimized Solutions

### Java
```java
public int birdAndFruit(int[] positions, char[][] types) {
    int maxFruits = 0;
    int left = 0;
    for (int right = 0; right < positions.length; right++) {
        if (right > 0 && types[right][0] != types[left][0]) {
            left = right;
        }
        maxFruits = Math.max(maxFruits, right - left + 1);
    }
    return maxFruits;
}
```

### Python
```python
def bird_and_fruit(positions, types):
    max_fruits = 0
    left = 0
    for right in range(len(positions)):
        if right > 0 and types[right][0] != types[left][0]:
            left = right
        max_fruits = max(max_fruits, right - left + 1)
    return max_fruits
```

### C++
```cpp
int birdAndFruit(int* positions, char** types, int n) {
    int maxFruits = 0;
    int left = 0;
    for (int right = 0; right < n; right++) {
        if (right > 0 && types[right][0] != types[left][0]) {
            left = right;
        }
        maxFruits = std::max(maxFruits, right - left + 1);
    }
    return maxFruits;
}
```

### JavaScript
```javascript
function birdAndFruit(positions, types) {
    let maxFruits = 0;
    let left = 0;
    for (let right = 0; right < positions.length; right++) {
        if (right > 0 && types[right][0] !== types[left][0]) {
            left = right;
        }
        maxFruits = Math.max(maxFruits, right - left + 1);
    }
    return maxFruits;
}
```