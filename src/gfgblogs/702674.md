---
id: "702674"
title: "Merge and Sort"
slug: "merge-and-sort5821"
difficulty: "Basic"
companyTags: []
tags: ["Arrays", "Sorting", "Merge Sort", "Data Structures", "Algorithms"]
---

# Merge and Sort
## Slug: merge-and-sort5821
## Difficulty: Basic
## Id: 702674
## Topic Tags: Arrays, Sorting, Merge Sort, Data Structures, Algorithms
## Company Tags: None

### Summary
The problem involves merging two sorted arrays into a single sorted array. This is a classic example of a sorting algorithm problem that can be solved using the merge sort technique.

### Detailed Explanation
To solve this problem, we will implement a merge sort algorithm to merge and sort the two given arrays. The basic idea behind merge sort is to divide the input array into smaller subarrays until each subarray contains only one element (which is already sorted), then merge these subarrays in a way that maintains the sorting.

Here's a step-by-step breakdown of the solution:

1.  Initialize three variables: `left`, `right`, and `result` arrays, representing the input left array, right array, and the result merged array, respectively.
2.  Compare the smallest unprocessed element from each array (i.e., the first elements of both arrays). If the left array's element is smaller, add it to the `result` array, move on to the next element in the left array. If the right array's element is smaller, add it to the `result` array, move on to the next element in the right array.
3.  Repeat step 2 until one of the arrays becomes empty. At this point, all elements from the non-empty array have been added to the result array.
4.  Combine the remaining elements (if any) from both arrays into the `result` array.

The time complexity for this solution is O(n log n), where n is the total number of elements in both input arrays. This is because we are essentially performing a divide-and-conquer operation, splitting the arrays into smaller subarrays until they contain only one element each, and then merging these subarrays to produce the final sorted array.

The space complexity for this solution is O(n), where n is the total number of elements in both input arrays. This is because we need to store all elements from both arrays in the `result` array.

### Optimized Solutions

#### Java
```java
public static int[] mergeSortedArrays(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    int i = 0, j = 0, k = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result[k++] = left[i++];
        } else {
            result[k++] = right[j++];
        }
    }
    
    while (i < left.length) {
        result[k++] = left[i++];
    }
    
    while (j < right.length) {
        result[k++] = right[j++];
    }
    
    return result;
}
```

#### Python
```python
def merge_sorted_arrays(left, right):
    result = [0] * (len(left) + len(right))
    i = j = k = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result[k] = left[i]
            i += 1
        else:
            result[k] = right[j]
            j += 1
        k += 1
    
    while i < len(left):
        result[k] = left[i]
        i += 1
        k += 1
    
    while j < len(right):
        result[k] = right[j]
        j += 1
        k += 1
    
    return result
```

#### C++
```cpp
#include <vector>

std::vector<int> mergeSortedArrays(const std::vector<int>& left, const std::vector<int>& right) {
    int n = left.size() + right.size();
    std::vector<int> result(n);
    
    int i = j = k = 0;
    
    while (i < left.size() && j < right.size()) {
        if (left[i] <= right[j]) {
            result[k++] = left[i++];
        } else {
            result[k++] = right[j++];
        }
    }
    
    while (i < left.size()) {
        result[k++] = left[i++];
    }
    
    while (j < right.size()) {
        result[k++] = right[j++];
    }
    
    return result;
}
```

#### JavaScript
```javascript
function mergeSortedArrays(left, right) {
    let result = new Array(left.length + right.length);
    let i = j = k = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result[k++] = left[i++];
        } else {
            result[k++] = right[j++];
        }
    }
    
    while (i < left.length) {
        result[k++] = left[i++];
    }
    
    while (j < right.length) {
        result[k++] = right[j++];
    }
    
    return result;
}
```