---
id: "700308"
title: "Extreme nodes in alternate order"
slug: "extreme-nodes-in-alternate-order"
difficulty: "Medium"
companyTags: ["Amazon"]
tags: ["Tree", "Data Structures"]
---

**Extreme nodes in alternate order**
=====================================================

**Slug:** extreme-nodes-in-alternate-order
**Difficulty:** Medium
**Id:** 700308
**Topic Tags:** Tree, Data Structures
**Company Tags:** Amazon

## Summary
Given a binary tree, find the nodes that are at an odd distance from the root node. In other words, if we start traversing the tree from the root and visit each node in alternate order (i.e., skip one node and then visit the next), the nodes that will be visited will be the extreme nodes. This problem requires understanding of binary trees and traversal algorithms.

## Detailed Explanation
The given problem can be solved by using a level-order traversal algorithm with some modifications to keep track of the nodes at odd distances from the root. We'll use a queue to perform the level-order traversal and an integer variable, `level`, to keep track of the current level.

Here's a step-by-step breakdown of the solution:

1.  Initialize an empty queue and add the root node to it.
2.  Initialize an empty list to store the extreme nodes.
3.  Perform level-order traversal using the queue:
    *   Dequeue a node from the front of the queue.
    *   If the dequeued node is at an odd distance from the root (i.e., `level` is odd), add it to the list of extreme nodes.
    *   Add all the child nodes of the dequeued node to the back of the queue. Increment `level` by 1 for each child node.
4.  Return the list of extreme nodes.

Time complexity: O(N), where N is the number of nodes in the binary tree. This is because we visit each node once during the level-order traversal.
Space complexity: O(N), as we need to store all the nodes at a given level in the queue, which can grow up to N for a skewed tree.

## Optimized Solutions

#### Java
```java
import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Solution {
    public List<TreeNode> extremeNodes(TreeNode root) {
        List<TreeNode> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int level = 1;

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (level % 2 != 0) { // nodes at odd distances
                result.add(node);
            }
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
            level++;
        }

        return result;
    }
}

```

#### Python
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def extreme_nodes(root):
    if not root:
        return []

    result = []
    queue = [root]
    level = 1

    while queue:
        node = queue.pop(0)
        if level % 2 != 0:  # nodes at odd distances
            result.append(node)
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
        level += 1

    return result

```

#### C++
```cpp
// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    vector<TreeNode*> extremeNodes(TreeNode* root) {
        vector<TreeNode*> result;
        if (root == NULL) return result;

        queue<TreeNode*> q;
        q.push(root);
        int level = 1;

        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            if (level % 2 != 0) { // nodes at odd distances
                result.push_back(node);
            }
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
            level++;
        }

        return result;
    }
};

```

#### JavaScript
```javascript
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function extremeNodes(root) {
    if (!root) return [];

    let result = [];
    let queue = [root];
    let level = 1;

    while (queue.length > 0) {
        let node = queue.shift();
        if (level % 2 !== 0) { // nodes at odd distances
            result.push(node);
        }
        if (node.left) queue.push(node.left);
        if (node.right) queue.push(node.right);
        level++;
    }

    return result;
}

```

Note that the optimized solutions provided are based on the assumption that you want to find the extreme nodes in all levels of the binary tree. If you only want to consider the first k levels, you can modify the solution accordingly.