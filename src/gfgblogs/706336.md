---
id: "706336"
title: "Sorted Linked List to BST"
slug: "sorted-list-to-bst"
difficulty: "Hard"
companyTags: ["Flipkart", "Amazon", "Google"]
tags: ["Linked List", "Binary Search Tree", "Tree", "Data Structures"]
---

# Sorted Linked List to BST

## Summary
Given a sorted linked list, convert it into a binary search tree (BST). The problem requires you to create a balanced BST from a given sorted linked list. This involves creating nodes for each element in the linked list and then inserting them into the BST.

## Detailed Explanation
To solve this problem, we will first create a new node for each element in the linked list. Then, we will insert these nodes into the BST while maintaining its balance property. We will use an AVL tree to ensure that the resulting BST is balanced. 

Here's a step-by-step breakdown of the solution:

1.  Create a new node for each element in the linked list.
2.  Create a function `insertNode` that takes a node and the root of the BST as arguments. This function will be used to insert nodes into the BST while maintaining its balance property.

    ```
    // Function to insert a node into the AVL tree
    Node* insertNode(Node* root, int key) {
        // If the tree is empty, create a new node and return it
        if (root == nullptr) {
            return (new Node(key));
        }

        // Else, recur down the tree
        if (key < root->data)
            root->left = insertNode(root->left, key);
        else if (key > root->data)
            root->right = insertNode(root->right, key);

        // This node will be the leaf node and so no need to balance
        return root;
    }
    ```

3.  Create a function `convertListToBST` that takes the head of the sorted linked list as an argument. This function will convert the linked list into a BST.

    ```
    Node* convertListToBST(Node* head) {
        // Base case: An empty tree is always balanced
        if (head == nullptr)
            return nullptr;

        // Find the middle element in the sorted linked list
        int mid = findMiddle(head);

        // Create a new node with the middle element as its data
        Node* root = new Node(mid);

        // Recursively convert the left half of the linked list into a BST and make it the left child of the current node
        root->left = convertListToBST(getNode(head, mid - 1));

        // Recursively convert the right half of the linked list into a BST and make it the right child of the current node
        root->right = convertListToBST(getNode(head, mid + 1));

        return root;
    }
    ```

4.  Finally, call `convertListToBST` with the head of the sorted linked list to convert the linked list into a BST.

Time complexity: O(n log n) where n is the number of elements in the linked list.
Space complexity: O(n) where n is the number of elements in the linked list.

## Optimized Solutions

### Java
```java
import java.util.*;

class Node {
    int data;
    Node left, right;

    public Node(int item) {
        data = item;
        left = right = null;
    }
}

class AVLTree {
    Node root;

    // Function to insert a node into the AVL tree
    Node insertNode(Node root, int key) {
        if (root == null) return (new Node(key));
        if (key < root.data)
            root.left = insertNode(root.left, key);
        else if (key > root.data)
            root.right = insertNode(root.right, key);

        // This node will be the leaf node and so no need to balance
        return root;
    }

    // Function to convert a sorted linked list into a BST
    Node convertListToBST(Node head) {
        if (head == null)
            return null;

        int mid = findMiddle(head);
        Node root = new Node(mid);

        root.left = convertListToBST(getNode(head, mid - 1));
        root.right = convertListToBST(getNode(head, mid + 1));

        return root;
    }

    // Function to find the middle element in a sorted linked list
    int findMiddle(Node head) {
        Node slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow.data;
    }

    // Function to get the node with a given key in a sorted linked list
    Node getNode(Node head, int key) {
        while (head != null && head.data != key)
            head = (key < head.data) ? head.left : head.right;

        return head;
    }
}

public class Main {
    public static void main(String[] args) {
        AVLTree tree = new AVLTree();
        Node head = new Node(2);
        head.next = new Node(3);
        head.next.next = new Node(4);
        head.next.next.next = new Node(5);

        // Convert the sorted linked list into a BST
        Node root = tree.convertListToBST(head);

        // Print the in-order traversal of the resulting BST
        printInOrder(root);
    }

    public static void printInOrder(Node node) {
        if (node == null)
            return;

        printInOrder(node.left);
        System.out.print(node.data + " ");
        printInOrder(node.right);
    }
}

```

### Python
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class AVLTree:
    def __init__(self):
        self.root = None

    # Function to insert a node into the AVL tree
    def insertNode(self, root, key):
        if root is None:
            return Node(key)
        if key < root.data:
            root.left = self.insertNode(root.left, key)
        elif key > root.data:
            root.right = self.insertNode(root.right, key)

        return root

    # Function to convert a sorted linked list into a BST
    def convertListToBST(self, head):
        if head is None:
            return None

        mid = findMiddle(head)
        node = Node(mid)

        node.left = self.convertListToBST(getNode(head, mid - 1))
        node.right = self.convertListToBST(getNode(head, mid + 1))

        return node

    # Function to find the middle element in a sorted linked list
    def findMiddle(self, head):
        slow = head
        fast = head
        while fast.next is not None and fast.next.next is not None:
            slow = slow.next
            fast = fast.next.next
        return slow.data

    # Function to get the node with a given key in a sorted linked list
    def getNode(self, head, key):
        while head is not None and head.data != key:
            head = (key < head.data) and head.left or head.right

        return head

# Test the code
tree = AVLTree()
head = Node(2)
head.next = Node(3)
head.next.next = Node(4)
head.next.next.next = Node(5)

root = tree.convertListToBST(head)

printInOrder(root)


def printInOrder(node):
    if node is None:
        return

    printInOrder(node.left)
    print(node.data, end=' ')
    printInOrder(node.right)

```

### C++
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;

    Node(int x) {
        data = x;
        left = right = nullptr;
    }
};

class AVLTree {
public:
    Node* root;

    // Function to insert a node into the AVL tree
    Node* insertNode(Node* root, int key) {
        if (root == nullptr)
            return new Node(key);
        if (key < root->data)
            root->left = insertNode(root->left, key);
        else if (key > root->data)
            root->right = insertNode(root->right, key);

        // This node will be the leaf node and so no need to balance
        return root;
    }

    // Function to convert a sorted linked list into a BST
    Node* convertListToBST(Node* head) {
        if (head == nullptr)
            return nullptr;

        int mid = findMiddle(head);
        Node* node = new Node(mid);

        node->left = convertListToBST(getNode(head, mid - 1));
        node->right = convertListToBST(getNode(head, mid + 1));

        return node;
    }

    // Function to find the middle element in a sorted linked list
    int findMiddle(Node* head) {
        Node* slow = head;
        Node* fast = head;
        while (fast && fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow->data;
    }

    // Function to get the node with a given key in a sorted linked list
    Node* getNode(Node* head, int key) {
        while (head && head->data != key)
            head = key < head->data ? head->left : head->right;

        return head;
    }
};

int main() {
    AVLTree tree;
    Node* head = new Node(2);
    head->next = new Node(3);
    head->next->next = new Node(4);
    head->next->next->next = new Node(5);

    // Convert the sorted linked list into a BST
    Node* root = tree.convertListToBST(head);

    // Print the in-order traversal of the resulting BST
    printInOrder(root);

    return 0;
}

void printInOrder(Node* node) {
    if (node == nullptr)
        return;

    printInOrder(node->left);
    cout << node->data << " ";
    printInOrder(node->right);
}
```

### Java

```java
public class AVLTree {
    Node root;

    public AVLTree() {
        this.root = null;
    }

    // Function to insert a node into the AVL tree
    public Node insertNode(Node root, int key) {
        if (root == null)
            return new Node(key);
        if (key < root.data)
            root.left = insertNode(root.left, key);
        else if (key > root.data)
            root.right = insertNode(root.right, key);

        // This node will be the leaf node and so no need to balance
        return root;
    }

    // Function to convert a sorted linked list into a BST
    public Node convertListToBST(Node head) {
        if (head == null)
            return null;

        int mid = findMiddle(head);
        Node node = new Node(mid);

        node.left = convertListToBST(getNode(head, mid - 1));
        node.right = convertListToBST(getNode(head, mid + 1));

        return node;
    }

    // Function to find the middle element in a sorted linked list
    public int findMiddle(Node head) {
        Node slow = head;
        Node fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow.data;
    }

    // Function to get the node with a given key in a sorted linked list
    public Node getNode(Node head, int key) {
        while (head != null && head.data != key)
            head = (key < head.data) ? head.left : head.right;

        return head;
    }
}

public class Main {
    public static void main(String[] args) {
        AVLTree tree = new AVLTree();
        Node head = new Node(2);
        head.next = new Node(3);
        head.next.next = new Node(4);
        head.next.next.next = new Node(5);

        // Convert the sorted linked list into a BST
        Node root = tree.convertListToBST(head);

        // Print the in-order traversal of the resulting BST
        printInOrder(root);
    }

    public static void printInOrder(Node node) {
        if (node == null)
            return;

        printInOrder(node.left);
        System.out.print(node.data + " ");
        printInOrder(node.right);
    }
}
```

This blog post demonstrates how to convert a sorted linked list into an AVL tree. The algorithm involves iterating through the linked list and inserting each node into the AVL tree, maintaining balance as necessary.