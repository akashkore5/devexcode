---
id: "714256"
title: "Cake Distribution Problem"
slug: "cake-distribution-problem--170647"
difficulty: "Hard"
companyTags: []
tags: ["Binary Search", "Arrays"]
---

**Cake Distribution Problem**
==========================

### Summary
The Cake Distribution Problem is a challenging algorithmic problem that involves distributing cakes to customers based on their preferences. The problem requires you to optimize the distribution process by minimizing the total difference between the number of cakes given to each customer and their desired number.

Key concepts involved in this problem include binary search, arrays, and optimization techniques.

### Detailed Explanation
To solve this problem, we can use a combination of sorting and binary search. First, we sort the array of customers based on their preferences (i.e., the number of cakes they want). Then, we use a two-pointer approach to distribute the cakes.

Here's a step-by-step breakdown of the solution:

1. Sort the array of customers in ascending order based on their preferences.
2. Initialize two pointers, `left` and `right`, to the start and end of the sorted array, respectively.
3. Calculate the average number of cakes per customer by dividing the total number of cakes by the number of customers.
4. Use a binary search approach to find the closest preference that is less than or equal to the average number of cakes per customer. This will be our initial target for cake distribution.
5. Distribute cakes to each customer based on their preferences, starting from the leftmost customer and moving towards the right. For each customer, calculate the difference between their desired number of cakes and the actual number of cakes given (based on the current target).
6. Update the target by adjusting it up or down depending on whether the total difference is increasing or decreasing.
7. Repeat steps 5-6 until the target preference is reached or all customers have received cakes.

The time complexity of this solution is O(n log n), where n is the number of customers, due to the sorting and binary search operations. The space complexity is O(1) since we only use a constant amount of extra memory to store the two pointers and the target preference.

### Optimized Solutions

#### Java
```java
public class CakeDistribution {
    public static int minTotalDiff(int[] preferences, int nCakes) {
        Arrays.sort(preferences);
        int left = 0;
        int right = preferences.length - 1;
        int target = preferences[preferences.length / 2];
        int totalDiff = 0;

        for (int i = 0; i < nCakes; i++) {
            if (i < preferences[left]) {
                totalDiff += preferences[left] - target;
                left++;
            } else if (i >= preferences[right]) {
                totalDiff += target - preferences[right];
                right--;
            } else {
                totalDiff += Math.abs(target - preferences[i]);
                break;
            }
        }

        return totalDiff;
    }
}
```

#### Python
```python
def min_total_diff(preferences, n_cakes):
    preferences.sort()
    left = 0
    right = len(preferences) - 1
    target = preferences[len(preferences) // 2]
    total_diff = 0

    for i in range(n_cakes):
        if i < preferences[left]:
            total_diff += preferences[left] - target
            left += 1
        elif i >= preferences[right]:
            total_diff += target - preferences[right]
            right -= 1
        else:
            total_diff += abs(target - preferences[i])
            break

    return total_diff
```

#### C++
```cpp
#include <algorithm>
#include <vector>

int minTotalDiff(std::vector<int>& preferences, int nCakes) {
    std::sort(preferences.begin(), preferences.end());
    int left = 0;
    int right = preferences.size() - 1;
    int target = preferences[preferences.size() / 2];
    int totalDiff = 0;

    for (int i = 0; i < nCakes; i++) {
        if (i < preferences[left]) {
            totalDiff += preferences[left] - target;
            left++;
        } else if (i >= preferences[right]) {
            totalDiff += target - preferences[right];
            right--;
        } else {
            totalDiff += std::abs(target - preferences[i]);
            break;
        }
    }

    return totalDiff;
}
```

#### JavaScript
```javascript
function minTotalDiff(preferences, nCakes) {
  preferences.sort((a, b) => a - b);
  let left = 0;
  let right = preferences.length - 1;
  let target = preferences[Math.floor(preferences.length / 2)];
  let totalDiff = 0;

  for (let i = 0; i < nCakes; i++) {
    if (i < preferences[left]) {
      totalDiff += preferences[left] - target;
      left++;
    } else if (i >= preferences[right]) {
      totalDiff += target - preferences[right];
      right--;
    } else {
      totalDiff += Math.abs(target - preferences[i]);
      break;
    }
  }

  return totalDiff;
}
```