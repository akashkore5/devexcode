---
id: "702700"
title: "Pairs of equals Sum"
slug: "sum-equals-to-sum4006"
difficulty: "Easy"
companyTags: ["Amazon", "OYO Rooms"]
tags: ["Arrays", "Hash", "Data Structures"]
---

Here is a detailed Markdown blog post for the "Pairs of equals Sum" problem:

# Pairs of equals Sum
## Summary

Given an array `nums` of integers, find all pairs `(i, j)` such that `nums[i] + nums[j] = 4006`. This problem involves using arrays and hash data structures to solve a simple sum-equals problem.

## Detailed Explanation

To solve this problem, we will use a two-pointer technique. We first sort the array in ascending order. Then, we initialize two pointers, one at the start of the array (`i`) and one at the end of the array (`j`). We calculate the sum `nums[i] + nums[j]` and compare it to our target sum `4006`. If the sum is less than `4006`, we increment `i` to increase the sum. If the sum is greater than `4006`, we decrement `j` to decrease the sum.

Here's a step-by-step breakdown of the solution:

1. Sort the array in ascending order.
2. Initialize two pointers, `i` and `j`, at the start and end of the array respectively.
3. Calculate the sum `nums[i] + nums[j]`.
4. Compare the sum to our target sum `4006`. If the sum is less than `4006`, increment `i` to increase the sum.
5. If the sum is greater than `4006`, decrement `j` to decrease the sum.
6. Repeat steps 3-5 until `i` and `j` meet or cross each other.

The time complexity of this solution is O(n log n) due to the sorting step, where `n` is the size of the array. The space complexity is O(1) as we only use a few extra variables to store the pointers and sum.

## Optimized Solutions

### Java
```
java
import java.util.Arrays;

public class PairsOfEqualsSum {
    public static void findPairs(int[] nums, int target) {
        Arrays.sort(nums);
        int i = 0, j = nums.length - 1;
        while (i < j) {
            int sum = nums[i] + nums[j];
            if (sum == target) {
                System.out.println("Pair found: (" + i + ", " + j + ")");
                i++;
                j--;
            } else if (sum < target) {
                i++;
            } else {
                j--;
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5};
        findPairs(nums, 4006);
    }
}
```

### Python
```
python
def find_pairs(nums, target):
    nums.sort()
    i, j = 0, len(nums) - 1
    while i < j:
        sum = nums[i] + nums[j]
        if sum == target:
            print("Pair found: ({}, {})".format(i, j))
            i += 1
            j -= 1
        elif sum < target:
            i += 1
        else:
            j -= 1

nums = [1, 2, 3, 4, 5]
find_pairs(nums, 4006)
```

### C++
```
cpp
#include <iostream>
#include <vector>
#include <algorithm>

void findPairs(std::vector<int>& nums, int target) {
    std::sort(nums.begin(), nums.end());
    int i = 0, j = nums.size() - 1;
    while (i < j) {
        int sum = nums[i] + nums[j];
        if (sum == target) {
            std::cout << "Pair found: (" << i << ", " << j << ")" << std::endl;
            i++;
            j--;
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
}

int main() {
    std::vector<int> nums = {1, 2, 3, 4, 5};
    findPairs(nums, 4006);
    return 0;
}
```

### JavaScript
```
javascript
function findPairs(nums, target) {
    nums.sort((a, b) => a - b);
    let i = 0, j = nums.length - 1;
    while (i < j) {
        let sum = nums[i] + nums[j];
        if (sum === target) {
            console.log("Pair found: (" + i + ", " + j + ")");
            i++;
            j--;
        } else if (sum < target) {
            i++;
        } else {
            j--;
        }
    }
}

let nums = [1, 2, 3, 4, 5];
findPairs(nums, 4006);
```

These optimized solutions use the same two-pointer technique as described in the detailed explanation section.