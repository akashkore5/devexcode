---
id: "700535"
title: "Intersection of Two Linked Lists"
slug: "intersection-of-two-linked-list"
difficulty: "Easy"
companyTags: ["VMWare", "Flipkart", "Accolite", "Amazon", "Microsoft", "24*7 Innovation Labs", "D-E-Shaw", "Walmart", "Komli Media", "Taxi4Sure"]
tags: ["Linked List", "Hash", "Sorting", "Data Structures", "Algorithms"]
---

# Intersection of Two Linked Lists
## Slug: intersection-of-two-linked-list
## Difficulty: Easy
## Id: 700535
## Topic Tags: Linked List, Hash, Sorting, Data Structures, Algorithms
## Company Tags: VMWare, Flipkart, Accolite, Amazon, Microsoft, 24*7 Innovation Labs, D-E-Shaw, Walmart, Komli Media, Taxi4Sure

### Summary
Given two linked lists that intersect at some node, find the intersection point. The problem assumes that the intersection is not included in the linked list and is not part of either linked list.

The key concepts involved are linked lists and hash tables.

### Detailed Explanation
To solve this problem, we first need to traverse both linked lists until we reach the end of either of them. Then, we create a hash table (in this case, a HashMap in Java) that maps each node's value to its corresponding node. Next, we start traversing one of the linked lists again and check for each node if it is present in the hash table. If it is, then we have found the intersection point.

Here is a step-by-step breakdown:

1.  Initialize two pointers (or iterators) at the beginning of both linked lists.
2.  Traverse both linked lists until you reach the end of either list. This will ensure that both lists are of equal length and that there is no remaining part left in either list after intersection.
3.  Create a HashMap to store node values as keys and their corresponding nodes as values.
4.  Start traversing one of the linked lists again, keeping track of its current position using an iterator or pointer.
5.  For each node in this second traversal, check if it is present in the HashMap. If it is, then that means you have found the intersection point, and you can stop the traversal.
6.  If you reach the end of the second linked list without finding any intersection points, it means there was no intersection between the two lists.

### Optimized Solutions

#### Java
```java
public Node getIntersectionNode(Node headA, Node headB) {
    if (headA == null || headB == null)
        return null;

    HashMap<Node, Integer> map = new HashMap<>();
    int lenA = 0;
    int lenB = 0;
    Node currA = headA;
    Node currB = headB;

    while (currA != null) {
        map.put(currA, lenA);
        lenA++;
        currA = currA.next;
    }

    while (currB != null) {
        if (map.containsKey(currB)) {
            return currB;
        }
        lenB++;
        currB = currB.next;
    }

    return null;
}
```

#### Python
```python
def getIntersectionNode(headA, headB):
    if not headA or not headB:
        return None

    map = {}
    lenA = 0
    lenB = 0
    currA = headA
    currB = headB

    while currA:
        map[currA] = lenA
        lenA += 1
        currA = currA.next

    while currB:
        if currB in map:
            return currB
        lenB += 1
        currB = currB.next

    return None
```

#### C++
```cpp
Node* getIntersectionNode(Node* headA, Node* headB) {
    if (!headA || !headB)
        return NULL;

    unordered_map<Node*, int> map;
    int lenA = 0;
    int lenB = 0;
    Node* currA = headA;
    Node* currB = headB;

    while (currA) {
        map[currA] = lenA;
        lenA++;
        currA = currA->next;
    }

    while (currB) {
        if (map.find(currB) != map.end()) {
            return currB;
        }
        lenB++;
        currB = currB->next;
    }

    return NULL;
}
```

#### JavaScript
```javascript
function getIntersectionNode(headA, headB) {
    if (!headA || !headB)
        return null;

    let map = new Map();
    let lenA = 0;
    let lenB = 0;
    let currA = headA;
    let currB = headB;

    while (currA) {
        map.set(currA, lenA);
        lenA++;
        currA = currA.next;
    }

    while (currB) {
        if (map.has(currB)) {
            return currB;
        }
        lenB++;
        currB = currB.next;
    }

    return null;
}
```

The time complexity of this algorithm is O(m + n), where m and n are the lengths of the two linked lists. The space complexity is O(min(m, n)), which is used to store the HashMap.