---
id: "712225"
title: "MaxSkill"
slug: "burst-balloons"
difficulty: "Hard"
companyTags: []
tags: ["Arrays", "Dynamic Programming", "Data Structures", "Algorithms"]
---

**MaxSkill**
=====================================

**Slug:** burst-balloons
**Difficulty:** Hard
**Id:** 712225
**Topic Tags:** Arrays, Dynamic Programming, Data Structures, Algorithms
**Company Tags:** None

## Summary
The MaxSkill problem involves bursting balloons with different skill levels. You are given an array of integers representing the skill levels of the balloons, and you need to burst the balloons in a way that maximizes your score. The score is calculated as the product of the number of balloons burst at each level and the skill level of those balloons.

## Detailed Explanation
To solve this problem, we can use dynamic programming to find the maximum score. We initialize an array `dp` where `dp[i]` represents the maximum score that can be achieved by bursting balloons up to level `i`. We then iterate over the array of balloon skill levels and update the `dp` array accordingly.

Here is a step-by-step breakdown of the solution:

1. Initialize `dp[0] = 0`, since we start with no balloons burst.
2. Iterate over the array of balloon skill levels from left to right.
3. For each balloon, calculate the maximum score that can be achieved by bursting it and all previous balloons:
   * If the current balloon's skill level is greater than or equal to the previous balloon's skill level, we can burst the current balloon and add its score to the previous balloon's score.
   * Otherwise, we can only burst the previous balloon, so we don't get any additional score from the current balloon.
4. Update `dp[i]` with the maximum of these two scores.
5. Return the maximum score achieved by bursting all balloons.

Time complexity: O(n), where n is the number of balloons.
Space complexity: O(1), since we only need a constant amount of space to store the `dp` array.

## Optimized Solutions

### Java
```
java
public int maxSkill(int[] balloonSkills) {
    int n = balloonSkills.length;
    int[] dp = new int[n + 1];
    for (int i = 0; i < n; i++) {
        if (i > 0 && balloonSkills[i] >= balloonSkills[i - 1]) {
            dp[i + 1] = Math.max(dp[i] + balloonSkills[i], dp[i]);
        } else {
            dp[i + 1] = dp[i];
        }
    }
    return dp[n];
}
```

### Python
```
python
def max_skill(balloon_skills):
    n = len(balloon_skills)
    dp = [0] * (n + 1)
    for i in range(n):
        if i > 0 and balloon_skills[i] >= balloon_skills[i - 1]:
            dp[i + 1] = max(dp[i] + balloon_skills[i], dp[i])
        else:
            dp[i + 1] = dp[i]
    return dp[n]
```

### C++
```
cpp
int maxSkill(int* balloonSkills, int n) {
    int i;
    for (i = 0; i < n; i++) {
        if (i > 0 && balloonSkills[i] >= balloonSkills[i - 1]) {
            dp[i + 1] = std::max(dp[i] + balloonSkills[i], dp[i]);
        } else {
            dp[i + 1] = dp[i];
        }
    }
    return dp[n];
}
```

### JavaScript
```
javascript
function maxSkill(balloonSkills) {
    let n = balloonSkills.length;
    let dp = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        if (i > 0 && balloonSkills[i] >= balloonSkills[i - 1]) {
            dp[i + 1] = Math.max(dp[i] + balloonSkills[i], dp[i]);
        } else {
            dp[i + 1] = dp[i];
        }
    }
    return dp[n];
}
```