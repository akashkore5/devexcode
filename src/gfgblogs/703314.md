---
id: "703314"
title: "Three Great Candidates"
slug: "three-great-candidates0515"
difficulty: "Easy"
companyTags: ["Flipkart", "Amazon", "Snapdeal"]
tags: ["Arrays", "Data Structures"]
---

Here is a detailed Markdown blog post for the Three Great Candidates problem:

**Three Great Candidates**
======================

**703314**
-----------------

### Summary

We are given an array of candidates where each candidate has a name and a score. Our task is to find the top three candidates based on their scores. The candidates with the highest scores should be returned first, and in case of a tie, the candidate who appears earliest in the array should be considered better.

### Detailed Explanation

To solve this problem, we can use an algorithm that sorts the candidates based on their scores and then selects the top three candidates. Here's a step-by-step breakdown of the solution:

1. Sort the candidates array based on the score in descending order (highest to lowest).
2. Initialize three variables to store the names of the top three candidates.
3. Iterate through the sorted array, starting from the first candidate:
	* If the current candidate is not one of the top three, skip it.
	* If the current candidate's score is higher than the lowest score among the top three, replace the candidate with the lowest score with the current candidate.
4. Return the names of the top three candidates.

Here's an ASCII art diagram to illustrate the sorting and selection process:
```
Candidate 1 (score: 80)   Candidate 2 (score: 70)   Candidate 3 (score: 90)
          |                  |                       |
          |  Sort by score   |                       |
          v                  v                       v
Candidate 3 (score: 90)   Candidate 1 (score: 80)   Candidate 2 (score: 70)
          |                  |                       |
          |  Top three       |                       |
          v                  v                       v
John (score: 90)    Jane (score: 80)    Jack (score: 70)
```

The time complexity of this algorithm is O(n log n), where n is the number of candidates, since we are sorting the array. The space complexity is O(1), as we only need a constant amount of extra space to store the top three candidates.

### Optimized Solutions

Here are optimized solutions in different programming languages:

#### Java
```java
public String[] findTopThree(String[] candidates) {
    Arrays.sort(candidates, (a, b) -> Integer.compare(Integer.parseInt(b.split(":")[1]), Integer.parseInt(a.split(":")[1])));
    String[] topThree = new String[3];
    for (int i = 0; i < 3; i++) {
        topThree[i] = candidates[i].split(":")[0];
    }
    return topThree;
}
```

#### Python
```python
def find_top_three(candidates):
    sorted_candidates = sorted(candidates, key=lambda x: int(x.split(":")[1]), reverse=True)
    top_three = [candidate.split(":")[0] for candidate in sorted_candidates[:3]]
    return top_three
```

#### C++
```cpp
#include <algorithm>
#include <string>
#include <vector>

std::vector<std::string> findTopThree(std::vector<std::string> candidates) {
    std::sort(candidates.begin(), candidates.end(),
              [](const std::string& a, const std::string& b) {
                  return std::stoi(b.substr(b.find(":") + 1)) <
                         std::stoi(a.substr(a.find(":") + 1));
              });
    std::vector<std::string> topThree(3);
    for (int i = 0; i < 3; i++) {
        topThree[i] = candidates[i].substr(0, candidates[i].find(":"));
    }
    return topThree;
}
```

#### JavaScript
```javascript
function findTopThree(candidates) {
    const sortedCandidates = candidates.slice().sort((a, b) => {
        const scoreA = parseInt(b.split(":")[1]);
        const scoreB = parseInt(a.split(":")[1]);
        return scoreB - scoreA;
    });
    const topThree = [];
    for (let i = 0; i < 3; i++) {
        topThree.push(sortedCandidates[i].split(":")[0]);
    }
    return topThree;
}
```

These solutions all have a time complexity of O(n log n) and a space complexity of O(1), as described in the Detailed Explanation section.