---
id: "700665"
title: "Insert in Middle of Linked List"
slug: "insert-in-middle-of-linked-list"
difficulty: "Basic"
companyTags: []
tags: ["Linked List", "Data Structures"]
---

# Insert in Middle of Linked List
## Slug: insert-in-middle-of-linked-list
## Difficulty: Basic
## Id: 700665
## Topic Tags: Linked List, Data Structures
## Company Tags: None

### Summary
The problem is to insert a new node into the middle of a linked list. The key concepts involved are basic data structures and algorithms, particularly linked lists.

### Detailed Explanation

To solve this problem, we will first need to find the middle of the linked list. We can do this by iterating through the list until we reach the halfway point. Once we have found the middle, we can insert our new node into the list at that position.

Here is a step-by-step breakdown of the solution:

1. Initialize two pointers, `slow` and `fast`, to the beginning of the linked list.
2. Iterate through the list until `fast` reaches the end of the list. For each iteration:
   - Move `slow` one node forward.
   - Move `fast` two nodes forward (if there is an odd number of nodes, this will still point to the correct position).
3. Once `fast` has reached the end of the list, `slow` will be pointing to the middle node. Insert our new node after `slow`.

### Optimized Solutions

#### Java
```java
public class Solution {
    public void insertInMiddle(Node head, int data) {
        if (head == null || head.next == null) {
            return; // list has only one or zero nodes
        }

        Node slow = head;
        Node fast = head;

        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        Node newNode = new Node(data);
        newNode.next = slow.next;
        slow.next = newNode;
    }
}
```

#### Python
```python
class Solution:
    def insert_in_middle(self, head, data):
        if not head or not head.next:
            return  # list has only one or zero nodes

        slow = head
        fast = head

        while fast and fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next

        new_node = Node(data)
        new_node.next = slow.next
        slow.next = new_node
```

#### C++
```cpp
class Solution {
public:
    void insertInMiddle(Node* head, int data) {
        if (head == nullptr || head->next == nullptr) {
            return; // list has only one or zero nodes
        }

        Node* slow = head;
        Node* fast = head;

        while (fast && fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        Node* newNode = new Node(data);
        newNode->next = slow->next;
        slow->next = newNode;
    }
};
```

#### JavaScript
```javascript
class Solution {
  insertInMiddle(head, data) {
    if (!head || !head.next) {
      return; // list has only one or zero nodes
    }

    let slow = head;
    let fast = head;

    while (fast && fast.next && fast.next.next) {
      slow = slow.next;
      fast = fast.next.next;
    }

    const newNode = { value: data, next: null };
    newNode.next = slow.next;
    slow.next = newNode;
  }
}
```

Note that the time complexity of this solution is O(n), where n is the number of nodes in the linked list. The space complexity is O(1) since we are only using a constant amount of space to store our pointers and new node.