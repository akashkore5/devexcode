---
id: "703453"
title: "Search array with adjacent diff at most k"
slug: "searching-in-an-array-where-adjacent-differ-by-at-most-k0456"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Searching", "CPP", "Data Structures", "Algorithms"]
---

# Search array with adjacent diff at most k

## Summary
This problem is about searching for an element in an array where each adjacent pair of elements differs by at most a certain value `k`. The goal is to find the target element in the array efficiently.

## Detailed Explanation
To solve this problem, we can use a two-pointer technique. We start with two pointers, `i` and `j`, initially set to 0. We then iterate through the array, moving the pointer that points to the smaller value towards the other end of the array. The key insight is that if the difference between adjacent elements is more than `k`, we can safely move the pointer that points to the larger value.

Here's a step-by-step breakdown:

1. Initialize two pointers `i` and `j` to 0.
2. While `i` is less than `j + k`, do the following:
	* If the difference between `arr[i]` and `arr[j]` is more than `k`, move `j` towards `i`.
	* Otherwise, if `target` is equal to `arr[j]`, return `j`. This means we've found the target element.
3. If we reach the end of the array without finding the target, return -1.

Time complexity: O(n), where n is the length of the array.
Space complexity: O(1).

## Optimized Solutions

#### Java
```java
public int search(int[] arr, int target) {
    int i = 0, j = 0;
    while (j + k <= arr.length && i < j + k) {
        if (Math.abs(arr[i] - arr[j]) > k) {
            j++;
        } else if (arr[j] == target) {
            return j;
        }
        i++;
    }
    return -1;
}
```

#### Python
```python
def search(arr, target):
    i = 0
    j = 0
    while j + k <= len(arr) and i < j + k:
        if abs(arr[i] - arr[j]) > k:
            j += 1
        elif arr[j] == target:
            return j
        i += 1
    return -1
```

#### C++
```cpp
int search(int* arr, int n, int target) {
    int i = 0, j = 0;
    while (j + k <= n && i < j + k) {
        if (abs(arr[i] - arr[j]) > k) {
            j++;
        } else if (arr[j] == target) {
            return j;
        }
        i++;
    }
    return -1;
}
```

#### JavaScript
```javascript
function search(arr, target) {
    let i = 0, j = 0;
    while (j + k <= arr.length && i < j + k) {
        if (Math.abs(arr[i] - arr[j]) > k) {
            j++;
        } else if (arr[j] === target) {
            return j;
        }
        i++;
    }
    return -1;
}
```
Note that the optimized solutions provided are in the respective languages, but the problem statement does not specify any particular language.