---
id: "703324"
title: "Sub-Array Pairs"
slug: "sub-array-pairs5530"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

**Sub-Array Pairs**
==================

**Slug:** sub-array-pairs5530
**Difficulty:** Medium
**Id:** 703324
**Topic Tags:** Arrays, Data Structures
**Company Tags:** None

## Summary
Given an array of integers, find all pairs of non-empty subarrays that have the same sum. The problem is to write a function that takes the input array as an argument and returns a list of such pairs.

## Detailed Explanation
The solution involves iterating through the array to generate all possible subarrays and then checking if two subarrays with the same sum exist in the list. This can be achieved by creating a hashmap where the key is the sum of the subarray and the value is a list of indices where this sum appears.

Here's a step-by-step breakdown:

1. Initialize an empty hashmap `sum_to_indices`.
2. Iterate through the array to generate all possible subarrays.
3. For each subarray, calculate its sum and check if it already exists in the `sum_to_indices` hashmap. If not, add the sum as a new key with an empty list as its value.
4. Add the index of the current subarray to the list of indices for the corresponding sum in the `sum_to_indices` hashmap.
5. Initialize an empty result list `pairs`.
6. Iterate through the `sum_to_indices` hashmap and find all pairs of indices where the same sum appears. For each pair, add a tuple containing the start and end indices of the subarrays to the `pairs` list.
7. Return the `pairs` list.

Time complexity: O(n^2), where n is the length of the input array. This is because we're generating all possible subarrays, which takes O(n) time for each subarray, and there are O(n) subarrays in total.

Space complexity: O(n), as we need to store the indices of all subarrays with the same sum in the `sum_to_indices` hashmap.

## Optimized Solutions

### Java
```java
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;

public class SubArrayPairs {
    public List<int[]> findSubArrayPairs(int[] arr) {
        HashMap<Integer, List<Integer>> sum_to_indices = new HashMap<>();
        List<int[]> pairs = new ArrayList<>();

        for (int i = 0; i < arr.length; i++) {
            int sum = 0;
            for (int j = i; j < arr.length; j++) {
                sum += arr[j];
                if (!sum_to_indices.containsKey(sum)) {
                    sum_to_indices.put(sum, new ArrayList<>());
                }
                sum_to_indices.get(sum).add(j);
            }
        }

        for (List<Integer> indices : sum_to_indices.values()) {
            if (indices.size() > 1) {
                for (int i = 0; i < indices.size(); i++) {
                    int start = indices.get(i);
                    for (int j = i + 1; j < indices.size(); j++) {
                        int end = indices.get(j);
                        pairs.add(new int[] {start, end});
                    }
                }
            }
        }

        return pairs;
    }
}
```

### Python
```python
def find_sub_array_pairs(arr):
    sum_to_indices = {}
    pairs = []

    for i in range(len(arr)):
        sum = 0
        for j in range(i, len(arr)):
            sum += arr[j]
            if sum not in sum_to_indices:
                sum_to_indices[sum] = []
            sum_to_indices[sum].append(j)

    for indices in sum_to_indices.values():
        if len(indices) > 1:
            for i in range(len(indices)):
                start = indices[i]
                for j in range(i + 1, len(indices)):
                    end = indices[j]
                    pairs.append((start, end))

    return pairs
```

### C++
```cpp
#include <unordered_map>
#include <vector>

std::vector<std::pair<int, int>> findSubArrayPairs(const std::vector<int>& arr) {
    std::unordered_map<int, std::vector<int>> sum_to_indices;
    std::vector<std::pair<int, int>> pairs;

    for (int i = 0; i < arr.size(); i++) {
        int sum = 0;
        for (int j = i; j < arr.size(); j++) {
            sum += arr[j];
            if (!sum_to_indices.count(sum)) {
                sum_to_indices[sum] = {};
            }
            sum_to_indices[sum].push_back(j);
        }
    }

    for (const auto& indices : sum_to_indices) {
        if (indices.second.size() > 1) {
            for (int i = 0; i < indices.second.size(); i++) {
                int start = indices.second[i];
                for (int j = i + 1; j < indices.second.size(); j++) {
                    int end = indices.second[j];
                    pairs.push_back({start, end});
                }
            }
        }
    }

    return pairs;
}
```

### JavaScript
```javascript
function findSubArrayPairs(arr) {
    const sum_to_indices = {};
    let pairs = [];

    for (let i = 0; i < arr.length; i++) {
        let sum = 0;
        for (let j = i; j < arr.length; j++) {
            sum += arr[j];
            if (!sum_to_indices[sum]) {
                sum_to_indices[sum] = [];
            }
            sum_to_indices[sum].push(j);
        }
    }

    Object.keys(sum_to_indices).forEach((sum) => {
        const indices = sum_to_indices[sum];
        if (indices.length > 1) {
            for (let i = 0; i < indices.length; i++) {
                let start = indices[i];
                for (let j = i + 1; j < indices.length; j++) {
                    let end = indices[j];
                    pairs.push([start, end]);
                }
            }
        }
    });

    return pairs;
}
```