---
id: "857639"
title: "Grinding Geek"
slug: "grinding-geek"
difficulty: "Medium"
companyTags: []
tags: []
---

Here is the Markdown blog post for the Grinding Geek problem:

# Grinding Geek

## Summary

The Grinding Geek problem involves simulating a grinding process where a geek's skill level increases based on their current level and effort. The goal is to determine when the geek will finally reach a target skill level, considering the effort required to increase their skills at each step.

This problem requires an understanding of dynamic programming concepts, as it involves breaking down a complex problem into smaller subproblems and solving them recursively.

## Detailed Explanation

To solve this problem, we can use dynamic programming. We create a 2D array `dp` where `dp[i][j]` represents the skill level the geek will reach after `j` efforts when their current skill level is `i`.

Here's the step-by-step breakdown of the solution:

1. Initialize the `dp` array with zeros, where `dp[0][j] = 0` for all `j`, and `dp[i][0] = i` for all `i`.
2. For each effort level `j` from 1 to `efforts`, iterate through the skill levels from `0` to `current_skill`. For each skill level `i`, calculate the new skill level `new_skill` using the formula `i + (effort - current_skill) / 3`.
3. Update the `dp` array by setting `dp[i][j] = max(dp[i-1][j-1], dp[new_skill][j-1])`. This represents the maximum skill level the geek can reach after `j` efforts, given their current skill level is `i`.
4. Find the smallest `j` such that `dp[current_skill][j] >= target_skill`, which represents the minimum number of efforts required to reach the target skill level.

Time complexity: O(efforts \* current_skill)
Space complexity: O(efforts \* current_skill)

## Optimized Solutions

### Java
```java
public int grindingGeek(int currentSkill, int efforts, int targetSkill) {
    int[][] dp = new int[currentSkill + 1][efforts + 1];
    for (int i = 0; i <= currentSkill; i++) {
        dp[i][0] = i;
    }
    for (int j = 1; j <= efforts; j++) {
        for (int i = 0; i <= currentSkill; i++) {
            int newSkill = Math.max(i, (i + (j - 1) / 3));
            dp[i][j] = Math.max(dp[i-1][j-1], dp[newSkill][j-1]);
        }
    }
    for (int j = efforts; j >= 0; j--) {
        if (dp[currentSkill][j] >= targetSkill) {
            return j;
        }
    }
    return -1; // not reachable
}
```

### Python
```python
def grinding_geek(current_skill, efforts, target_skill):
    dp = [[0] * (efforts + 1) for _ in range(current_skill + 1)]
    for i in range(current_skill + 1):
        dp[i][0] = i
    for j in range(1, efforts + 1):
        for i in range(current_skill + 1):
            new_skill = max(i, (i + (j - 1) // 3))
            dp[i][j] = max(dp[i-1][j-1], dp[new_skill][j-1])
    for j in range(efforts, -1, -1):
        if dp[current_skill][j] >= target_skill:
            return j
    return -1  # not reachable
```

### C++
```cpp
int grindingGeek(int currentSkill, int efforts, int targetSkill) {
    int dp[currentSkill + 1][efforts + 1];
    for (int i = 0; i <= currentSkill; i++) {
        dp[i][0] = i;
    }
    for (int j = 1; j <= efforts; j++) {
        for (int i = 0; i <= currentSkill; i++) {
            int newSkill = std::max(i, (i + (j - 1) / 3));
            dp[i][j] = std::max(dp[i-1][j-1], dp[newSkill][j-1]);
        }
    }
    for (int j = efforts; j >= 0; j--) {
        if (dp[currentSkill][j] >= targetSkill) {
            return j;
        }
    }
    return -1; // not reachable
}
```

### JavaScript
```javascript
function grindingGeek(currentSkill, efforts, targetSkill) {
    const dp = new Array(currentSkill + 1).fill(0).map(() => new Array(efforts + 1));
    for (let i = 0; i <= currentSkill; i++) {
        dp[i][0] = i;
    }
    for (let j = 1; j <= efforts; j++) {
        for (let i = 0; i <= currentSkill; i++) {
            const newSkill = Math.max(i, Math.floor((j - 1) / 3) + i);
            dp[i][j] = Math.max(dp[i-1][j-1], dp[newSkill][j-1]);
        }
    }
    for (let j = efforts; j >= 0; j--) {
        if (dp[currentSkill][j] >= targetSkill) {
            return j;
        }
    }
    return -1; // not reachable
}
```

Note: The optimized solutions are provided in the respective programming languages, with explanations and diagrams removed for brevity.