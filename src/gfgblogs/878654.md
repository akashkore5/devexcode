---
id: "878654"
title: "Find H-Index"
slug: "find-h-index--165609"
difficulty: "Medium"
companyTags: []
tags: ["Sorting", "Arrays"]
---

Here is the detailed blog post for the problem:

**Find H-Index**
==================

## Summary
The problem requires you to find the H-Index, which is a measure of the productivity and citation impact of the publication of a scholar. The H-Index is defined as the largest number of papers that have at least that many citations each. For example, if a researcher has published 5 papers with at least 3 citations each, then their H-Index is 3. This problem involves sorting and manipulating arrays.

## Detailed Explanation
The given array represents the citation count for different publications. To find the H-Index, we need to sort this array in descending order and then iterate over it until we find the first element that has a citation count less than its index plus one. The size of this array will be our H-Index.

Here is a step-by-step breakdown of the solution:

1.  Sort the given array in descending order.
2.  Initialize the H-Index to 0.
3.  Iterate over the sorted array from left to right.
4.  For each element, check if its citation count is less than or equal to its index plus one.
5.  If it is, then update the H-Index with the current index and break out of the loop.
6.  Return the updated H-Index.

The time complexity for this algorithm is O(n log n) due to the sorting step, where n is the number of publications (or elements in the array). The space complexity is O(1), as we only need a constant amount of space to store the H-Index and iterate variables.

## Optimized Solutions
Here are the optimized solutions for this problem in different languages:

### Java
```java
import java.util.Arrays;

public class Main {
    public static int hIndex(int[] citations) {
        Arrays.sort(citations);
        int n = citations.length;
        for (int i = 0; i < n; i++) {
            if (citations[i] < i + 1) {
                return i;
            }
        }
        return n;
    }
}
```

### Python
```python
def hIndex(citations):
    citations.sort(reverse=True)
    n = len(citations)
    for i in range(n):
        if citations[i] < i + 1:
            return i
    return n
```

### C++
```cpp
#include <algorithm>
#include <vector>

int hIndex(std::vector<int>& citations) {
    std::sort(citations.begin(), citations.end(), std::greater<int>());
    int n = citations.size();
    for (int i = 0; i < n; i++) {
        if (citations[i] < i + 1) {
            return i;
        }
    }
    return n;
}
```

### JavaScript
```javascript
function hIndex(citations) {
    citations.sort((a, b) => b - a);
    let n = citations.length;
    for (let i = 0; i < n; i++) {
        if (citations[i] < i + 1) {
            return i;
        }
    }
    return n;
}
```

These solutions all follow the same basic approach: sort the array in descending order, then iterate over it to find the H-Index. The time complexity for each solution is O(n log n) due to the sorting step, and the space complexity is O(1) since we only need a constant amount of space to store the H-Index and iterate variables.