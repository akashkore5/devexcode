---
id: "710056"
title: "Stack Permutations"
slug: "stack-permutations"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Stack", "implementation", "Data Structures"]
---

# Stack Permutations
## Summary
Given a stack of integers, generate all possible permutations of its elements. This problem involves manipulating an array using a stack data structure, making it a combination of arrays and stacks.

## Detailed Explanation
To solve this problem, we can use the concept of recursive backtracking to generate all possible permutations. We'll start by popping all elements from the stack and storing them in an array. Then, we'll use recursion to generate all permutations of the remaining stack (which will be an empty stack eventually).

Here's a step-by-step breakdown of the solution:
1. Initialize an empty stack `stack` and a result list `permutations`.
2. Pop all elements from the stack and store them in the `permutations` list.
3. If the stack is empty, add the current permutation to the `permutations` list and return.
4. Otherwise, recursively generate all permutations of the remaining stack (i.e., the stack with the last element removed).
5. For each permutation generated in step 4, insert the last popped element at every possible position to create a new permutation.
6. Add these new permutations to the `permutations` list and return.

Time complexity: O(n!), where n is the number of elements in the original stack. This is because we're generating all possible permutations of the elements.
Space complexity: O(n), for storing the permutations.

Here's an ASCII art diagram illustrating the process:
```
  +---------------+
  |  Stack: [1, 2, 3] |
  +---------------+
           |
           |  Pop all elements
           v
  +---------------+
  | Permutations: [] |
  +---------------+
           |
           |  Recursively generate permutations of remaining stack
           v
  +---------------+
  | Permutations: [[1], [2], [3]] |
  +---------------+
           |
           |  Insert last popped element at every possible position
           v
  +---------------+
  | Permutations: [[1, 2], [1, 3], [2, 3], [1], [2], [3]] |
  +---------------+
```

## Optimized Solutions

### Java
```java
import java.util.*;

public class StackPermutations {
    public List<List<Integer>> getStackPermutations(int[] stack) {
        List<List<Integer>> permutations = new ArrayList<>();
        backtrack(stack, new ArrayList<>(), permutations);
        return permutations;
    }

    private void backtrack(int[] stack, List<Integer> current, List<List<Integer>> permutations) {
        if (stack.length == 0) {
            permutations.add(new ArrayList<>(current));
            return;
        }
        for (int i = 0; i <= current.size(); i++) {
            current.add(stack[stack.length - 1]);
            backtrack(Arrays.copyOfRange(stack, 0, stack.length - 1), current, permutations);
            current.remove(current.size() - 1);
        }
    }

    public static void main(String[] args) {
        StackPermutations sp = new StackPermutations();
        int[] stack = {1, 2, 3};
        List<List<Integer>> permutations = sp.getStackPermutations(stack);
        System.out.println(permutations);
    }
}
```

### Python
```python
def get_stack_permutations(stack):
    permutations = []
    backtrack(stack, [], permutations)
    return permutations

def backtrack(stack, current, permutations):
    if not stack:
        permutations.append(current[:])
        return
    for i in range(len(current) + 1):
        current.append(stack[-1])
        backtrack(stack[:-1], current, permutations)
        current.pop()

print(get_stack_permutations([1, 2, 3]))
```

### C++
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<vector<int>> getStackPermutations(vector<int> stack) {
    vector<vector<int>> permutations;
    backtrack(stack, {}, permutations);
    return permutations;
}

void backtrack(vector<int>& stack, vector<int> current, vector<vector<int>>& permutations) {
    if (stack.empty()) {
        permutations.push_back(current);
        return;
    }
    for (int i = 0; i <= current.size(); i++) {
        current.push_back(stack.back());
        backtrack(stack, current, permutations);
        current.pop_back();
    }
}

int main() {
    vector<int> stack = {1, 2, 3};
    vector<vector<int>> permutations = getStackPermutations(stack);
    for (const auto& permutation : permutations) {
        cout << permutation << endl;
    }
    return 0;
}
```

### JavaScript
```javascript
function getStackPermutations(stack) {
    const permutations = [];
    backtrack(stack, [], permutations);
    return permutations;

    function backtrack(stack, current, permutations) {
        if (!stack.length) {
            permutations.push([...current]);
            return;
        }
        for (let i = 0; i <= current.length; i++) {
            current.push(stack.pop());
            backtrack(stack, current, permutations);
            current.pop();
        }
    }
}

console.log(getStackPermutations([1, 2, 3]));
```

Note: The optimized solutions are in the respective programming languages and use the concept of recursive backtracking to generate all possible permutations.