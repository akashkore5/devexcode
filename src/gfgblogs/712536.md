---
id: "712536"
title: "Insert Interval"
slug: "insert-interval-1666733333"
difficulty: "Medium"
companyTags: []
tags: []
---

# Insert Interval

## Summary
The problem is to insert a new interval into an existing set of intervals, where each interval is represented by a pair of numbers (start, end). The goal is to maintain the integrity of the intervals and ensure that the new interval does not overlap with any existing interval. This requires identifying the correct position for the new interval and updating the set accordingly.

## Detailed Explanation
To solve this problem, we can sort the intervals based on their start value. Then, iterate through the sorted intervals and insert the new interval at the appropriate position. The key is to identify when to stop iterating and inserting new intervals.

Here's a step-by-step breakdown of the solution:

1. Sort the existing intervals by their start value.
2. Initialize an index variable `i` to 0, which will be used to track the current position in the sorted interval list.
3. Iterate through the sorted intervals:
   * If the new interval starts before the current interval ends, insert the new interval at the beginning of the list (index `i`).
   * If the new interval overlaps with the current interval, check if it starts after the current interval ends and ends before the next interval starts. If true, insert the new interval between the two intervals.
   * If the new interval does not overlap with any existing interval, insert it at the end of the list (index `i`).
4. Update the index `i` to reflect the new position in the sorted interval list.

Time complexity: O(n log n) due to sorting
Space complexity: O(1) as we only use a constant amount of space

## Optimized Solutions

### Java
```java
class Interval {
    int start;
    int end;

    public Interval(int start, int end) {
        this.start = start;
        this.end = end;
    }
}

public class InsertInterval {
    public static int[][] insert(int[][] intervals, int[] newInterval) {
        List<Interval> sortedIntervals = new ArrayList<>();
        for (int[] interval : intervals) {
            sortedIntervals.add(new Interval(interval[0], interval[1]));
        }
        sortedIntervals.add(new Interval(newInterval[0], newInterval[1]));

        List<Interval> result = new ArrayList<>();
        int i = 0;
        while (i < sortedIntervals.size()) {
            if (newInterval[0] <= sortedIntervals.get(i).end) {
                break;
            }
            result.add(sortedIntervals.get(i));
            i++;
        }

        Interval currentInterval = sortedIntervals.get(i);
        while (i < sortedIntervals.size() && newInterval[1] >= currentInterval.start) {
            if (newInterval[0] <= currentInterval.end && currentInterval.start <= newInterval[1]) {
                result.add(new Interval(Math.min(currentInterval.start, newInterval[0]), Math.max(currentInterval.end, newInterval[1])));
                i++;
                currentInterval = sortedIntervals.get(i);
            } else if (currentInterval.end < newInterval[0]) {
                result.add(currentInterval);
                i++;
                currentInterval = sortedIntervals.get(i);
            }
        }

        while (i < sortedIntervals.size()) {
            result.add(sortedIntervals.get(i));
            i++;
        }

        return result.stream().mapToInt(interval -> {return new int[] { interval.start, interval.end };}).toArray(int[][]::new);
    }
}
```

### Python
```python
class Interval:
    def __init__(self, start, end):
        self.start = start
        self.end = end

def insert(intervals, newInterval):
    sortedIntervals = [Interval(*interval) for interval in intervals]
    sortedIntervals.append(Interval(*newInterval))

    result = []
    i = 0
    while i < len(sortedIntervals):
        if newInterval[0] <= sortedIntervals[i].end:
            break
        result.append(sortedIntervals[i])
        i += 1

    currentInterval = sortedIntervals[i]
    while i < len(sortedIntervals) and newInterval[1] >= currentInterval.start:
        if newInterval[0] <= currentInterval.end and currentInterval.start <= newInterval[1]:
            result.append(Interval(min(currentInterval.start, newInterval[0]), max(currentInterval.end, newInterval[1])))
            i += 1
            currentInterval = sortedIntervals[i]
        elif currentInterval.end < newInterval[0]:
            result.append(currentInterval)
            i += 1
            currentInterval = sortedIntervals[i]

    while i < len(sortedIntervals):
        result.append(sortedIntervals[i])
        i += 1

    return [list(interval) for interval in result]
```

### C++
```cpp
class Interval {
public:
    int start;
    int end;

    Interval(int start, int end) : start(start), end(end) {}
};

std::vector<int*> insert(std::vector<Interval*> intervals, Interval* newInterval) {
    std::sort(intervals.begin(), intervals.end(), [](const Interval* a, const Interval* b) {
        return a->start < b->start;
    });

    intervals.push_back(newInterval);

    std::vector<int*> result;
    int i = 0;
    while (i < intervals.size()) {
        if (newInterval->start <= intervals[i]->end) {
            break;
        }
        result.push_back(&intervals[i]->start);
        i++;
    }

    Interval* currentInterval = &intervals[i];
    while (i < intervals.size() && newInterval->end >= currentInterval->start) {
        if (newInterval->start <= currentInterval->end && currentInterval->start <= newInterval->end) {
            result.push_back(new int[]{std::min(currentInterval->start, newInterval->start), std::max(currentInterval->end, newInterval->end)});
            i++;
            currentInterval = &intervals[i];
        } else if (currentInterval->end < newInterval->start) {
            result.push_back(&currentInterval->start);
            i++;
            currentInterval = &intervals[i];
        }
    }

    while (i < intervals.size()) {
        result.push_back(&intervals[i]->start);
        i++;
    }

    return result;
}
```

### JavaScript
```javascript
class Interval {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
}

function insert(intervals, newInterval) {
  intervals.push(new Interval(...newInterval));

  let result = [];
  for (let i = 0; i < intervals.length; i++) {
    if (newInterval[0] <= intervals[i].end) {
      break;
    }
    result.push({ start: intervals[i].start, end: intervals[i].end });
  }

  let currentInterval = intervals[i];
  while (i < intervals.length && newInterval[1] >= currentInterval.start) {
    if (newInterval[0] <= currentInterval.end && currentInterval.start <= newInterval[1]) {
      result.push({ start: Math.min(currentInterval.start, newInterval[0]), end: Math.max(currentInterval.end, newInterval[1]) });
      i++;
      currentInterval = intervals[i];
    } else if (currentInterval.end < newInterval[0]) {
      result.push({ start: currentInterval.start, end: currentInterval.end });
      i++;
      currentInterval = intervals[i];
    }
  }

  while (i < intervals.length) {
    result.push({ start: currentInterval.start, end: currentInterval.end });
    i++;
  }

  return result;
}
```