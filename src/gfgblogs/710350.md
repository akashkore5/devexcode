---
id: "710350"
title: "Construct Binary Tree from String with bracket representation"
slug: "construct-binary-tree-from-string-with-bracket-representation"
difficulty: "Medium"
companyTags: []
tags: ["Strings", "Tree", "Data Structures"]
---

# Construct Binary Tree from String with Bracket Representation
## Slug: construct-binary-tree-from-string-with-bracket-representation
## Difficulty: Medium
## Id: 710350
## Topic Tags: Strings, Tree, Data Structures
## Company Tags: None

### Summary
Construct a binary tree from a given string representation using brackets. The input string is in the format of a pre-order traversal of the binary tree, where each node is represented as an integer followed by its left and right child nodes enclosed in square brackets. For example, "1[2[4]3[5[6]]]" represents the following binary tree:

```
    1
   / \
  2   3
 /     \
4       5
      /
     6
```

### Detailed Explanation

The problem requires constructing a binary tree from a string representation using brackets. The input string is in pre-order traversal format, where each node's value is followed by its left and right child nodes enclosed in square brackets.

To solve this problem, we can use a recursive approach to construct the binary tree. Here are the steps:

1. Initialize an empty binary tree.
2. Iterate through the input string. When you encounter an integer, create a new node with that value and add it to the current node's left or right child position (depending on whether it is a left or right bracket).
3. When you encounter a bracket, recursively construct the left subtree if it's an opening bracket ( '[' ) or the right subtree if it's a closing bracket ( ']' ).
4. Continue this process until the end of the input string.

Here's a step-by-step breakdown:

```
    Input String: "1[2[4]3[5[6]]]"
    1. Initialize an empty binary tree.
    2. Encounter "1", create a new node with value 1 and add it to the root of the binary tree.
    3. Encounter "[", recursively construct the left subtree.
        * Encounter "2", create a new node with value 2 and add it as the left child of the current node (node 1).
        * Encounter "[", recursively construct the left subtree of node 2.
            - Encounter "4", create a new node with value 4 and add it as the left child of node 2.
        * Encounter "]", return to the previous level and continue constructing the right subtree of node 1.
    4. Continue this process until the end of the input string, resulting in the constructed binary tree:
```

The time complexity of this solution is O(n), where n is the length of the input string, since we iterate through the string once to construct the binary tree. The space complexity is O(h), where h is the height of the binary tree, since we recursively construct the tree and store nodes in memory.

### Optimized Solutions

#### Java
```java
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    public TreeNode(int x) { val = x; }
}

public class Solution {
    public TreeNode stringToTreeNode(String s) {
        if (s == null || s.length() == 0) return null;

        String[] nodes = s.split(",");
        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));
        constructTree(root, nodes, 1);
        return root;
    }

    private void constructTree(TreeNode node, String[] nodes, int index) {
        if (index >= nodes.length) return;

        String current = nodes[index];
        if (current.startsWith("[")) {
            // Left subtree
            node.left = new TreeNode(Integer.parseInt(current.substring(1, current.indexOf("]"))));
            constructTree(node.left, nodes, index + 1);
        } else if (current.endsWith("]")) {
            // Right subtree
            node.right = new TreeNode(Integer.parseInt(current.substring(0, current.length() - 1)));
            constructTree(node.right, nodes, index + 1);
        }
    }
}
```

#### Python
```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def stringToTreeNode(s):
    if not s or len(s) == 0: return None

    nodes = s.split(",")
    root = TreeNode(int(nodes[0]))
    constructTree(root, nodes, 1)
    return root

def constructTree(node, nodes, index):
    if index >= len(nodes): return

    current = nodes[index]
    if current.startswith("["):
        # Left subtree
        node.left = TreeNode(int(current[1:current.index("]")]))
        constructTree(node.left, nodes, index + 1)
    elif current.endswith("]"):
        # Right subtree
        node.right = TreeNode(int(current[:current.length() - 1]))
        constructTree(node.right, nodes, index + 1)
```

#### C++
```cpp
class TreeNode {
public:
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* stringToTreeNode(string s) {
    if (s.empty()) return NULL;

    vector<string> nodes;
    stringstream ss(s);
    string token;
    while (getline(ss, token, ',')) {
        nodes.push_back(token);
    }

    TreeNode* root = new TreeNode(stoi(nodes[0]));
    constructTree(root, &nodes, 1);
    return root;
}

void constructTree(TreeNode* node, vector<string>* nodes, int index) {
    if (index >= nodes->size()) return;

    string current = (*nodes)[index];
    if (current.find("[") == 0) {
        // Left subtree
        node->left = new TreeNode(stoi(current.substr(1, current.find("]") - 1)));
        constructTree(node->left, nodes, index + 1);
    } else if (current.find("]") == current.size() - 1) {
        // Right subtree
        node->right = new TreeNode(stoi(current.substr(0, current.find("[") - 1)));
        constructTree(node->right, nodes, index + 1);
    }
}
```

#### JavaScript
```javascript
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

function stringToTreeNode(s) {
  if (!s || s.length === 0) return null;

  const nodes = s.split(",");
  const root = new TreeNode(parseInt(nodes[0]));
  constructTree(root, nodes, 1);
  return root;
}

function constructTree(node, nodes, index) {
  if (index >= nodes.length) return;

  const current = nodes[index];
  if (current.startsWith("[")) {
    // Left subtree
    node.left = new TreeNode(parseInt(current.substring(1, current.indexOf("]") - 1)));
    constructTree(node.left, nodes, index + 1);
  } else if (current.endsWith("]")) {
    // Right subtree
    node.right = new TreeNode(parseInt(current.substring(0, current.length - 1)));
    constructTree(node.right, nodes, index + 1);
  }
}
```