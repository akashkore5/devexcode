---
id: "713585"
title: "BST Downward Traversal"
slug: "bst-downward-traversal--170646"
difficulty: "Medium"
companyTags: []
tags: ["Binary Search Tree"]
---

**BST Downward Traversal**
=====================

### Summary
Given a Binary Search Tree (BST), perform a downward traversal from the root node to all leaf nodes, printing each node's value in descending order.

Key concepts involved: BST, tree traversal.

### Detailed Explanation
To solve this problem, we'll use an in-order traversal algorithm with some modifications to achieve the desired downward traversal. We'll start at the root node and recursively visit its left subtree, then the current node itself, and finally its right subtree. This order ensures that we print each node's value in descending order.

Here's a step-by-step breakdown of the solution:

1. Start at the root node.
2. Recursively traverse the left subtree (if it exists).
3. Print the current node's value.
4. Recursively traverse the right subtree (if it exists).

To illustrate this process, consider the following ASCII art representation of a BST:
```
       8
     /   \
    5     12
   / \   / \
  2   6 10 14
```
In this example, the downward traversal from the root node (8) would visit nodes in the order: 12, 14, 10, 6, 8, 5, 2.

The time complexity of this algorithm is O(n), where n is the number of nodes in the BST. The space complexity is O(h), where h is the height of the tree, since we need to store the recursion stack.

### Optimized Solutions

#### Java
```java
public class Main {
    public static void downwardTraversal(Node node) {
        if (node == null) return;
        downwardTraversal(node.right);
        System.out.println(node.val);
        downwardTraversal(node.left);
    }

    public static void main(String[] args) {
        Node root = new Node(8);
        root.left = new Node(5);
        root.right = new Node(12);
        root.left.left = new Node(2);
        root.left.right = new Node(6);
        root.right.left = new Node(10);
        root.right.right = new Node(14);

        downwardTraversal(root);
    }
}

class Node {
    int val;
    Node left, right;

    public Node(int val) {
        this.val = val;
    }
}
```

#### Python
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def downward_traversal(node):
    if node is None: return
    downward_traversal(node.right)
    print(node.val)
    downward_traversal(node.left)

root = Node(8)
root.left = Node(5)
root.right = Node(12)
root.left.left = Node(2)
root.left.right = Node(6)
root.right.left = Node(10)
root.right.right = Node(14)

downward_traversal(root)
```

#### C++
```cpp
#include <iostream>

struct Node {
    int val;
    struct Node* left;
    struct Node* right;

    Node(int val) : val(val), left(nullptr), right(nullptr) {}
};

void downwardTraversal(Node* node) {
    if (node == nullptr) return;
    downwardTraversal(node->right);
    std::cout << node->val << std::endl;
    downwardTraversal(node->left);
}

int main() {
    Node* root = new Node(8);
    root->left = new Node(5);
    root->right = new Node(12);
    root->left->left = new Node(2);
    root->left->right = new Node(6);
    root->right->left = new Node(10);
    root->right->right = new Node(14);

    downwardTraversal(root);
    delete root;
    return 0;
}
```

#### JavaScript
```javascript
class Node {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function downwardTraversal(node) {
    if (node === null) return;
    downwardTraversal(node.right);
    console.log(node.val);
    downwardTraversal(node.left);
}

const root = new Node(8);
root.left = new Node(5);
root.right = new Node(12);
root.left.left = new Node(2);
root.left.right = new Node(6);
root.right.left = new Node(10);
root.right.right = new Node(14);

downwardTraversal(root);
```

Note: The optimized solutions provided are in the form of a recursive function, which is suitable for this problem since we need to traverse the tree in a depth-first manner.