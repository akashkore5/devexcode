---
id: "874906"
title: "Minimum cost to connect all houses in a city"
slug: "minimum-cost-to-connect-all-houses-in-a-city"
difficulty: "Medium"
companyTags: []
tags: []
---

**Minimum cost to connect all houses in a city**
=============================

## Summary
The problem is about finding the minimum cost to connect all houses in a city, given that each connection between two houses costs a certain amount and there are no restrictions on which houses can be connected. This is an optimization problem that involves graph theory concepts.

## Detailed Explanation
To solve this problem, we can use Kruskal's algorithm, which is used to find the minimum spanning tree of a graph. The idea is to sort all the edges in non-decreasing order of their weights and then pick the smallest unselected edge. If it doesn't form a cycle with the already selected edges, include it; otherwise, discard it.

Here are the steps:

1.  Initialize an empty graph `G` and add all houses as nodes.
2.  Create a list `E` to store all possible connections between houses (edges).
3.  Sort the edges in non-decreasing order of their weights.
4.  Iterate over the sorted edges and pick the smallest unselected edge.
5.  If it doesn't form a cycle with the already selected edges, include it; otherwise, discard it.
6.  Repeat step 4 until all houses are connected.
7.  The total cost is the sum of the weights of all included edges.

Here's an ASCII art diagram to illustrate the process:
```
   A---B---C
  /       \
 D         E
|           |
 F         G
```

Time complexity: O(ElogE) where E is the number of edges.
Space complexity: O(V + E), where V is the number of vertices (houses).

## Optimized Solutions

### Java
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Input graph represented as an adjacency list
        Map<Integer, List<Edge>> graph = new HashMap<>();
        // Add edges to the graph
        graph.put(0, Arrays.asList(new Edge(0, 1, 4), new Edge(0, 2, 3)));
        graph.put(1, Arrays.asList(new Edge(1, 2, 2)));
        graph.put(2, Arrays.asList(new Edge(2, 3, 10)));

        // Find minimum spanning tree using Kruskal's algorithm
        List<Edge> mst = new ArrayList<>();
        for (Edge edge : getEdges(graph)) {
            if (!isCycle(edge, graph, mst)) {
                mst.add(edge);
            }
        }

        System.out.println("Minimum cost: " + calculateCost(mst));
    }

    static class Edge {
        int from;
        int to;
        int weight;

        public Edge(int from, int to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
    }

    static List<Edge> getEdges(Map<Integer, List<Edge>> graph) {
        List<Edge> edges = new ArrayList<>();
        for (List<Edge> edgeList : graph.values()) {
            edges.addAll(edgeList);
        }
        return edges;
    }

    static boolean isCycle(Edge edge, Map<Integer, List<Edge>> graph, List<Edge> mst) {
        int parent = getParent(edge.from, graph, mst);
        if (parent == -1) {
            return false; // Edge forms a cycle
        } else {
            return true;
        }
    }

    static int getParent(int node, Map<Integer, List<Edge>> graph, List<Edge> mst) {
        for (Edge edge : mst) {
            if (edge.from == node || edge.to == node) {
                return edge.from;
            }
        }
        return -1; // Node is not connected
    }

    static int calculateCost(List<Edge> mst) {
        int cost = 0;
        for (Edge edge : mst) {
            cost += edge.weight;
        }
        return cost;
    }
}
```

### Python
```python
class Edge:
    def __init__(self, from_node, to_node, weight):
        self.from_node = from_node
        self.to_node = to_node
        self.weight = weight

def get_edges(graph):
    edges = []
    for edge_list in graph.values():
        edges.extend(edge_list)
    return edges

def is_cycle(edge, graph, mst):
    parent = find_parent(edge.from_node, graph, mst)
    if parent == -1:
        return False  # Edge forms a cycle
    else:
        return True

def find_parent(node, graph, mst):
    for edge in mst:
        if edge.from_node == node or edge.to_node == node:
            return edge.from_node
    return -1  # Node is not connected

def calculate_cost(mst):
    cost = 0
    for edge in mst:
        cost += edge.weight
    return cost

# Input graph represented as an adjacency list
graph = {
    0: [Edge(0, 1, 4), Edge(0, 2, 3)],
    1: [Edge(1, 2, 2)],
    2: [Edge(2, 3, 10)]
}

# Find minimum spanning tree using Kruskal's algorithm
mst = []
for edge in get_edges(graph):
    if not is_cycle(edge, graph, mst):
        mst.append(edge)

print("Minimum cost:", calculate_cost(mst))
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Edge {
    int from;
    int to;
    int weight;

    Edge(int from, int to, int weight) : from(from), to(to), weight(weight) {}
};

int findParent(int node, std::vector<Edge>& mst) {
    for (Edge& edge : mst) {
        if (edge.from == node || edge.to == node) {
            return edge.from;
        }
    }
    return -1; // Node is not connected
}

bool isCycle(Edge edge, std::vector<Edge>& mst) {
    int parent = findParent(edge.from, mst);
    if (parent == -1) {
        return false; // Edge forms a cycle
    } else {
        return true;
    }
}

int calculateCost(std::vector<Edge>& mst) {
    int cost = 0;
    for (Edge& edge : mst) {
        cost += edge.weight;
    }
    return cost;
}

// Input graph represented as an adjacency list
std::vector<Edge> edges = {
    Edge(0, 1, 4),
    Edge(0, 2, 3),
    Edge(1, 2, 2),
    Edge(2, 3, 10)
};

// Find minimum spanning tree using Kruskal's algorithm
std::vector<Edge> mst;
for (Edge& edge : edges) {
    if (!isCycle(edge, mst)) {
        mst.push_back(edge);
    }
}

std::cout << "Minimum cost: " << calculateCost(mst) << std::endl;
```

### JavaScript
```javascript
class Edge {
  constructor(from, to, weight) {
    this.from = from;
    this.to = to;
    this.weight = weight;
  }
}

function getEdges(graph) {
  const edges = [];
  for (const edgeList of Object.values(graph)) {
    edges.push(...edgeList);
  }
  return edges;
}

function isCycle(edge, graph, mst) {
  const parent = getParent(edge.from, graph, mst);
  if (parent === -1) {
    return false; // Edge forms a cycle
  } else {
    return true;
  }
}

function getParent(node, graph, mst) {
  for (const edge of mst) {
    if (edge.from === node || edge.to === node) {
      return edge.from;
    }
  }
  return -1; // Node is not connected
}

function calculateCost(mst) {
  let cost = 0;
  for (const edge of mst) {
    cost += edge.weight;
  }
  return cost;
}

// Input graph represented as an adjacency list
const graph = {
  0: [{ from: 0, to: 1, weight: 4 }, { from: 0, to: 2, weight: 3 }],
  1: [{ from: 1, to: 2, weight: 2 }],
  2: [{ from: 2, to: 3, weight: 10 }]
};

// Find minimum spanning tree using Kruskal's algorithm
const mst = [];
for (const edge of getEdges(graph)) {
  if (!isCycle(edge, graph, mst)) {
    mst.push(edge);
  }
}

console.log(`Minimum cost: ${calculateCost(mst)}`);
```