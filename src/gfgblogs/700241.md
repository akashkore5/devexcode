---
id: "700241"
title: "Max sum path in two arrays"
slug: "max-sum-path-in-two-arrays"
difficulty: "Medium"
companyTags: ["Amazon"]
tags: ["Arrays", "Data Structures"]
---

# Max sum path in two arrays

## Summary

The problem is to find the maximum sum path between two arrays. Given two arrays `A` and `B`, each containing non-negative integers, you need to find a sequence of elements from both arrays that adds up to the maximum possible value. This problem requires understanding of dynamic programming concepts and array manipulation techniques.

## Detailed Explanation

To solve this problem, we will use dynamic programming to build a 2D table where each cell represents the maximum sum path ending at that point. We start by initializing a 2D table `dp` with dimensions `(m+1) x (n+1)` where `m` and `n` are the lengths of arrays `A` and `B`, respectively.

We iterate through both arrays simultaneously, and for each pair of elements `(a, b)` from `A` and `B`, we calculate the maximum sum path ending at that point. This is done by considering two options: either take the current element from array `A` or array `B`, and then recursively find the maximum sum path in the remaining arrays.

The time complexity of this approach is O(m*n) where m and n are the lengths of arrays A and B, respectively. The space complexity is also O(m*n) for storing the dynamic programming table.

Here's a step-by-step breakdown of the solution:

1. Initialize a 2D table `dp` with dimensions `(m+1) x (n+1)` where `m` and `n` are the lengths of arrays `A` and `B`, respectively.
2. Iterate through both arrays simultaneously, considering each pair of elements `(a, b)` from `A` and `B`.
3. For each pair `(a, b)`, calculate the maximum sum path ending at that point by considering two options:
   - Take the current element `a` from array `A` and recursively find the maximum sum path in the remaining arrays.
   - Take the current element `b` from array `B` and recursively find the maximum sum path in the remaining arrays.
4. Store the maximum sum path ending at each point in the dynamic programming table `dp`.
5. The maximum sum path is stored in the last cell of the dynamic programming table, which corresponds to the maximum sum path between the two arrays.

## Optimized Solutions

### Java
```java
public int maxSumPath(int[] A, int[] B) {
    int m = A.length;
    int n = B.length;
    int[][] dp = new int[m+1][n+1];

    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0) {
                dp[i][j] = B[j];
            } else if (j == 0) {
                dp[i][j] = A[i-1];
            } else {
                dp[i][j] = Math.max(A[i-1], B[j-1]) + dp[i-1][j-1];
            }
        }
    }

    return dp[m][n];
}
```

### Python
```python
def max_sum_path(A, B):
    m, n = len(A), len(B)
    dp = [[0] * (n+1) for _ in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0:
                dp[i][j] = B[j]
            elif j == 0:
                dp[i][j] = A[i-1]
            else:
                dp[i][j] = max(A[i-1], B[j-1]) + dp[i-1][j-1]

    return dp[m][n]
```

### C++
```cpp
int maxSumPath(int* A, int* B, int m, int n) {
    int** dp = new int*[m+1];
    for (int i = 0; i <= m; i++) {
        dp[i] = new int[n+1];
    }

    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            if (i == 0) {
                dp[i][j] = B[j];
            } else if (j == 0) {
                dp[i][j] = A[i-1];
            } else {
                dp[i][j] = max(A[i-1], B[j-1]) + dp[i-1][j-1];
            }
        }
    }

    int result = dp[m][n];
    for (int i = 0; i <= m; i++) {
        delete[] dp[i];
    }
    delete[] dp;

    return result;
}
```

### JavaScript
```javascript
function maxSumPath(A, B) {
    let m = A.length;
    let n = B.length;
    let dp = new Array(m+1).fill(0).map(() => new Array(n+1).fill(0));

    for (let i = 0; i <= m; i++) {
        for (let j = 0; j <= n; j++) {
            if (i == 0) {
                dp[i][j] = B[j];
            } else if (j == 0) {
                dp[i][j] = A[i-1];
            } else {
                dp[i][j] = Math.max(A[i-1], B[j-1]) + dp[i-1][j-1];
            }
        }
    }

    return dp[m][n];
}
```