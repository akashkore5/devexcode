---
id: "712030"
title: "Shortest path in Directed Acyclic Graph"
slug: "shortest-path-in-undirected-graph"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "Shortest Path", "Data Structures", "Algorithms"]
---

# Shortest Path in Directed Acyclic Graph
## Slug: shortest-path-in-directed-acyclic-graph
## Difficulty: Medium
## Id: 712030
## Topic Tags: Graph, Shortest Path, Data Structures, Algorithms
## Company Tags: None

### Summary
In this problem, we are given a directed acyclic graph (DAG) and asked to find the shortest path from a source node to all other nodes in the graph. This is an extension of the classic shortest path problem for undirected graphs, where we need to consider the direction of edges in the graph.

### Detailed Explanation
To solve this problem, we can use topological sorting and Dijkstra's algorithm. Topological sorting is used to ensure that we visit all nodes in the correct order, while Dijkstra's algorithm finds the shortest path from the source node to each node.

Here's a step-by-step breakdown of the solution:

1. First, we perform a topological sort on the graph to get an ordering of the nodes.
2. Then, for each node `v` in the graph, we use Dijkstra's algorithm to find the shortest path from the source node `s` to `v`. We keep track of the distance from `s` to `v` and the previous node in the shortest path.
3. Finally, we return the distances and previous nodes for all nodes in the graph.

Here's an ASCII art diagram illustrating the algorithm:
```
       +--------+
       |  s  |
       +--------+
              |
              | (topological sort)
       +--------+
       |  v1  |
       +--------+
              |
              | (Dijkstra's algorithm)
       +--------+
       |  v2  |
       +--------+
              |
              | ...
```
Time complexity: O(|E|log|V|) where `|E|` is the number of edges and `|V|` is the number of nodes.
Space complexity: O(|V| + |E|).

### Optimized Solutions

#### Java
```java
import java.util.*;

public class ShortestPathInDAG {
    public static Map<Integer, Integer> shortestPath(int[][] graph) {
        // Perform topological sort
        List<Integer> order = new ArrayList<>();
        for (int i = 0; i < graph.length; i++) {
            if (!hasIncomingEdges(graph, i)) {
                order.add(i);
            }
        }

        Map<Integer, Integer> distances = new HashMap<>();
        Map<Integer, Integer> previousNodes = new HashMap<>();

        // Run Dijkstra's algorithm for each node in the graph
        for (int v : order) {
            distances.put(v, 0);
            previousNodes.put(v, null);

            for (int w : getNeighbors(graph, v)) {
                int weight = getEdgeWeight(graph, v, w);
                if (!distances.containsKey(w) || distances.get(w) > distances.get(v) + weight) {
                    distances.put(w, distances.get(v) + weight);
                    previousNodes.put(w, v);
                }
            }
        }

        return distances;
    }

    // Helper methods
    private static boolean hasIncomingEdges(int[][] graph, int node) {
        for (int i = 0; i < graph.length; i++) {
            if (graph[i][node] > 0) {
                return true;
            }
        }
        return false;
    }

    private static List<Integer> getNeighbors(int[][] graph, int node) {
        List<Integer> neighbors = new ArrayList<>();
        for (int i = 0; i < graph.length; i++) {
            if (graph[i][node] > 0) {
                neighbors.add(i);
            }
        }
        return neighbors;
    }

    private static int getEdgeWeight(int[][] graph, int u, int v) {
        // Assume edge weight is 1
        return 1;
    }
}
```

#### Python
```python
def shortest_path(graph):
    # Perform topological sort
    order = []
    for i in range(len(graph)):
        if not has_incoming_edges(graph, i):
            order.append(i)

    distances = {}
    previous_nodes = {}

    # Run Dijkstra's algorithm for each node in the graph
    for v in order:
        distances[v] = 0
        previous_nodes[v] = None

        for w in get_neighbors(graph, v):
            weight = get_edge_weight(graph, v, w)
            if not distances.get(w) or distances[w] > distances[v] + weight:
                distances[w] = distances[v] + weight
                previous_nodes[w] = v

    return distances

def has_incoming_edges(graph, node):
    for i in range(len(graph)):
        if graph[i][node] > 0:
            return True
    return False

def get_neighbors(graph, node):
    neighbors = []
    for i in range(len(graph)):
        if graph[i][node] > 0:
            neighbors.append(i)
    return neighbors

def get_edge_weight(graph, u, v):
    # Assume edge weight is 1
    return 1
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

class ShortestPathInDAG {
public:
    unordered_map<int, int> shortestPath(vector<vector<int>>& graph) {
        // Perform topological sort
        vector<int> order;
        for (int i = 0; i < graph.size(); i++) {
            if (!hasIncomingEdges(graph, i)) {
                order.push_back(i);
            }
        }

        unordered_map<int, int> distances;
        unordered_map<int, int> previousNodes;

        // Run Dijkstra's algorithm for each node in the graph
        for (int v : order) {
            distances[v] = 0;
            previousNodes[v] = NULL;

            for (int w : getNeighbors(graph, v)) {
                int weight = getEdgeWeight(graph, v, w);
                if (!distances.count(w) || distances[w] > distances[v] + weight) {
                    distances[w] = distances[v] + weight;
                    previousNodes[w] = v;
                }
            }
        }

        return distances;
    }

    // Helper methods
    bool hasIncomingEdges(vector<vector<int>>& graph, int node) {
        for (int i = 0; i < graph.size(); i++) {
            if (graph[i][node] > 0) {
                return true;
            }
        }
        return false;
    }

    vector<int> getNeighbors(vector<vector<int>>& graph, int node) {
        vector<int> neighbors;
        for (int i = 0; i < graph.size(); i++) {
            if (graph[i][node] > 0) {
                neighbors.push_back(i);
            }
        }
        return neighbors;
    }

    int getEdgeWeight(vector<vector<int>>& graph, int u, int v) {
        // Assume edge weight is 1
        return 1;
    }
};
```

#### JavaScript
```javascript
class ShortestPathInDAG {
  shortestPath(graph) {
    // Perform topological sort
    const order = [];
    for (let i = 0; i < graph.length; i++) {
      if (!this.hasIncomingEdges(graph, i)) {
        order.push(i);
      }
    }

    const distances = {};
    const previousNodes = {};

    // Run Dijkstra's algorithm for each node in the graph
    for (const v of order) {
      distances[v] = 0;
      previousNodes[v] = null;

      for (const w of this.getNeighbors(graph, v)) {
        const weight = this.getEdgeWeight(graph, v, w);
        if (!distances[w] || distances[w] > distances[v] + weight) {
          distances[w] = distances[v] + weight;
          previousNodes[w] = v;
        }
      }
    }

    return distances;
  }

  // Helper methods
  hasIncomingEdges(graph, node) {
    for (let i = 0; i < graph.length; i++) {
      if (graph[i][node] > 0) {
        return true;
      }
    }
    return false;
  }

  getNeighbors(graph, node) {
    const neighbors = [];
    for (let i = 0; i < graph.length; i++) {
      if (graph[i][node] > 0) {
        neighbors.push(i);
      }
    }
    return neighbors;
  }

  getEdgeWeight(graph, u, v) {
    // Assume edge weight is 1
    return 1;
  }
}
```

Note: The above code assumes that the graph is represented as an adjacency matrix. You may need to modify it to suit your specific use case.