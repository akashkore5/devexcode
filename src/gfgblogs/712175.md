---
id: "712175"
title: "Asteroid Collision"
slug: "asteroid-collision"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Stack", "Data Structures"]
---

**Asteroid Collision**
=====================

### Summary
Given a list of asteroids and their positions, determine which asteroids will collide with each other. Two asteroids are considered to collide if they have the same position in space.

This problem involves understanding the concept of stacks and arrays, as well as using these data structures to solve the problem efficiently.

### Detailed Explanation
The asteroid collision problem can be solved by treating the list of asteroids as a stack. We iterate over the list from right to left, considering each asteroid's position. If an asteroid is about to collide with the one above it (i.e., they have the same position), we remove the top asteroid from the stack until there are no more collisions.

Here is a step-by-step breakdown of the solution:

1. Initialize an empty stack.
2. Iterate over the list of asteroids from right to left.
3. For each asteroid, check if it will collide with the one above it (i.e., they have the same position).
4. If a collision is detected, remove the top asteroid from the stack until there are no more collisions.
5. Once all asteroids have been processed, the remaining asteroids in the stack represent those that will not collide.

Time complexity: O(n), where n is the number of asteroids.
Space complexity: O(1), as we only use a constant amount of space to store the stack.

### Optimized Solutions

#### Java
```java
import java.util.Stack;

public class AsteroidCollision {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stack = new Stack<>();
        for (int i = asteroids.length - 1; i >= 0; i--) {
            while (!stack.isEmpty() && Math.abs(asteroids[i]) != Math.abs(stack.peek())) {
                if (Math.abs(asteroids[i]) > Math.abs(stack.pop())) {
                    stack.push(asteroids[i]);
                    break;
                } else if (Math.abs(asteroids[i]) < Math.abs(stack.peek())) {
                    break;
                }
            } else {
                stack.push(asteroids[i]);
            }
        }
        int[] result = new int[stack.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = stack.pop();
        }
        return result;
    }
}
```

#### Python
```python
def asteroidCollision(asteroids):
    stack = []
    for asteroid in asteroids[::-1]:
        while stack and abs(asteroid) != abs(stack[-1]):
            if abs(asteroid) > abs(stack.pop()):
                stack.append(asteroid)
                break
            elif abs(asteroid) < abs(stack[-1]):
                break
        else:
            stack.append(asteroid)
    return list(reversed(stack))
```

#### C++
```cpp
#include <stack>
#include <vector>

std::vector<int> asteroidCollision(std::vector<int>& asteroids) {
    std::stack<int> stack;
    for (int i = asteroids.size() - 1; i >= 0; i--) {
        while (!stack.empty() && Math.abs(asteroids[i]) != Math.abs(stack.top())) {
            if (Math.abs(asteroids[i]) > Math.abs(stack.top())) {
                stack.push(asteroids[i]);
                break;
            } else if (Math.abs(asteroids[i]) < Math.abs(stack.top())) {
                break;
            }
        } else {
            stack.push(asteroids[i]);
        }
    }
    std::vector<int> result;
    while (!stack.empty()) {
        result.push_back(stack.top());
        stack.pop();
    }
    return result;
}
```

#### JavaScript
```javascript
function asteroidCollision(asteroids) {
    const stack = [];
    for (let i = asteroids.length - 1; i >= 0; i--) {
        while (stack.length && Math.abs(asteroids[i]) !== Math.abs(stack[stack.length - 1])) {
            if (Math.abs(asteroids[i]) > Math.abs(stack.pop())) {
                stack.push(asteroids[i]);
                break;
            } else if (Math.abs(asteroids[i]) < Math.abs(stack[stack.length - 1])) {
                break;
            }
        } else {
            stack.push(asteroids[i]);
        }
    }
    return stack.reverse();
}
```