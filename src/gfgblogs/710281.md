---
id: "710281"
title: "Minimum increment/decrement to make array non-Increasing"
slug: "minimum-incrementdecrement-to-make-array-non-increasing--170637"
difficulty: "Medium"
companyTags: ["Amazon"]
tags: ["Arrays", "priority-queue", "Data Structures"]
---

**Minimum increment/decrement to make array non-Increasing**
=====================================================

## Summary
Given an integer array, we need to find the minimum number of increments or decrements required to make the array non-increasing. This problem is related to arrays and priority queues.

## Detailed Explanation
The approach to solve this problem is to use a priority queue to keep track of the elements in the array that are not yet non-decreasing. We start by initializing a priority queue with all elements from the input array, where each element is represented as a pair (value, index). Then we repeatedly extract the maximum element from the priority queue and update the array accordingly.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty priority queue.
2. Iterate through the input array and add each element to the priority queue along with its index.
3. While the priority queue is not empty, do the following:
    * Extract the maximum element from the priority queue. Let this element be (value, index).
    * If the value of the extracted element is greater than or equal to the value at the previous index in the array, update the array by decrementing the value.
    * Add the updated element back to the priority queue.
4. The number of increments/decrements required to make the array non-increasing is the total number of elements processed.

Time complexity: O(n log n) due to the sorting operation in each iteration of the while loop, where n is the size of the input array.
Space complexity: O(n) for storing the priority queue and the updated array.

## Optimized Solutions
### Java
```java
import java.util.PriorityQueue;
import java.util.Arrays;

public class Main {
    public static int minIncrDecr(int[] arr) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int i : arr) {
            pq.offer(i);
        }
        int count = 0;
        while (!pq.isEmpty()) {
            int max = pq.poll();
            if (!pq.isEmpty() && pq.peek() >= max) {
                pq.poll();
                count++;
            } else {
                break;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        int[] arr = {5, 3, 2, 1};
        System.out.println(minIncrDecr(arr));
    }
}
```

### Python
```python
import heapq

def min_incr_decr(arr):
    pq = []
    for i in arr:
        heapq.heappush(pq, i)
    count = 0
    while pq:
        max_val = heapq.heappop(pq)
        if pq and pq[0] >= max_val:
            heapq.heappop(pq)
            count += 1
        else:
            break
    return count

print(min_incr_decr([5, 3, 2, 1]))
```

### C++
```cpp
#include <queue>
#include <vector>

int minIncrDecr(std::vector<int>& arr) {
    std::priority_queue<int> pq;
    for (int i : arr) {
        pq.push(i);
    }
    int count = 0;
    while (!pq.empty()) {
        int max_val = pq.top();
        pq.pop();
        if (!pq.empty() && pq.top() >= max_val) {
            pq.pop();
            count++;
        } else {
            break;
        }
    }
    return count;
}

int main() {
    std::vector<int> arr = {5, 3, 2, 1};
    std::cout << minIncrDecr(arr) << std::endl;
    return 0;
}
```

### JavaScript
```javascript
function minIncrDecr(arr) {
    const pq = [];
    for (let i of arr) {
        pq.push(i);
    }
    let count = 0;
    while (pq.length > 0) {
        const max_val = Math.max(...pq);
        pq.splice(pq.indexOf(max_val), 1);
        if (pq.length > 0 && Math.max(...pq) >= max_val) {
            pq.splice(pq.indexOf(Math.max(...pq)), 1);
            count++;
        } else {
            break;
        }
    }
    return count;
}

console.log(minIncrDecr([5, 3, 2, 1]));
```