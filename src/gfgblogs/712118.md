---
id: "712118"
title: "Count Good numbers"
slug: "count-good-numbers"
difficulty: "Medium"
companyTags: []
tags: ["Mathematical", "Algorithms"]
---

Here is a detailed Markdown blog post for the "Count Good numbers" problem:

# Count Good numbers
## Summary

The "Count Good numbers" problem involves counting the number of good numbers within a given range. A good number is defined as an integer that has the same digits as the number 1, but in any order. For example, the good numbers for the input 1 are 1 and the numbers that can be formed by rearranging its digits. The goal is to write an algorithm that efficiently counts the total number of good numbers within a given range.

## Detailed Explanation

To solve this problem, we can start by generating all possible permutations of the digits in the given range. We then check if each permutation is a good number and count it accordingly. This approach has a time complexity of O(n!), where n is the number of digits in the given range.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty set to store the good numbers.
2. Generate all permutations of the digits in the given range using recursion or an iterative algorithm.
3. For each permutation, check if it is a good number by comparing its digits with those of the original number. If the permutation has the same digits as the original number, add it to the set of good numbers.
4. Count the total number of good numbers in the set and return the result.

Here's an ASCII art diagram illustrating the algorithm:
```
          +---------------+
          |  Generate    |
          |  permutations |
          +---------------+
                  |
                  |  Check if each
                  |  permutation is a
                  |  good number
                  v
+-------------------------------+
|  If it's a good number, add   |
|  it to the set of good numbers |
+-------------------------------+
```
The time complexity of this algorithm is O(n!), where n is the number of digits in the given range. The space complexity is O(n), as we need to store the permutations and good numbers.

## Optimized Solutions

Here are optimized solutions for the problem in different programming languages:

### Java
```java
import java.util.*;

public class CountGoodNumbers {
    public static int countGoodNumbers(int n) {
        Set<String> goodNumbers = new HashSet<>();
        generatePermutations(goodNumbers, String.valueOf(n));
        return goodNumbers.size();
    }

    private static void generatePermutations(Set<String> set, String str) {
        if (str.length() == 1) {
            set.add(str);
        } else {
            for (int i = 0; i < str.length(); i++) {
                String remainingStr = str.substring(0, i) + str.substring(i + 1);
                generatePermutations(set, remainingStr + str.charAt(i));
            }
        }
    }

    public static void main(String[] args) {
        int n = 1;
        System.out.println("Number of good numbers: " + countGoodNumbers(n));
    }
}
```

### Python
```python
def count_good_numbers(n):
    good_numbers = set()
    generate_permutations(good_numbers, str(n))
    return len(good_numbers)

def generate_permutations(good_numbers, str_n):
    if len(str_n) == 1:
        good_numbers.add(str_n)
    else:
        for i in range(len(str_n)):
            remaining_str = str_n[:i] + str_n[i+1:]
            generate_permutations(good_numbers, remaining_str + str_n[i])

print("Number of good numbers:", count_good_numbers(1))
```

### C++
```cpp
#include <iostream>
#include <set>
#include <string>

int countGoodNumbers(int n) {
    std::set<std::string> goodNumbers;
    generatePermutations(goodNumbers, std::to_string(n));
    return goodNumbers.size();
}

void generatePermutations(std::set<std::string>& set, const std::string& str) {
    if (str.length() == 1) {
        set.insert(str);
    } else {
        for (int i = 0; i < str.length(); i++) {
            std::string remainingStr = str.substr(0, i) + str.substr(i+1);
            generatePermutations(set, remainingStr + str[i]);
        }
    }
}

int main() {
    int n = 1;
    std::cout << "Number of good numbers: " << countGoodNumbers(n) << std::endl;
    return 0;
}
```

### JavaScript
```javascript
function countGoodNumbers(n) {
    const goodNumbers = new Set();
    generatePermutations(goodNumbers, n.toString());
    return goodNumbers.size;
}

function generatePermutations(set, str) {
    if (str.length === 1) {
        set.add(str);
    } else {
        for (let i = 0; i < str.length; i++) {
            const remainingStr = str.slice(0, i) + str.slice(i+1);
            generatePermutations(set, remainingStr + str[i]);
        }
    }
}

console.log("Number of good numbers:", countGoodNumbers(1));
```

Note that the optimized solutions are not necessarily the most efficient, but they do demonstrate a basic approach to solving the problem.