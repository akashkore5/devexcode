---
id: "713597"
title: "Fixing Two swapped nodes of a BST"
slug: "fixing-two-swapped-nodes-of-a-bst--170646"
difficulty: "Hard"
companyTags: ["Paytm", "Amazon", "Microsoft", "FactSet", "Walmart", "BankBazaar"]
tags: ["Binary Search Tree", "Data Structures"]
---

**Fixing Two swapped nodes of a BST**
=====================================

## Summary
The problem involves fixing two swapped nodes in a Binary Search Tree (BST). The goal is to restore the original order of the tree by swapping back the incorrect nodes. This problem requires understanding of binary search trees and their traversal methods.

## Detailed Explanation
To solve this problem, we can start by performing an inorder traversal of the BST to get all the node values in ascending order. Then, we compare each pair of adjacent nodes to find the swapped nodes. Once we've identified the two swapped nodes, we need to restore the original order by swapping them back.

Here's a step-by-step breakdown of the solution:

1. Perform an inorder traversal of the BST to get all node values in ascending order.
2. Compare each pair of adjacent nodes to find the swapped nodes. The swapped nodes will have the same value but different parent-child relationships than their original counterparts.
3. Once we've identified the two swapped nodes, swap them back to restore the original order.

Here's an ASCII art diagram illustrating the problem:

```
       4
     /   \
    2     6
   / \   / \
  1   3 5   7
```

In this example, the nodes with values 3 and 5 are swapped. To fix this, we would swap them back to restore the original order.

Time complexity: O(n), where n is the number of nodes in the BST.
Space complexity: O(1) as we only use a constant amount of space for our algorithm.

## Optimized Solutions

### Java
```java
public class FixSwappedNodes {
    public static void fixSwappedNodes(Node root) {
        if (root == null) return;

        List<Integer> inorder = new ArrayList<>();
        inorder(root, inorder);

        int prev = Integer.MIN_VALUE;
        for (int i = 0; i < inorder.size() - 1; i++) {
            if (inorder.get(i) > inorder.get(i + 1)) {
                // Swap nodes
                int temp = inorder.set(i, inorder.get(i + 1));
                inorder.set(i + 1, temp);
                return;
            }
        }
    }

    private static void inorder(Node node, List<Integer> inorder) {
        if (node == null) return;

        inorder(node.left, inorder);
        inorder.add(node.val);
        inorder(node.right, inorder);
    }
}
```

### Python
```python
class Node:
    def __init__(self, val):
        self.val = val

def fix_swapped_nodes(root):
    if root is None: return

    inorder = []
    _inorder(root, inorder)

    prev = float('-inf')
    for i in range(len(inorder) - 1):
        if inorder[i] > inorder[i + 1]:
            # Swap nodes
            inorder[i], inorder[i + 1] = inorder[i + 1], inorder[i]
            return
    return

def _inorder(node, inorder):
    if node is None: return

    _inorder(node.left, inorder)
    inorder.append(node.val)
    _inorder(node.right, inorder)

# Example usage:
root = Node(4)
root.left = Node(2)
root.right = Node(6)
root.left.left = Node(1)
root.left.right = Node(3)
root.right.right = Node(7)
fix_swapped_nodes(root)
```

### C++
```cpp
struct Node {
    int val;
    Node* left;
    Node* right;
};

void fixSwappedNodes(Node* root) {
    if (root == nullptr) return;

    vector<int> inorder;
    _inorder(root, inorder);

    int prev = INT_MIN;
    for (int i = 0; i < inorder.size() - 1; i++) {
        if (inorder[i] > inorder[i + 1]) {
            // Swap nodes
            swap(inorder[i], inorder[i + 1]);
            return;
        }
    }
}

void _inorder(Node* node, vector<int>& inorder) {
    if (node == nullptr) return;

    _inorder(node->left, inorder);
    inorder.push_back(node->val);
    _inorder(node->right, inorder);

}
```

### JavaScript
```javascript
class Node {
  constructor(val) {
    this.val = val;
  }
}

function fixSwappedNodes(root) {
  if (root === null) return;

  const inorder = [];
  _inorder(root, inorder);

  let prev = -Infinity;
  for (let i = 0; i < inorder.length - 1; i++) {
    if (inorder[i] > inorder[i + 1]) {
      // Swap nodes
      [inorder[i], inorder[i + 1]] = [inorder[i + 1], inorder[i]];
      return;
    }
  }
}

function _inorder(node, inorder) {
  if (node === null) return;

  _inorder(node.left, inorder);
  inorder.push(node.val);
  _inorder(node.right, inorder);

}
```

Note: These optimized solutions are provided in various programming languages and assume that the input is a binary search tree node.