---
id: "712507"
title: "Account Merge"
slug: "account-merge"
difficulty: "Hard"
companyTags: []
tags: ["Arrays", "Hash", "DFS", "Graph", "union-find", "Data Structures", "Algorithms"]
---

**Account Merge**
================

**Slug:** account-merge
**Difficulty:** Hard
**Id:** 712507
**Topic Tags:** Arrays, Hash, DFS, Graph, union-find, Data Structures, Algorithms

## Summary
The Account Merge problem involves merging similar accounts in a social network. Given a list of account pairs and their corresponding email addresses, the task is to merge these accounts into a single account if they have matching email addresses. This process should be efficient, as it's crucial for maintaining data consistency and minimizing user confusion.

## Detailed Explanation
The solution to this problem involves implementing a union-find algorithm, which is used to group similar accounts together. We will use an array to keep track of the parent node for each account and another array to store the size of each component (i.e., the number of accounts in each group).

Here's a step-by-step breakdown of the solution:

1.  Initialize two arrays: `parent` and `size`. The `parent` array will store the parent node for each account, and the `size` array will keep track of the size of each component.
2.  Iterate through the list of account pairs. For each pair, check if the email addresses match.
3.  If the email addresses match, merge the two accounts using a union operation. This involves updating the parent node for one of the accounts to point to the other account.
4.  After processing all the account pairs, iterate through the `parent` array and group the accounts based on their parent nodes.

Time complexity: O(n), where n is the number of account pairs.
Space complexity: O(n), as we need to store the parent node and size for each account.

## Optimized Solutions
Here are optimized solutions in various programming languages:

### Java
```java
import java.util.*;

class Solution {
    public List<String> accountsMerge(int[][] accounts, int[][] friends) {
        UnionFind uf = new UnionFind(accounts.length);
        Map<Integer, Integer> parent = new HashMap<>();
        Map<Integer, Integer> size = new HashMap<>();

        for (int[] friend : friends) {
            uf.union(friend[0], friend[1]);
        }

        List<String> result = new ArrayList<>();
        Map<Integer, List<String>> emailToName = new HashMap<>();

        for (int i = 0; i < accounts.length; i++) {
            parent.put(i, i);
            size.put(i, 1);
        }

        for (int[] account : accounts) {
            int id = account[0];
            String name = account[1];
            for (String email : account.subarray(2)) {
                uf.union(id, Integer.parseInt(email.split("@")[1]));
                parent.put(Integer.parseInt(email.split("@")[1]), id);
                size.put(id, size.getOrDefault(id, 0) + 1);
            }
        }

        Set<Integer> roots = new HashSet<>();
        for (int i = 0; i < accounts.length; i++) {
            int root = uf.find(i);
            if (!roots.add(root)) {
                continue;
            }
            List<String> emails = new ArrayList<>();
            for (int j = 0; j < accounts.length; j++) {
                if (uf.find(j) == root) {
                    String email = "";
                    for (String accEmail : accounts[j].subarray(2)) {
                        email += accEmail + " ";
                    }
                    emails.add(name + " " + email);
                }
            }
            result.addAll(emails);
        }

        return result;
    }
}

class UnionFind {
    Map<Integer, Integer> parent;

    public UnionFind(int n) {
        parent = new HashMap<>();
        for (int i = 0; i < n; i++) {
            parent.put(i, i);
        }
    }

    public int find(int x) {
        if (parent.get(x) != x) {
            parent.put(x, find(parent.get(x)));
        }
        return parent.get(x);
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) {
            return;
        }

        if (size.getOrDefault(rootX, 0) < size.getOrDefault(rootY, 0)) {
            parent.put(rootX, rootY);
        } else {
            parent.put(rootY, rootX);
        }
    }
}
```

### Python
```python
class Solution:
    def accountsMerge(self, accounts: List[List[str]], friends: List[List[str]]) -> List[str]:
        uf = UnionFind(len(accounts))
        parent = {i: i for i in range(len(accounts))}
        size = {i: 1 for i in range(len(accounts))}

        for friend in friends:
            uf.union(friend[0], friend[1])

        result = []
        email_to_name = {}

        for account in accounts:
            id = account[0]
            name = account[1]
            for email in account[2:]:
                uf.union(id, int(email.split('@')[1]))
                parent[int(email.split('@')[1])] = id
                size[id] += 1

        roots = set()
        for i in range(len(accounts)):
            root = uf.find(i)
            if not roots.add(root):
                continue
            emails = []
            for j in range(len(accounts)):
                if uf.find(j) == root:
                    email = ' '.join(account[2] for account in accounts[j][2:])
                    emails.append(f"{name} {email}")
            result.extend(emails)

        return result

class UnionFind:
    def __init__(self, n):
        self.parent = {i: i for i in range(n)}

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)

        if root_x == root_y:
            return

        if size.get(root_x, 0) < size.get(root_y, 0):
            self.parent[root_x] = root_y
        else:
            self.parent[root_y] = root_x
```

### C++
```cpp
class Solution {
public:
    vector<string> accountsMerge(vector<vector<string>>& accounts, vector<vector<int>>& friends) {
        UnionFind uf(account.size());
        map<int, int> parent;
        map<int, int> size;

        for (auto& friend : friends) {
            uf.union(friend[0], friend[1]);
        }

        vector<string> result;
        map<int, list<string>> emailToName;

        for (int i = 0; i < account.size(); i++) {
            parent[i] = i;
            size[i] = 1;
        }

        for (auto& account : accounts) {
            int id = account[0];
            string name = account[1];
            for (string email : account.begin() + 2, end(account)) {
                uf.union(id, stoi(email.substr(email.find('@') + 1)));
                parent[stoi(email.substr(email.find('@') + 1))] = id;
                size[id] += 1;
            }
        }

        set<int> roots;
        for (int i = 0; i < account.size(); i++) {
            int root = uf.find(i);
            if (!roots.insert(root).second) {
                continue;
            }
            list<string> emails;
            for (int j = 0; j < account.size(); j++) {
                if (uf.find(j) == root) {
                    string email = "";
                    for (auto& accEmail : accounts[j].begin() + 2, end(accounts[j])) {
                        email += accEmail + " ";
                    }
                    emails.push_back(name + " " + email);
                }
            }
            result.insert(result.end(), emails.begin(), emails.end());
        }

        return result;
    }
};

class UnionFind {
public:
    map<int, int> parent;

    UnionFind(int n) : parent() {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) {
            return;
        }

        if (size[rootX] < size[rootY]) {
            parent[rootX] = rootY;
        } else {
            parent[rootY] = rootX;
        }
    }
};
```

### Java
```java
public class Solution {
    public List<String> accountsMerge(int[][] accounts, int[][] friends) {
        UnionFind uf = new UnionFind(accounts.length);
        Map<Integer, Integer> parent = new HashMap<>();
        Map<Integer, Integer> size = new HashMap<>();

        for (int[] friend : friends) {
            uf.union(friend[0], friend[1]);
        }

        List<String> result = new ArrayList<>();
        Map<Integer, List<String>> emailToName = new HashMap<>();

        for (int i = 0; i < accounts.length; i++) {
            parent.put(i, i);
            size.put(i, 1);
        }

        for (int i = 0; i < accounts.length; i++) {
            int id = accounts[i][0];
            String name = accounts[i][1];
            for (String email : accounts[i].substring(2)) {
                uf.union(id, Integer.parseInt(email.split('@')[1]));
                parent.put(Integer.parseInt(email.split('@')[1]), id);
                size.put(id, size.getOrDefault(id, 0) + 1);
            }
        }

        Set<Integer> roots = new HashSet<>();
        for (int i = 0; i < accounts.length; i++) {
            int root = uf.find(i);
            if (!roots.add(root)) {
                continue;
            }
            List<String> emails = new ArrayList<>();
            for (int j = 0; j < accounts.length; j++) {
                if (uf.find(j) == root) {
                    String email = "";
                    for (String accEmail : Arrays.stream(accounts[j].substring(2)).toArray(String[]::new)) {
                        email += accEmail + " ";
                    }
                    emails.add(name + " " + email);
                }
            }
            result.addAll(emails);
        }

        return result;
    }
}

class UnionFind {
    Map<Integer, Integer> parent;

    public UnionFind(int n) {
        parent = new HashMap<>();
        for (int i = 0; i < n; i++) {
            parent.put(i, i);
        }
    }

    public int find(int x) {
        if (parent.get(x) != x) {
            parent.put(x, find(parent.get(x)));
        }
        return parent.get(x);
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX == rootY) {
            return;
        }

        if (size.getOrDefault(rootX, 0) < size.getOrDefault(rootY, 0)) {
            parent.put(rootX, rootY);
        } else {
            parent.put(rootY, rootX);
        }
    }
}
```

In this example, we're assuming that the email addresses are unique for each account. If there are duplicate email addresses across different accounts, you might need to handle them differently.