---
id: "701248"
title: "Level of Nodes"
slug: "level-of-nodes-1587115620"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "BFS", "Data Structures", "Algorithms"]
---

**Level of Nodes**
================

### Slug: level-of-nodes-1587115620
### Difficulty: Medium
### Id: 701248
### Topic Tags: Graph, BFS, Data Structures, Algorithms
### Company Tags: None

## Summary
Given a graph and an integer k, the task is to find all nodes at level k from the root node. A node's level is its distance from the root node in a breadth-first search (BFS) traversal of the graph.

## Detailed Explanation
To solve this problem, we can use BFS traversal algorithm on the given graph. We start by visiting the root node and then keep track of nodes at each level. Once we visit all nodes at a particular level, we move to the next level until we reach the kth level. For each node, we also maintain its parent node to ensure that we don't revisit any node more than once.

Here's a step-by-step breakdown of the solution:

1.  Initialize an empty queue and add the root node to it.
2.  Set the current level to 0 (since the root node is at level 0).
3.  While the queue is not empty:
    *   Dequeue the front node from the queue.
    *   If the dequeued node's level is equal to k, add it to the result set.
    *   Enqueue all the children of the dequeued node that have not been visited yet.
    *   Increment the current level by 1 for each child node.
4.  Return the result set.

Here's an example diagram:

```
       0 (root)
      /     \
    1        2
   / \      / \
  3   4    5   6

Level 0: 0
Level 1: 1, 2
Level 2: 3, 4, 5, 6
```

The time complexity of this solution is O(V + E), where V is the number of nodes and E is the number of edges in the graph. The space complexity is O(V) for storing the visited nodes and their levels.

## Optimized Solutions

### Java
```java
import java.util.*;

class Node {
    int val;
    List<Node> children;

    public Node(int val) {
        this.val = val;
        this.children = new ArrayList<>();
    }
}

public class LevelOfNodes {
    public static List<Integer> levelOrder(Node root, int k) {
        if (root == null) return new ArrayList<>();

        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        int currentLevel = 0;

        List<Integer> result = new ArrayList<>();

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.val == k) {
                result.add(node.val);
            }
            if (currentLevel < k) {
                for (Node child : node.children) {
                    queue.offer(child);
                }
                currentLevel++;
            }
        }

        return result;
    }
}
```

### Python
```python
from collections import deque

class Node:
    def __init__(self, val):
        self.val = val
        self.children = []

def level_order(root, k):
    if root is None: return []
    
    queue = deque([root])
    current_level = 0
    
    result = []
    
    while queue:
        node = queue.popleft()
        if node.val == k:
            result.append(node.val)
        if current_level < k:
            for child in node.children:
                queue.append(child)
            current_level += 1
        else:
            break
    
    return result
```

### C++
```cpp
#include <queue>
#include <vector>

struct Node {
    int val;
    std::vector<Node*> children;

    Node(int val) : val(val), children() {}
};

std::vector<int> levelOrder(Node* root, int k) {
    if (root == nullptr) return {};

    std::queue<Node*> queue;
    queue.push(root);
    int currentLevel = 0;

    std::vector<int> result;

    while (!queue.empty()) {
        Node* node = queue.front();
        queue.pop();
        if (node->val == k) {
            result.push_back(node->val);
        }
        if (currentLevel < k) {
            for (Node* child : node->children) {
                queue.push(child);
            }
            currentLevel++;
        } else {
            break;
        }
    }

    return result;
}
```

### JavaScript
```javascript
class Node {
  constructor(val, children = []) {
    this.val = val;
    this.children = children;
  }
}

function levelOrder(root, k) {
  if (root === null) return [];

  const queue = [root];
  let currentLevel = 0;

  const result = [];

  while (queue.length > 0) {
    const node = queue.shift();
    if (node.val === k) {
      result.push(node.val);
    }
    if (currentLevel < k) {
      for (const child of node.children) {
        queue.push(child);
      }
      currentLevel++;
    } else {
      break;
    }
  }

  return result;
}
```