---
id: "703325"
title: "Subset with no pair sum divisible by K"
slug: "subset-with-no-pair-sum-divisible-by-k1105"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Modular Arithmetic", "Data Structures", "Algorithms"]
---

**Subset with no pair sum divisible by K**
=====================================

### Summary
Given a set of integers `arr`, find all subsets (of varying sizes) where the sum of each subset is not divisible by a given integer `K`. This problem involves arrays, modular arithmetic, and algorithms.

### Detailed Explanation
To solve this problem, we can use a backtracking approach. We start by creating an empty subset and iteratively add elements from the array to it. For each element, we check if the sum of the current subset is divisible by `K`. If it is, we backtrack and try another subset without including the current element. If not, we recursively add more elements to the subset until we have a subset that meets our condition or we've exhausted all possible subsets.

Here's a step-by-step breakdown:

1. Initialize an empty subset `subset` and a variable `sum` to store the sum of the subset.
2. Iterate through each element `num` in the array `arr`.
3. For each element, check if adding it to the current subset would make the sum divisible by `K`. If so, backtrack and try another subset without including the current element.
4. If not, recursively add more elements to the subset until we have a subset that meets our condition or we've exhausted all possible subsets.
5. Once we've found a subset that meets our condition, add it to our list of results.

Time complexity: O(2^n \* n), where `n` is the size of the array and 2^n is the number of possible subsets.
Space complexity: O(n), for storing the current subset and recursive function calls.

### Optimized Solutions

#### Java
```java
public class Solution {
    public List<List<Integer>> findSubsets(int[] arr, int K) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(arr, new ArrayList<>(), 0, 0, result);
        return result;
    }

    private void backtrack(int[] arr, List<Integer> subset, int start, int sum, List<List<Integer>> result) {
        if (sum % K == 0) return; // backtracking
        for (int i = start; i < arr.length; i++) {
            subset.add(arr[i]);
            sum += arr[i];
            backtrack(arr, subset, i + 1, sum, result);
            sum -= arr[i]; // backtrack
            subset.remove(subset.size() - 1);
        }
    }
}
```

#### Python
```python
def find_subsets(arr, K):
    result = []
    backtrack(arr, [], 0, 0, result)
    return result

def backtrack(arr, subset, start, sum, result):
    if sum % K == 0: return  # backtracking
    for i in range(start, len(arr)):
        subset.append(arr[i])
        global_sum = sum + arr[i]
        backtrack(arr, subset, i + 1, global_sum, result)
        global_sum -= arr[i]  # backtrack
        subset.pop()
```

#### C++
```cpp
class Solution {
public:
    vector<vector<int>> findSubsets(vector<int>& arr, int K) {
        vector<vector<int>> result;
        backtrack(arr, {}, 0, 0, result);
        return result;
    }

    void backtrack(vector<int>& arr, vector<int> subset, int start, int sum, vector<vector<int>>& result) {
        if (sum % K == 0) return; // backtracking
        for (int i = start; i < arr.size(); i++) {
            subset.push_back(arr[i]);
            sum += arr[i];
            backtrack(arr, subset, i + 1, sum, result);
            sum -= arr[i]; // backtrack
            subset.pop_back();
        }
    }
};
```

#### JavaScript
```javascript
class Solution {
  findSubsets(arr, K) {
    const result = [];
    this.backtrack(arr, [], 0, 0, result);
    return result;
  }

  backtrack(arr, subset, start, sum, result) {
    if (sum % K === 0) return; // backtracking
    for (let i = start; i < arr.length; i++) {
      subset.push(arr[i]);
      const globalSum = sum + arr[i];
      this.backtrack(arr, subset, i + 1, globalSum, result);
      globalSum -= arr[i]; // backtrack
      subset.pop();
    }
  }
}
```