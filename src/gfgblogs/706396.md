---
id: "706396"
title: "Reverse a sublist of a linked list"
slug: "reverse-a-sublist-of-a-linked-list"
difficulty: "Hard"
companyTags: ["Microsoft"]
tags: ["Linked List", "Data Structures"]
---

# Reverse a Sublist of a Linked List
## Slug: reverse-a-sublist-of-a-linked-list
## Difficulty: Hard
## Topic Tags: Linked List, Data Structures
## Company Tags: Microsoft

### Summary
Given a singly linked list and an integer k, reverse the kth sublist from the beginning of the linked list. For example, if the input list is 1 -> 2 -> 3 -> 4 -> 5 and k = 2, the output should be 1 -> 2 -> 5 -> 4 -> 3.

### Detailed Explanation
To solve this problem, we can approach it in two steps: first, find the start of the sublist to be reversed, then reverse the sublist. To find the start of the sublist, we need to traverse k nodes from the beginning of the linked list. Once we reach the start of the sublist, we can reverse the sublist using a standard linked list reversal algorithm.

Here's a step-by-step breakdown of the solution:

1. Initialize three pointers: `prev`, `curr`, and `next`. Set `prev` to `NULL`, `curr` to the beginning of the linked list, and `next` to `NULL`.
2. Traverse k nodes from the beginning of the linked list. Update `curr` and `next` accordingly.
3. Once we reach the start of the sublist, update `prev` to point to the node before the current node (`curr`). Set `next` to `curr -> next`, effectively moving one step forward in the original list.
4. Reverse the sublist by updating `prev -> next` and setting `curr` to `next`.
5. Continue reversing the sublist until we reach the end of the sublist (i.e., when `curr` points to a node that is k nodes ahead of the start of the sublist).
6. Update the original linked list by moving the reversed sublist to its original position.

Time complexity: O(n), where n is the length of the linked list.
Space complexity: O(1), as we only use a constant amount of space to store the pointers.

### Optimized Solutions

#### Java
```java
public Node reverseSublist(Node head, int k) {
    if (head == null || k <= 0) {
        return head;
    }

    Node prev = null;
    Node curr = head;
    for (int i = 0; i < k - 1; i++) {
        prev = curr;
        curr = curr.next;
    }

    Node start = curr;
    Node end = start;
    while (end.next != null) {
        end = end.next;
    }
    end = end.next;

    Node next = start.next;
    while (next != end) {
        Node temp = next.next;
        next.next = start;
        start = next;
        next = temp;
    }

    if (prev != null) {
        prev.next = end;
    } else {
        head = end;
    }
    return head;
}
```

#### Python
```python
def reverse_sublist(head, k):
    if not head or k <= 0:
        return head

    prev = None
    curr = head
    for _ in range(k - 1):
        prev = curr
        curr = curr.next

    start = curr
    end = start
    while end.next:
        end = end.next
    end = end.next

    next_node = start.next
    while next_node != end:
        temp = next_node.next
        next_node.next = start
        start = next_node
        next_node = temp

    if prev:
        prev.next = end
    else:
        head = end
    return head
```

#### C++
```cpp
Node* reverseSublist(Node* head, int k) {
    if (head == NULL || k <= 0) {
        return head;
    }

    Node* prev = NULL;
    Node* curr = head;
    for (int i = 0; i < k - 1; i++) {
        prev = curr;
        curr = curr->next;
    }

    Node* start = curr;
    Node* end = start;
    while (end->next != NULL) {
        end = end->next;
    }
    end = end->next;

    Node* next = start->next;
    while (next != end) {
        Node* temp = next->next;
        next->next = start;
        start = next;
        next = temp;
    }

    if (prev != NULL) {
        prev->next = end;
    } else {
        head = end;
    }
    return head;
}
```

#### JavaScript
```javascript
function reverseSublist(head, k) {
  if (!head || k <= 0) {
    return head;
  }

  let prev = null;
  let curr = head;
  for (let i = 0; i < k - 1; i++) {
    prev = curr;
    curr = curr.next;
  }

  let start = curr;
  let end = start;
  while (end.next) {
    end = end.next;
  }
  end = end.next;

  let nextNode = start.next;
  while (nextNode !== end) {
    let temp = nextNode.next;
    nextNode.next = start;
    start = nextNode;
    nextNode = temp;
  }

  if (prev) {
    prev.next = end;
  } else {
    head = end;
  }
  return head;
}
```