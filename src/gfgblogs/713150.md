---
id: "713150"
title: "Find the first node of loop in linked list"
slug: "find-the-first-node-of-loop-in-linked-list--170645"
difficulty: "Easy"
companyTags: []
tags: ["Linked List", "two-pointer-algorithm", "Data Structures", "Algorithms"]
---

**Find the First Node of Loop in Linked List**
==================================================

## Summary
Given a linked list with a loop, find the first node of the loop. This problem involves understanding the concept of loops in linked lists and implementing an efficient algorithm to detect the start of the loop.

## Detailed Explanation
The given linked list has a cycle or a loop. A loop occurs when there is a reference from some node back to previous nodes, thus forming a cycle. We can solve this problem using Floyd's Cycle-Finding Algorithm (also known as the "tortoise and the hare" algorithm). This algorithm works by having two pointers, one that increments one step at a time and another that increments two steps at a time. If there is no loop, these two pointers will never meet. But if there is a loop, they will eventually meet.

Here's how we can implement this:

1. Initialize the two pointers, `slow` and `fast`, to the head of the linked list.
2. Move the `slow` pointer one step at a time and the `fast` pointer two steps at a time.
3. If there is no loop, these two pointers will never meet. But if there is a loop, they will eventually meet at some node inside the loop.
4. Once we detect the meeting point, reset the `slow` pointer to the head of the linked list and move both pointers one step at a time. They will meet again at the start of the loop.

The steps are visualized below:

    A -> B -> C -> D -> E -> F
    |             |
    V             V
  S (slow) -> A -> B -> C -> D -> ...
              T (fast)

Time Complexity: O(n)
Space Complexity: O(1)

## Optimized Solutions

### Java
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) return null;
        
        ListNode slow = head, fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) break;
        }
        if (fast == null || fast.next == null) return null;
        
        slow = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```

### Python
```python
class Solution:
    def detectCycle(self, head):
        if not head or not head.next: return None
        
        slow = head; fast = head
        while fast and fast.next:
            slow = slow.next; fast = fast.next.next
            if slow == fast: break
        if not fast or not fast.next: return None
        
        slow = head; 
        while slow != fast:
            slow = slow.next; fast = fast.next
        return slow
```

### C++
```cpp
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        if (head == nullptr || head->next == nullptr) return nullptr;
        
        ListNode* slow = head, *fast = head;
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) break;
        }
        if (fast == nullptr || fast->next == nullptr) return nullptr;
        
        slow = head;
        while (slow != fast) {
            slow = slow->next; 
            fast = fast->next;
        }
        return slow;
    }
};
```

### JavaScript
```javascript
class Solution {
  detectCycle(head) {
    if (!head || !head.next) return null;
    
    let slow = head, fast = head;
    while (fast && fast.next) {
      slow = slow.next; 
      fast = fast.next.next;
      if (slow === fast) break;
    }
    if (!fast || !fast.next) return null;
    
    slow = head;
    while (slow !== fast) {
      slow = slow.next; 
      fast = fast.next;
    }
    return slow;
  }
}
```

Note: The code provided assumes that the input linked list is a singly linked list, and that the cycle in the linked list is not due to any other nodes pointing back to previous nodes.