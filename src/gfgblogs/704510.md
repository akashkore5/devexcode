---
id: "704510"
title: "Subset with sum divisible by k"
slug: "subset-with-sum-divisible-by-m2546"
difficulty: "Medium"
companyTags: []
tags: ["Dynamic Programming", "Algorithms", "Arrays", "Data Structures"]
---

**Subset with sum divisible by k**
================================

### Slug: subset-with-sum-divisible-by-m2546
### Difficulty: Medium
### Id: 704510
### Topic Tags: Dynamic Programming, Algorithms, Arrays, Data Structures
### Company Tags: None

## Summary
The problem is to find all subsets of a given array whose sum is divisible by k. This problem involves dynamic programming and arrays.

## Detailed Explanation
To solve this problem, we can use dynamic programming to generate all possible subsets of the input array. We can then iterate through each subset and check if its sum is divisible by k. If it is, we add it to our result set.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty set `result` to store the subsets whose sum is divisible by k.
2. Iterate through each element `i` in the input array.
3. For each `i`, generate all possible subsets that include `i`. You can do this by iterating through each previous subset and adding `i` to it.
4. For each subset, calculate its sum using a loop or recursive function.
5. Check if the sum is divisible by k. If it is, add the subset to the `result` set.
6. Return the `result` set.

Here's an ASCII art diagram illustrating the dynamic programming approach:
```
       +---------------+
       |  Input Array  |
       +---------------+
                  |
                  |  Generate subsets
                  v
       +---------------+
       |  Subsets with i  |
       +---------------+
                  |
                  |  Calculate sum
                  |  Check if divisible by k
                  v
       +---------------+
       |  Result Set     |
       +---------------+
```
Time complexity: O(n * 2^n), where n is the length of the input array. This is because we generate all possible subsets, and there are 2^n subsets in total.
Space complexity: O(n), as we need to store the result set.

## Optimized Solutions

### Java
```java
import java.util.*;

public class SubsetSumDivisible {
    public List<List<Integer>> findSubsets(int[] arr, int k) {
        Set<List<Integer>> result = new HashSet<>();
        for (int i : arr) {
            Set<List<Integer>> subsetsWithI = new HashSet<>();
            for (List<Integer> subset : result) {
                subsetsWithI.add(new ArrayList<>(subset) {{
                    add(i);
                }});
            }
            for (List<Integer> subset : subsetsWithI) {
                int sum = 0;
                for (int num : subset) {
                    sum += num;
                }
                if (sum % k == 0) {
                    result.add(new ArrayList<>(subset));
                }
            }
        }
        return new ArrayList<>(result);
    }
}
```

### Python
```python
def find_subsets(arr, k):
    result = set()
    for i in arr:
        subsets_with_i = set()
        for subset in result:
            subsets_with_i.add(list(subset) + [i])
        for subset in subsets_with_i:
            sum_val = sum(subset)
            if sum_val % k == 0:
                result.add(tuple(sorted(subset)))
    return list(result)

# Example usage
arr = [1, 2, 3, 4]
k = 3
print(find_subsets(arr, k))
```

### C++
```cpp
#include <vector>
#include <unordered_set>

std::vector<std::vector<int>> findSubsets(int* arr, int n, int k) {
    std::unordered_set<std::vector<int>> result;
    for (int i = 0; i < n; i++) {
        std::unordered_set<std::vector<int>> subsetsWithI;
        for (const auto& subset : result) {
            subsetsWithI.insert(subset);
            subsetsWithI.insert(subset.begin(), subset.end());
            subsetsWithI.insert({i});
        }
        for (const auto& subset : subsetsWithI) {
            int sum = 0;
            for (int num : subset) {
                sum += num;
            }
            if (sum % k == 0) {
                result.insert(subset);
            }
        }
    }
    return std::vector<std::vector<int>>(result.begin(), result.end());
}

// Example usage
int main() {
    int arr[] = {1, 2, 3, 4};
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 3;
    std::cout << findSubsets(arr, n, k) << std::endl;
    return 0;
}
```

### JavaScript
```javascript
function findSubsets(arr, k) {
    let result = new Set();
    for (let i of arr) {
        let subsetsWithI = new Set();
        for (let subset of result) {
            subsetsWithI.add(new Set([...subset].concat([i])));
        }
        for (let subset of subsetsWithI) {
            let sum = 0;
            for (let num of [...subset]) {
                sum += num;
            }
            if (sum % k === 0) {
                result.add(new Set([...subset]));
            }
        }
    }
    return Array.from(result.values());
}

// Example usage
let arr = [1, 2, 3, 4];
let k = 3;
console.log(findSubsets(arr, k));
```

Note: The above solutions assume that the input array is non-empty and `k` is a positive integer.