---
id: "715408"
title: "Ticket Counter"
slug: "ticket-counter-2731"
difficulty: "Easy"
companyTags: []
tags: ["Greedy", "Queue"]
---

**Ticket Counter**
==================

**Slug:** ticket-counter-2731
**Difficulty:** Easy
**Id:** 715408
**Topic Tags:** Greedy, Queue
**Company Tags:** None


## Summary

The Ticket Counter problem involves managing a queue of customers at a ticket counter. The goal is to minimize the average waiting time by assigning tickets efficiently. This problem requires a greedy approach and can be solved using a queue data structure.


## Detailed Explanation

To solve this problem, we need to understand how the ticket counter works. Customers arrive at the counter in an order, and each customer needs a unique ticket before they can proceed. The goal is to minimize the average waiting time by assigning tickets efficiently.

Here's the algorithmic approach:

1.  Create an empty queue to store customers.
2.  Assign a ticket number to each arriving customer based on their position in the queue (i.e., the first customer gets ticket number 1, the second customer gets ticket number 2, and so on).
3.  As more customers arrive, keep assigning tickets efficiently without considering any additional information.

Step-by-step breakdown:

    -   Initialize an empty queue to store customers.
    -   Assign a unique ticket number to each arriving customer based on their position in the queue.
    -   Keep track of the total waiting time and the average waiting time as more customers arrive.

Time complexity: O(n), where n is the number of customers. We iterate through all the customers once, performing constant-time operations for each customer.

Space complexity: O(1), as we only need a fixed amount of space to store the queue and other variables.


## Optimized Solutions

### Java
```
java
import java.util.*;

public class TicketCounter {
    public static int minAverageWaitingTime(int n) {
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            queue.offer(i);
        }
        int totalWaitingTime = 0;
        while (!queue.isEmpty()) {
            totalWaitingTime += queue.poll();
        }
        return totalWaitingTime / n;
    }
}
```

### Python
```
python
class TicketCounter:
    def min_average_waiting_time(self, n):
        queue = []
        for i in range(1, n+1):
            queue.append(i)
        total_waiting_time = 0
        while queue:
            total_waiting_time += queue.pop(0)
        return total_waiting_time // n
```

### C++
```
cpp
#include <queue>
#include <iostream>

class TicketCounter {
public:
    int minAverageWaitingTime(int n) {
        std::queue<int> queue;
        for (int i = 1; i <= n; i++) {
            queue.push(i);
        }
        int totalWaitingTime = 0;
        while (!queue.empty()) {
            totalWaitingTime += queue.front();
            queue.pop();
        }
        return totalWaitingTime / n;
    }
};
```

### JavaScript
```
javascript
class TicketCounter {
  minAverageWaitingTime(n) {
    const queue = [];
    for (let i = 1; i <= n; i++) {
      queue.push(i);
    }
    let totalWaitingTime = 0;
    while (queue.length > 0) {
      totalWaitingTime += queue.shift();
    }
    return totalWaitingTime / n;
  }
}
```

Remember, these optimized solutions are just one way to solve the problem. There might be other approaches that also work efficiently.