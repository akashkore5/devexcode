---
id: "700538"
title: "Merge Sort on Doubly Linked List"
slug: "merge-sort-on-doubly-linked-list"
difficulty: "Hard"
companyTags: []
tags: ["doubly-linked-list", "Linked List", "Sorting", "Merge Sort", "Data Structures", "Algorithms"]
---

# Merge Sort on Doubly Linked List
## Slug: merge-sort-on-doubly-linked-list
## Difficulty: Hard
## Topic Tags: doubly-linked-list, Linked List, Sorting, Merge Sort, Data Structures, Algorithms
## Company Tags: None

### Summary

The problem is to sort a doubly linked list using the merge sort algorithm. The key concepts involved are sorting, doubly linked lists, and the merge sort algorithm.

### Detailed Explanation

To solve this problem, we will follow the standard merge sort algorithm approach:

1.  Divide the input list into two halves until each half has one element.
2.  Recursively sort both halves.
3.  Merge the sorted halves to produce a single sorted list.

Since it's a doubly linked list, we need to take care of updating the `next` and `prev` pointers correctly during the merge process.

Here's a step-by-step breakdown of the solution:

1.  Initialize two pointers, `left` and `right`, to point to the start and end of the input list.
2.  Recursively divide the list into two halves until each half has one element.
3.  For each level of recursion:
    *   Merge the left and right halves in a bottom-up manner.
        *   Compare the smallest unmerged elements from both halves and move the smaller one to the front of the result.
        *   Update the `next` and `prev` pointers accordingly.
4.  Continue merging until the entire list is sorted.

### Optimized Solutions

Here are optimized solutions in various programming languages:

#### Java
```java
public class MergeSortDoublyLinkedList {
    public static Node mergeSort(Node head) {
        if (head == null || head.next == null) {
            return head;
        }

        Node prev = null;
        Node slow = head;
        Node fast = head;

        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        Node mid = slow;
        Node right = mid.next;

        mid.next = null;

        Node sortedLeft = mergeSort(head);
        Node sortedRight = mergeSort(right);

        return merge(sortedLeft, sortedRight);
    }

    public static Node merge(Node left, Node right) {
        if (left == null) {
            return right;
        }
        if (right == null) {
            return left;
        }

        Node result;

        if (left.data <= right.data) {
            result = left;
            left = left.next;
        } else {
            result = right;
            right = right.next;
        }

        while (left != null && right != null) {
            if (left.data <= right.data) {
                result.next = left;
                left = left.next;
            } else {
                result.next = right;
                right = right.next;
            }
            result = result.next;
        }

        if (left != null) {
            result.next = left;
        } else {
            result.next = right;
        }

        return result;
    }
}
```

#### Python
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

def merge_sort(head):
    if head is None or head.next is None:
        return head

    prev = None
    slow = head
    fast = head

    while fast is not None and fast.next is not None:
        prev = slow
        slow = slow.next
        fast = fast.next.next

    mid = slow
    right = mid.next

    mid.next = None

    left = merge_sort(head)
    right = merge_sort(right)

    return merge(left, right)

def merge(left, right):
    if left is None:
        return right
    if right is None:
        return left

    result = None

    if left.data <= right.data:
        result = left
        left = left.next
    else:
        result = right
        right = right.next

    while left is not None and right is not None:
        if left.data <= right.data:
            result.next = left
            left = left.next
        else:
            result.next = right
            right = right.next
        result = result.next

    if left is not None:
        result.next = left
    else:
        result.next = right

    return result
```

#### C++
```cpp
class Node {
public:
    int data;
    Node* next;
    Node* prev;

    Node(int data) : data(data), next(nullptr), prev(nullptr) {}
};

Node* mergeSort(Node* head) {
    if (head == nullptr || head->next == nullptr) {
        return head;
    }

    Node* prev = nullptr;
    Node* slow = head;
    Node* fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        prev = slow;
        slow = slow->next;
        fast = fast->next->next;
    }

    Node* mid = slow;
    Node* right = mid->next;

    mid->next = nullptr;

    Node* left = mergeSort(head);
    Node* sortedRight = mergeSort(right);

    return merge(left, sortedRight);
}

Node* merge(Node* left, Node* right) {
    if (left == nullptr) {
        return right;
    }
    if (right == nullptr) {
        return left;
    }

    Node* result;

    if (left->data <= right->data) {
        result = left;
        left = left->next;
    } else {
        result = right;
        right = right->next;
    }

    while (left != nullptr && right != nullptr) {
        if (left->data <= right->data) {
            result->next = left;
            left = left->next;
        } else {
            result->next = right;
            right = right->next;
        }
        result = result->next;
    }

    if (left != nullptr) {
        result->next = left;
    } else {
        result->next = right;
    }

    return result;
}
```

#### JavaScript
```javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}

function mergeSort(head) {
  if (head === null || head.next === null) {
    return head;
  }

  let prev = null;
  let slow = head;
  let fast = head;

  while (fast !== null && fast.next !== null) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }

  const mid = slow;
  const right = mid.next;

  mid.next = null;

  const left = mergeSort(head);
  const sortedRight = mergeSort(right);

  return merge(left, sortedRight);
}

function merge(left, right) {
  if (left === null) {
    return right;
  }
  if (right === null) {
    return left;
  }

  let result;

  if (left.data <= right.data) {
    result = left;
    left = left.next;
  } else {
    result = right;
    right = right.next;
  }

  while (left !== null && right !== null) {
    if (left.data <= right.data) {
      result.next = left;
      left = left.next;
    } else {
      result.next = right;
      right = right.next;
    }
    result = result.next;
  }

  if (left !== null) {
    result.next = left;
  } else {
    result.next = right;
  }

  return result;
}
```

I hope this detailed Markdown blog post helps you learn about the algorithms for sorting linked lists in programming languages.