---
id: "703287"
title: "Possible groups"
slug: "possible-groups2013"
difficulty: "Medium"
companyTags: ["Amazon"]
tags: ["Arrays", "Data Structures", "Algorithms"]
---

**Possible Groups**
==================

**Slug**: possible-groups2013
**Difficulty**: Medium
**Id**: 703287
**Topic Tags**: Arrays, Data Structures, Algorithms
**Company Tags**: Amazon

## Summary
The problem is to find all possible groups of people who can attend a meeting based on the given constraints. The input consists of an array of integers representing the availability of different individuals for the meeting at specific times. The task is to identify all possible subsets of this array that add up to a target sum.

Key concepts involved include arrays, data structures, and algorithms, with a focus on solving a combinatorial problem efficiently.

## Detailed Explanation
The approach to solve this problem involves using a combination of bitwise operations and recursion. We start by initializing an empty set `result` to store the possible groups. Then, we define a recursive function `findGroups` that takes three parameters: the current sum `sum`, the target sum `targetSum`, and the index `index` in the array.

The function works as follows:
1. If the current sum is equal to the target sum, add the current group to the result set.
2. If the current sum exceeds the target sum or if we have processed all elements in the array, return without adding any groups to the result.
3. Otherwise, consider two cases: including and excluding the `index`th element from the current group.

For each case, recursively call `findGroups` with the updated sum and index. Finally, add the new groups found to the result set.

Time complexity analysis:
The time complexity of this algorithm is O(2^n), where n is the size of the input array. This is because we are exploring all possible combinations of elements in the array.

Space complexity analysis:
The space complexity is O(n) for storing the recursive call stack and the result set.

## Optimized Solutions

### Java
```java
import java.util.*;

public class PossibleGroups {
    public List<List<Integer>> findGroups(int[] availability, int targetSum) {
        List<List<Integer>> result = new ArrayList<>();
        findGroups(0, 0, availability, targetSum, result);
        return result;
    }

    private void findGroups(int sum, int index, int[] availability, int targetSum, List<List<Integer>> result) {
        if (sum == targetSum) {
            result.add(Arrays.asList(availability).subList(index, availability.length));
        } else if (sum > targetSum || index >= availability.length) {
            return;
        } else {
            findGroups(sum + availability[index], index + 1, availability, targetSum, result);
            findGroups(sum, index + 1, availability, targetSum, result);
        }
    }
}
```

### Python
```python
class PossibleGroups:
    def find_groups(self, availability, target_sum):
        result = []
        self.find_groups(0, 0, availability, target_sum, result)
        return result

    def find_groups(self, sum, index, availability, target_sum, result):
        if sum == target_sum:
            result.append(availability[index:])
        elif sum > target_sum or index >= len(availability):
            return
        else:
            self.find_groups(sum + availability[index], index + 1, availability, target_sum, result)
            self.find_groups(sum, index + 1, availability, target_sum, result)
```

### C++
```cpp
#include <vector>
#include <algorithm>

class PossibleGroups {
public:
    std::vector<std::vector<int>> findGroups(int* availability, int size, int targetSum) {
        std::vector<std::vector<int>> result;
        findGroups(0, 0, availability, size, targetSum, result);
        return result;
    }

private:
    void findGroups(int sum, int index, int* availability, int size, int targetSum, std::vector<std::vector<int>>& result) {
        if (sum == targetSum) {
            result.push_back(std::vector<int>(availability + index, availability + size));
        } else if (sum > targetSum || index >= size) {
            return;
        } else {
            findGroups(sum + availability[index], index + 1, availability, size, targetSum, result);
            findGroups(sum, index + 1, availability, size, targetSum, result);
        }
    }
};
```

### JavaScript
```javascript
class PossibleGroups {
    findGroups(availability, targetSum) {
        const result = [];
        this.findGroups(0, 0, availability, targetSum, result);
        return result;
    }

    findGroups(sum, index, availability, targetSum, result) {
        if (sum === targetSum) {
            result.push(availability.slice(index));
        } else if (sum > targetSum || index >= availability.length) {
            return;
        } else {
            this.findGroups(sum + availability[index], index + 1, availability, targetSum, result);
            this.findGroups(sum, index + 1, availability, targetSum, result);
        }
    }
}
```