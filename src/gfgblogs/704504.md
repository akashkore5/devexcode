---
id: "704504"
title: "Ticket sellers"
slug: "ticket-sellers3241"
difficulty: "Easy"
companyTags: ["BankBazaar", "Linkedin"]
tags: ["Arrays", "Data Structures"]
---

# Ticket Sellers
## Slug: ticket-sellers3241
## Difficulty: Easy
## Id: 704504
## Topic Tags: Arrays, Data Structures
## Company Tags: BankBazaar, Linkedin

### Summary
The Ticket Sellers problem involves a set of n ticket sellers, each with a unique price for their tickets. The goal is to find the minimum cost required to buy all the tickets from these sellers such that no two adjacent ticket sellers are selling at different prices. This problem can be approached using dynamic programming and arrays.

### Detailed Explanation
The approach to this problem involves creating an array `dp` of size n, where dp[i] represents the minimum cost required to buy tickets from the first i+1 ticket sellers. We initialize the base case as `dp[0] = 0`, since buying a single ticket costs nothing.

We then iterate through the array, considering each pair of adjacent ticket sellers. For each pair, we have two options: either buy the ticket at the current price and continue with the next seller's price, or skip this ticket and consider the previous ticket's price instead. We choose the option that results in a minimum cost.

The recurrence relation for this problem is `dp[i] = min(dp[i-1], prices[i-1] + dp[i-2])`, where `prices` is an array of ticket prices. This relation captures the idea that we can either buy the current ticket and continue with the next one, or skip it and consider the previous one instead.

Here's a step-by-step breakdown of the solution:
```
dp[0] = 0
for i in range(1, n):
    dp[i] = min(dp[i-1], prices[i-1] + dp[i-2])
return dp[n-1]
```

The time complexity for this problem is O(n), since we need to iterate through the array once. The space complexity is also O(n) due to the dynamic programming array.

### Optimized Solutions

#### Java
```java
public class TicketSellers {
    public static int minCost(int[] prices) {
        int n = prices.length;
        int[] dp = new int[n+1];
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            dp[i] = Math.min(dp[i-1], prices[i-1] + (i > 1 ? dp[i-2] : 0));
        }
        return dp[n];
    }
}
```

#### Python
```python
def min_cost(prices):
    n = len(prices)
    dp = [0] * (n+1)
    dp[0] = 0
    for i in range(1, n+1):
        dp[i] = min(dp[i-1], prices[i-1] + (i > 1 and dp[i-2] or 0))
    return dp[n]
```

#### C++
```cpp
#include <vector>
using namespace std;

int minCost(vector<int>& prices) {
    int n = prices.size();
    vector<int> dp(n+1);
    dp[0] = 0;
    for (int i = 1; i <= n; i++) {
        dp[i] = min(dp[i-1], prices[i-1] + (i > 1 ? dp[i-2] : 0));
    }
    return dp[n];
}
```

#### JavaScript
```javascript
function minCost(prices) {
    let n = prices.length;
    let dp = new Array(n+1).fill(0);
    dp[0] = 0;
    for (let i = 1; i <= n; i++) {
        dp[i] = Math.min(dp[i-1], prices[i-1] + (i > 1 ? dp[i-2] : 0));
    }
    return dp[n];
}
```