---
id: "700616"
title: "Maximum Node Level"
slug: "maximum-node-level"
difficulty: "Easy"
companyTags: ["VMWare", "Amazon"]
tags: ["Tree", "Data Structures"]
---

# Maximum Node Level
## Slug: maximum-node-level
## Difficulty: Easy
## Id: 700616
## Topic Tags: Tree, Data Structures
## Company Tags: VMWare, Amazon

### Summary
Given a binary tree, find the maximum node level in the tree. A node's level is defined as its distance from the root node. This problem involves traversing a tree and keeping track of the maximum level encountered so far.

### Detailed Explanation
To solve this problem, we can use a simple recursive function that calculates the maximum level for each node. We start by defining a helper function `maxLevel` that takes the root node as an argument. This function returns the maximum level found in the subtree rooted at the given node.

Here's the step-by-step breakdown of the solution:

1.  Initialize the maximum level to 0.
2.  If the current node is null, return the maximum level (which remains 0).
3.  Calculate the current level by adding 1 to the depth of the current node from the root.
4.  Update the maximum level if the current level is greater than the previously found maximum level.
5.  Recursively call `maxLevel` for each child node and update the maximum level accordingly.

The time complexity of this solution is O(n), where n is the number of nodes in the tree, since we visit each node once. The space complexity is O(h), where h is the height of the tree, due to the recursive call stack.

### Optimized Solutions

#### Java
```java
class Node {
    int val;
    Node left, right;

    public Node(int val) {
        this.val = val;
        left = right = null;
    }
}

public class Main {
    public static int maxLevel(Node root) {
        if (root == null) return 0;

        int maxLevel = 0;
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            maxLevel++;

            for (int i = 0; i < levelSize; i++) {
                Node node = queue.poll();

                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
        }

        return maxLevel;
    }

    public static void main(String[] args) {
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);

        System.out.println(maxLevel(root));  // Output: 3
    }
}
```

#### Python
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def max_level(node):
    if node is None:
        return 0

    queue = [node]
    level = 1
    max_level = 0

    while queue:
        level_size = len(queue)
        max_level += 1

        for _ in range(level_size):
            node = queue.pop(0)

            if node.left is not None:
                queue.append(node.left)
            if node.right is not None:
                queue.append(node.right)

    return max_level

root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

print(max_level(root))  # Output: 3
```

#### C++
```cpp
class Node {
public:
    int val;
    Node* left, *right;

    Node(int val) : val(val), left(nullptr), right(nullptr) {}
};

int maxLevel(Node* root) {
    if (root == nullptr) return 0;

    int maxLevel = 0;
    queue<Node*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        maxLevel++;

        for (int i = 0; i < levelSize; i++) {
            Node* node = q.front();
            q.pop();

            if (node->left != nullptr) q.push(node->left);
            if (node->right != nullptr) q.push(node->right);
        }
    }

    return maxLevel;
}

int main() {
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->left->left = new Node(4);
    root->left->right = new Node(5);

    cout << maxLevel(root) << endl;  // Output: 3

    return 0;
}
```

#### JavaScript
```javascript
class Node {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

function maxLevel(root) {
    if (root === null) return 0;

    let queue = [root];
    let level = 1;
    let maxLevel = 0;

    while (queue.length > 0) {
        let levelSize = queue.length;
        maxLevel++;

        for (let i = 0; i < levelSize; i++) {
            let node = queue.shift();

            if (node.left !== null) queue.push(node.left);
            if (node.right !== null) queue.push(node.right);
        }
    }

    return maxLevel;
}

const root = new Node(1);
root.left = new Node(2);
root.right = new Node(3);
root.left.left = new Node(4);
root.left.right = new Node(5);

console.log(maxLevel(root));  // Output: 3
```