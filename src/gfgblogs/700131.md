---
id: "700131"
title: "Delete in a Doubly Linked List"
slug: "delete-node-in-doubly-linked-list"
difficulty: "Easy"
companyTags: ["Amazon", "Walmart"]
tags: ["doubly-linked-list", "Linked List", "Data Structures", "Algorithms"]
---

# Delete Node in a Doubly Linked List

## Summary

This problem involves deleting a node from a doubly linked list. A doubly linked list is a data structure where each node has two pointers, one pointing to the previous node and another pointing to the next node. The goal is to delete a given node from the list while maintaining the integrity of the remaining nodes.

## Detailed Explanation

To solve this problem, we will follow these steps:

1. **Find the node**: First, locate the node that needs to be deleted in the doubly linked list.
2. **Update previous node's next pointer**: Update the `next` pointer of the previous node to point to the node that was previously pointed to by the current node.
3. **Update current node's next pointer**: Set the `next` pointer of the current node to `null`.
4. **Update node that was previously pointed to**: Set the `previous` pointer of the node that was previously pointed to by the current node to point to the previous node.
5. **Delete the node**: Finally, delete the current node.

Here is a step-by-step breakdown of the algorithm:

```
// Given a doubly linked list and a target node
Node* deleteNode(Node* head, Node* target) {
    // If the target node is the head of the list
    if (head == target) {
        return head->next; // Return the new head
    }

    // Traverse the list to find the target node
    Node* current = head;
    while (current != null && current != target) {
        current = current->next;
    }

    // If the target node is not found in the list
    if (current == null) {
        return head; // Return the original head
    }

    // Update previous node's next pointer
    Node* previous = head;
    while (previous->next != target) {
        previous = previous->next;
    }
    previous->next = current->next;

    // Update current node's next pointer and delete it
    current->next = null;
    return head; // Return the modified list
}
```

The time complexity of this algorithm is O(n), where n is the number of nodes in the doubly linked list. The space complexity is O(1), as we only use a constant amount of space to store the pointers and variables.

## Optimized Solutions

### Java
```java
public class DoublyLinkedList {
    public static Node deleteNode(Node head, Node target) {
        if (head == target) {
            return head.next;
        }

        Node current = head;
        while (current != null && current != target) {
            current = current.next;
        }

        if (current == null) {
            return head;
        }

        Node previous = head;
        while (previous.next != target) {
            previous = previous.next;
        }
        previous.next = current.next;

        current.next = null;
        return head;
    }
}
```

### Python
```python
class DoublyLinkedList:
    def delete_node(self, head, target):
        if head == target:
            return head.next

        current = head
        while current and current != target:
            current = current.next

        if not current:
            return head

        previous = head
        while previous.next != target:
            previous = previous.next
        previous.next = current.next

        current.next = None
        return head
```

### C++
```cpp
class DoublyLinkedList {
public:
    Node* deleteNode(Node* head, Node* target) {
        if (head == target) {
            return head->next;
        }

        Node* current = head;
        while (current && current != target) {
            current = current->next;
        }

        if (!current) {
            return head;
        }

        Node* previous = head;
        while (previous->next != target) {
            previous = previous->next;
        }
        previous->next = current->next;

        current->next = nullptr;
        return head;
    }
};
```

### JavaScript
```javascript
class DoublyLinkedList {
  deleteNode(head, target) {
    if (head === target) {
      return head.next;
    }

    let current = head;
    while (current && current !== target) {
      current = current.next;
    }

    if (!current) {
      return head;
    }

    let previous = head;
    while (previous.next !== target) {
      previous = previous.next;
    }
    previous.next = current.next;

    current.next = null;
    return head;
  }
}
```

Note that these solutions are optimized and assume a basic understanding of doubly linked lists and their operations.