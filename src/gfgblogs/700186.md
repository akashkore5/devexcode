---
id: "700186"
title: "Clone List with Next and Random"
slug: "clone-a-linked-list-with-next-and-random-pointer"
difficulty: "Hard"
companyTags: ["Flipkart", "Morgan Stanley", "Amazon", "Microsoft", "OYO Rooms", "Snapdeal", "D-E-Shaw", "MakeMyTrip", "Ola Cabs", "Walmart", "Adobe", "BankBazaar"]
tags: ["Linked List", "Data Structures"]
---

**Clone List with Next and Random**
======================================================

## Summary
Given a linked list where each node has three pointers, `next`, `random` and `val`, we need to clone this linked list. The `next` pointer points to the next node in the sequence, while the `random` pointer points to any other node (including itself) in the sequence. We need to create a new copy of this linked list.

## Detailed Explanation
The key concept involved here is manipulation of pointers and nodes in a linked list.

To solve this problem, we will use a recursive approach. First, we will clone each node in the original list. Then, we will update the `random` pointer for each node to point to its corresponding copy.

Here's a step-by-step breakdown of the solution:

1. Create a new node with the same value as the current node.
2. Update the `next` pointer of the cloned node to point to the next clone in the sequence.
3. Update the `random` pointer of the cloned node to point to its corresponding copy.

Here's an ASCII art diagram representing the original list and its clone:
```
Original List: A -> B -> C
Clone List: A' -> B' -> C'
```

Time complexity for this solution is O(N), where N is the number of nodes in the linked list. This is because we are visiting each node once.

Space complexity for this solution is also O(N), as we need to create a new copy of the entire list.

## Optimized Solutions
### Java
```java
public Node cloneList(Node head) {
    if (head == null) {
        return null;
    }

    Node clone = new Node(head.val);
    Node current = head.next;
    Node original = head;

    while (current != null) {
        Node nextOriginal = current.next;
        Node nextClone = new Node(current.val);

        current.next = nextClone;
        nextClone.next = nextOriginal;
        current = nextOriginal;
    }

    current = head;
    while (current != null) {
        Node cloneNode = current.next;
        current.next = cloneNode.next;
        cloneNode.next = (current.random == null) ? null : ((NodeList)clone).get(cloneNode.random.index);
        current = current.next;
    }

    return clone;
}
```

### Python
```python
def clone_list(head):
    if head is None:
        return None

    cloned_head = Node(head.val)
    current = head.next
    original = head

    while current is not None:
        next_original = current.next
        next_cloned = Node(current.val)

        current.next = next_cloned
        next_cloned.next = next_original
        current = next_original

    current = head
    while current is not None:
        cloned_node = current.next
        current.next = cloned_node.next
        if current.random is not None:
            cloned_random_index = [i for i, node in enumerate(list) if node == current.random][0]
            cloned_node.next = list[cloned_random_index].next
        current = current.next

    return cloned_head
```

### C++
```cpp
Node* cloneList(Node* head) {
    if (head == nullptr) {
        return nullptr;
    }

    Node* cloneHead = new Node(head->val);
    Node* current = head->next;
    Node* original = head;

    while (current != nullptr) {
        Node* nextOriginal = current->next;
        Node* nextClone = new Node(current->val);

        current->next = nextClone;
        nextClone->next = nextOriginal;
        current = nextOriginal;
    }

    current = head;
    while (current != nullptr) {
        Node* cloneNode = current->next;
        current->next = cloneNode->next;
        if (current->random == nullptr) {
            cloneNode->next = nullptr;
        } else {
            int randomIndex = -1;
            for (Node* node = head; node != nullptr && randomIndex < 0; node = node->next) {
                if (node->val == current->random->val) {
                    randomIndex = list.indexOf(node);
                }
            }
            cloneNode->next = list.get(randomIndex).next;
        }
        current = current->next;
    }

    return cloneHead;
}
```

### JavaScript
```javascript
function cloneList(head) {
    if (head === null) {
        return null;
    }

    let clonedHead = { val: head.val, next: null };
    let current = head.next;
    let original = head;

    while (current !== null) {
        let nextOriginal = current.next;
        let nextCloned = { val: current.val, next: null };

        current.next = nextCloned;
        nextCloned.next = nextOriginal;
        current = nextOriginal;
    }

    current = head;
    while (current !== null) {
        let clonedNode = current.next;
        current.next = clonedNode.next;
        if (current.random !== null) {
            const randomIndex = list.indexOf(current.random);
            clonedNode.next = list[randomIndex].next;
        }
        current = current.next;

    return clonedHead;
}
```

Note: The above solutions assume that the `random` pointer of each node in the original list only points to another node within the same linked list.