---
id: "707054"
title: "IPL 2021 - Match Day 6 - Semi Final"
slug: "ipl-2021-match-day-6-semi-final--141634"
difficulty: "Hard"
companyTags: []
tags: ["Stack", "Data Structures"]
---

**IPL 2021 - Match Day 6 - Semi Final**
==================================================

## Summary
In this problem, we're given a scenario where teams are playing matches in IPL 2021. The goal is to determine the winner of each match based on the points system. We're provided with two stacks representing the innings scores of the two teams. Our task is to pop the scores from both stacks and determine which team wins, considering the rules of the game.

## Detailed Explanation
To solve this problem, we'll use a stack-based approach. We'll iterate through both stacks simultaneously, popping elements from each stack and comparing them. The team with the higher score at any given point will be considered the winner. In case one team's score is higher than the other's, we'll continue popping scores until one of the following conditions is met:

* One team's stack becomes empty.
* The other team's stack also becomes empty.

We'll consider the team that has the higher score when both stacks are empty as the winner.

Here's a step-by-step breakdown of the solution:

1. Initialize two pointers, `i` and `j`, to point to the top elements in each stack.
2. Compare the scores at positions `i` and `j`. If the team with the higher score is Team A (represented by Stack 1), pop the element from Stack 1 and increment `i`.
3. If the team with the higher score is Team B (represented by Stack 2), pop the element from Stack 2 and increment `j`.
4. Repeat steps 2-3 until one of the following conditions is met:
	* One team's stack becomes empty.
	* The other team's stack also becomes empty.

The team with the higher score when both stacks are empty is considered the winner.

Time complexity: O(n), where n is the total number of elements in both stacks. We iterate through each element once, popping and comparing scores as needed.

Space complexity: O(1), since we only use a few variables to store the stack indices and don't require any additional space proportional to the input size.

## Optimized Solutions
### Java
```java
public class IPLMatch {
    public static String winner(int[] teamA, int[] teamB) {
        int i = 0, j = 0;
        while (i < teamA.length && j < teamB.length) {
            if (teamA[i] > teamB[j]) {
                i++;
            } else {
                j++;
            }
        }
        return teamA.length == i ? "Team A" : "Team B";
    }
}
```

### Python
```python
def winner(team_a, team_b):
    i = 0
    j = 0
    while i < len(team_a) and j < len(team_b):
        if team_a[i] > team_b[j]:
            i += 1
        else:
            j += 1
    return "Team A" if i == len(team_a) else "Team B"
```

### C++
```cpp
#include <vector>
#include <string>

std::string winner(std::vector<int> teamA, std::vector<int> teamB) {
    int i = 0, j = 0;
    while (i < teamA.size() && j < teamB.size()) {
        if (teamA[i] > teamB[j]) {
            i++;
        } else {
            j++;
        }
    }
    return teamA.size() == i ? "Team A" : "Team B";
}
```

### JavaScript
```javascript
function winner(teamA, teamB) {
  let i = 0;
  let j = 0;
  while (i < teamA.length && j < teamB.length) {
    if (teamA[i] > teamB[j]) {
      i++;
    } else {
      j++;
    }
  }
  return teamA.length === i ? "Team A" : "Team B";
}
```