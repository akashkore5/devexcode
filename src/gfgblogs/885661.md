---
id: "885661"
title: "K Closest Points to Origin"
slug: "k-closest-points-to-origin--172242"
difficulty: "Medium"
companyTags: []
tags: ["Sorting", "Heap", "Mathematical", "priority-queue", "Divide and Conquer", "Geometric", "Arrays"]
---

**K Closest Points to Origin**
================================

## Summary
Given a list of `n` points in 2D space, find the `k` closest points to the origin `(0, 0)`. The problem involves sorting and priority queue concepts, as we need to efficiently identify the closest points.

## Detailed Explanation
The approach is to first calculate the distance of each point from the origin. Then, use a priority queue (min-heap) to keep track of the `k` closest points. This way, we can efficiently remove the farthest point and add a new one if necessary.

Here's a step-by-step breakdown:

1.  Initialize an empty min-heap (priority queue).
2.  Iterate through each point `(x, y)` in the input list.
3.  Calculate the distance `d` from the origin using the Euclidean distance formula: `d = sqrt(x^2 + y^2)`.
4.  Add the point and its corresponding distance to the priority queue (min-heap).
5.  Once all points have been processed, extract the top `k` elements from the priority queue, which represent the `k` closest points to the origin.
6.  Return these `k` points.

Time Complexity Analysis:
The time complexity is O(n log n) due to the sorting and priority queue operations.

Space Complexity Analysis:
The space complexity is O(k) for storing the `k` closest points in the min-heap (priority queue).

## Optimized Solutions
### Java

```java
import java.util.*;

class Point {
    int x, y;
    double dist;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
        this.dist = Math.sqrt(x * x + y * y);
    }

    public static void main(String[] args) {
        List<Point> points = Arrays.asList(new Point(1, 2), new Point(-3, -4), ...);
        int k = 2;

        // Calculate the distance and store in a min-heap
        PriorityQueue<Point> pq = new PriorityQueue<>();
        for (Point p : points) {
            pq.add(p);
        }

        // Extract the top 'k' elements from the min-heap
        List<Point> closestPoints = new ArrayList<>();
        for (int i = 0; i < k; i++) {
            closestPoints.add(pq.poll());
        }

        // Print the 'k' closest points
        System.out.println(closestPoints);
    }
}
```

### Python

```python
import math
from heapq import heapify, heappop

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.dist = math.sqrt(x ** 2 + y ** 2)

def k_closest(points, k):
    # Calculate the distance and store in a min-heap
    pq = [Point(*point) for point in points]
    heapify(pq)

    # Extract the top 'k' elements from the min-heap
    closest_points = []
    for _ in range(k):
        closest_points.append(heappop(pq))

    return closest_points

# Example usage:
points = [(1, 2), (-3, -4), ...]
k = 2

print(k_closest(points, k))
```

### C++

```cpp
#include <queue>
#include <vector>

struct Point {
    int x, y;
    double dist;

    Point(int x, int y) : x(x), y(y), dist(sqrt(double(x)*x + double(y)*y)) {}
};

int main() {
    std::vector<Point> points = {{1, 2}, {-3, -4}, ...};
    int k = 2;

    // Calculate the distance and store in a min-heap
    std::priority_queue<std::pair<double, Point>, std::vector<std::pair<double, Point>>, std::greater<std::pair<double, Point>>> pq;
    for (const auto& p : points) {
        pq.push({p.dist, p});
    }

    // Extract the top 'k' elements from the min-heap
    std::vector<Point> closestPoints;
    for (int i = 0; i < k; ++i) {
        closestPoints.push_back(pq.top().second);
        pq.pop();
    }

    // Print the 'k' closest points
    std::cout << closestPoints << std::endl;

    return 0;
}
```

### JavaScript

```javascript
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.dist = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    }
}

function kClosest(points, k) {
    // Calculate the distance and store in a min-heap
    const pq = [...points].map((p) => ({ dist: p.dist, point: p }));
    pq.sort((a, b) => a.dist - b.dist);

    // Extract the top 'k' elements from the min-heap
    const closestPoints = pq.slice(0, k).map((p) => p.point);

    return closestPoints;
}

// Example usage:
const points = [{ x: 1, y: 2 }, { x: -3, y: -4 }, ...];
const k = 2;

console.log(kClosest(points, k));
```

I hope this helps! Let me know if you have any questions.