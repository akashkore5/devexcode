---
id: "889108"
title: "Minimum K Consecutive Bit Flips"
slug: "minimum-number-of-k-consecutive-bit-flips--171650"
difficulty: "Hard"
companyTags: []
tags: ["prefix-sum", "Bit Magic", "sliding-window", "Arrays", "Queue"]
---

**Minimum K Consecutive Bit Flips**
============================

## Summary
Given a binary array, find the minimum number of bit flips (i.e., changing 0 to 1 or vice versa) required to make all subarrays of length `K` have at least one 1. This problem involves prefix sums and sliding windows, making it a challenging problem that requires careful planning and execution.

## Detailed Explanation
To solve this problem, we can use a combination of prefix sums and sliding windows. The idea is to maintain a running count of the number of 0s in the current window of size `K`, as well as the total number of 1s seen so far. When we encounter a 1, we update our running count and increment our total count.

Here's a step-by-step breakdown of the solution:

1. Initialize two variables: `count` to keep track of the number of 0s in the current window, and `total_ones` to keep track of the total number of 1s seen so far.
2. Iterate through the binary array using a sliding window of size `K`.
3. For each element in the array, update our running count `count` based on whether it's a 0 or 1. If it's a 0, increment `count`. If it's a 1, reset `count` to 0.
4. If we've reached the end of the window, check if the number of 1s in the window is less than `K-1`. If so, update our total count by adding the length of the current window minus one (since we need at least one 1).
5. Repeat steps 2-4 until the end of the array.
6. The minimum number of bit flips required is equal to the total count.

Time complexity: O(n), where `n` is the length of the binary array.
Space complexity: O(1), since we only use a constant amount of space to store our running counts and totals.

## Optimized Solutions

### Java
```java
public int minKBitFlips(int[] arr, int k) {
    int count = 0;
    for (int i = 0; i < arr.length; i++) {
        if ((i + 1) % k == 0 && arr[i] == 0) {
            count++;
        } else if (arr[i] == 1) {
            count = 0;
        }
    }
    return count;
}
```

### Python
```python
def minKBitFlips(arr, k):
    count = 0
    for i in range(len(arr)):
        if (i + 1) % k == 0 and arr[i] == 0:
            count += 1
        elif arr[i] == 1:
            count = 0
    return count
```

### C++
```cpp
int minKBitFlips(vector<int>& arr, int k) {
    int count = 0;
    for (int i = 0; i < arr.size(); i++) {
        if ((i + 1) % k == 0 && arr[i] == 0) {
            count++;
        } else if (arr[i] == 1) {
            count = 0;
        }
    }
    return count;
}
```

### JavaScript
```javascript
function minKBitFlips(arr, k) {
    let count = 0;
    for (let i = 0; i < arr.length; i++) {
        if ((i + 1) % k === 0 && arr[i] === 0) {
            count++;
        } else if (arr[i] === 1) {
            count = 0;
        }
    }
    return count;
}
```