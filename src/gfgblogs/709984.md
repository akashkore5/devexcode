---
id: "709984"
title: "K-th Largest Sum Contiguous Subarray"
slug: "k-th-largest-sum-contiguous-subarray"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "priority-queue", "Data Structures", "Algorithms"]
---

Here is a detailed Markdown blog post for the GeeksforGeeks problem "K-th Largest Sum Contiguous Subarray":

# K-th Largest Sum Contiguous Subarray
## Slug: k-th-largest-sum-contiguous-subarray
## Difficulty: Medium
## Id: 709984
## Topic Tags: Arrays, priority-queue, Data Structures, Algorithms
## Company Tags: None

### Summary
Given an array of integers and a positive integer K, find the Kth largest sum of contiguous subarrays. A contiguous subarray is a sequence of numbers within the original array that can be accessed by its start index, end index, and length.

In this problem, we need to find the Kth largest sum of such subarrays. We will use a priority queue to efficiently keep track of the top-K sums encountered so far.

### Detailed Explanation
To solve this problem, we first initialize an empty priority queue Q. Then, we iterate over each possible contiguous subarray in the given array. For each subarray, we calculate its sum and add it to the priority queue. If the size of the priority queue exceeds K, we remove the smallest element from the queue.

Finally, after processing all subarrays, we retrieve the Kth largest sum from the priority queue. This sum is the desired answer.

Here's a step-by-step breakdown:

1. Initialize an empty priority queue Q.
2. Iterate over each possible contiguous subarray in the given array.
3. For each subarray:
   * Calculate its sum.
   * Add the sum to the priority queue Q.
   * If the size of the priority queue exceeds K, remove the smallest element from the queue.
4. After processing all subarrays, retrieve the Kth largest sum from the priority queue.

The time complexity for this solution is O(n log k), where n is the length of the input array and k is the value of K. The space complexity is O(k).

### Optimized Solutions

#### Java
```java
import java.util.PriorityQueue;
import java.util.Queue;

public class Solution {
    public int kthLargestSum(int[] nums, int k) {
        Queue<Integer> pq = new PriorityQueue<>();
        
        for (int i = 0; i < nums.length; i++) {
            for (int j = i; j < nums.length; j++) {
                int sum = 0;
                for (int x = i; x <= j; x++) {
                    sum += nums[x];
                }
                pq.offer(sum);
                
                if (pq.size() > k) {
                    pq.poll();
                }
            }
        }
        
        return pq.peek();
    }
}
```

#### Python
```python
import heapq

def kth_largest_sum(nums, k):
    pq = []
    
    for i in range(len(nums)):
        for j in range(i, len(nums)):
            sum = 0
            for x in range(i, j+1):
                sum += nums[x]
            heapq.heappush(pq, -sum)
            
            if len(pq) > k:
                heapq.heappop(pq)
    
    return -pq[0]
```

#### C++
```cpp
#include <queue>
#include <vector>

int kthLargestSum(std::vector<int>& nums, int k) {
    std::priority_queue<int> pq;
    
    for (int i = 0; i < nums.size(); i++) {
        for (int j = i; j < nums.size(); j++) {
            int sum = 0;
            for (int x = i; x <= j; x++) {
                sum += nums[x];
            }
            pq.push(-sum);
            
            if (pq.size() > k) {
                pq.pop();
            }
        }
    }
    
    return -pq.top();
}
```

#### JavaScript
```javascript
function kthLargestSum(nums, k) {
    const pq = [];
    
    for (let i = 0; i < nums.length; i++) {
        for (let j = i; j < nums.length; j++) {
            let sum = 0;
            for (let x = i; x <= j; x++) {
                sum += nums[x];
            }
            pq.push(-sum);
            
            if (pq.length > k) {
                pq.shift();
            }
        }
    }
    
    return -pq[0];
}
```

This problem requires a combination of array manipulation and priority queue operations. The provided solutions demonstrate how to efficiently find the Kth largest sum of contiguous subarrays in an array.