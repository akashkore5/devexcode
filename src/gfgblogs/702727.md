---
id: "702727"
title: "Longest Span in two Binary Arrays"
slug: "longest-span-with-same-sum-in-two-binary-arrays5142"
difficulty: "Medium"
companyTags: []
tags: ["prefix-sum", "sliding-window", "Arrays", "Data Structures", "Algorithms"]
---

Here is a detailed Markdown blog post for the GeeksforGeeks problem "Longest Span in two Binary Arrays":

**Longest Span with Same Sum in Two Binary Arrays**
=====================================================

## Summary
Given two binary arrays, A and B, where each array contains 0s and 1s, find the longest span (i.e., sequence of consecutive elements) that has the same sum in both arrays. The arrays can be of any length, but we assume they are non-empty.

This problem involves prefix sums, sliding windows, and arrays, making it a challenging yet tractable algorithmic problem.

## Detailed Explanation
The key to solving this problem is to use prefix sums to efficiently calculate the sum of each subarray in both A and B. We can then iterate through the arrays, maintaining two pointers for each array (one at the start and one at the end). As we move the pointers, we update the sums and keep track of the longest span found.

Here's a step-by-step breakdown:

1. Calculate the prefix sum for each array A and B.
2. Initialize two pointers, `i` and `j`, to 0 (start of both arrays).
3. Calculate the sum of the subarray from index 0 to `i` in array A (`sum_A`) and the corresponding sum in array B (`sum_B`).
4. If `sum_A == sum_B`, update the longest span found so far.
5. Move the pointers:
	* If `sum_A < sum_B`, increment `i` (move the start pointer of array A forward).
	* If `sum_A > sum_B`, decrement `j` (move the end pointer of array B backward).
6. Repeat steps 3-5 until the pointers reach the end of either array.
7. Return the longest span found.

Here's an ASCII art diagram to illustrate the concept:

    A: [0, 1, 0, 1]
    B: [0, 1, 1, 0]
    i = 2
    j = 2
    sum_A = 1 (0+1)
    sum_B = 1 (0+1)

    * Move `i` forward:
      A: [0, 1, 0, 1]
      B: [0, 1, 1, 0]
      i = 3
      j = 2
      sum_A = 2 (0+1+0)
      sum_B = 1 (0+1)

    * Move `j` backward:
      A: [0, 1, 0, 1]
      B: [0, 1, 0, 0]
      i = 3
      j = 1
      sum_A = 2 (0+1+0)
      sum_B = 0 (0+1-1)

    * Update longest span:
      Longest span found so far: [2]

Time complexity: O(n), where n is the length of the arrays.
Space complexity: O(1) since we only use a constant amount of space to store the prefix sums and pointers.

## Optimized Solutions
### Java
```java
public int longestSpan(int[] A, int[] B) {
    int n = A.length;
    int[] prefixSumA = new int[n + 1];
    int[] prefixSumB = new int[n + 1];

    for (int i = 0; i < n; i++) {
        prefixSumA[i + 1] = prefixSumA[i] + A[i];
        prefixSumB[i + 1] = prefixSumB[i] + B[i];
    }

    int maxSpan = 0;
    int i = 0, j = n - 1;

    while (i < n && j >= 0) {
        if (prefixSumA[i] == prefixSumB[j]) {
            maxSpan = Math.max(maxSpan, j - i + 1);
            i++;
            j--;
        } else if (prefixSumA[i] < prefixSumB[j]) {
            i++;
        } else {
            j--;
        }
    }

    return maxSpan;
}
```
### Python
```python
def longest_span(A, B):
    n = len(A)
    prefix_sum_A = [0] * (n + 1)
    prefix_sum_B = [0] * (n + 1)

    for i in range(n):
        prefix_sum_A[i + 1] = prefix_sum_A[i] + A[i]
        prefix_sum_B[i + 1] = prefix_sum_B[i] + B[i]

    max_span = 0
    i, j = 0, n - 1

    while i < n and j >= 0:
        if prefix_sum_A[i] == prefix_sum_B[j]:
            max_span = max(max_span, j - i + 1)
            i += 1
            j -= 1
        elif prefix_sum_A[i] < prefix_sum_B[j]:
            i += 1
        else:
            j -= 1

    return max_span
```
### C++
```cpp
int longestSpan(vector<int>& A, vector<int>& B) {
    int n = A.size();
    vector<int> prefixSumA(n + 1);
    vector<int> prefixSumB(n + 1);

    for (int i = 0; i < n; i++) {
        prefixSumA[i + 1] = prefixSumA[i] + A[i];
        prefixSumB[i + 1] = prefixSumB[i] + B[i];
    }

    int maxSpan = 0;
    int i = 0, j = n - 1;

    while (i < n && j >= 0) {
        if (prefixSumA[i] == prefixSumB[j]) {
            maxSpan = std::max(maxSpan, j - i + 1);
            i++;
            j--;
        } else if (prefixSumA[i] < prefixSumB[j]) {
            i++;
        } else {
            j--;
        }
    }

    return maxSpan;
}
```
### JavaScript
```javascript
function longestSpan(A, B) {
    let n = A.length;
    let prefixSumA = new Array(n + 1);
    let prefixSumB = new Array(n + 1);

    for (let i = 0; i < n; i++) {
        prefixSumA[i + 1] = prefixSumA[i] + A[i];
        prefixSumB[i + 1] = prefixSumB[i] + B[i];
    }

    let maxSpan = 0;
    let i = 0, j = n - 1;

    while (i < n && j >= 0) {
        if (prefixSumA[i] === prefixSumB[j]) {
            maxSpan = Math.max(maxSpan, j - i + 1);
            i++;
            j--;
        } else if (prefixSumA[i] < prefixSumB[j]) {
            i++;
        } else {
            j--;
        }
    }

    return maxSpan;
}
```
Note that the optimized solutions use a similar approach to the detailed explanation, but with the added bonus of being concise and efficient.