---
id: "703335"
title: "The Inverting Factor"
slug: "the-inverting-factor3932"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Numbers", "Reverse", "Data Structures"]
---

**The Inverting Factor**
=====================

**Slug:** the-inverting-factor3932
**Difficulty:** Easy
**Id:** 703335
**Topic Tags:** Arrays, Numbers, Reverse, Data Structures
**Company Tags:** None

## Summary
The problem is about finding the inverting factor of an array. Given an integer array `arr`, find the maximum number that can be obtained by reversing any subarray within the given array and adding it to another number. The goal is to maximize this sum.

## Detailed Explanation
To solve this problem, we will iterate over the array and calculate the sum of each possible subarray after reversing it. We then compare these sums with our current maximum sum and update it if necessary. Here's a step-by-step breakdown:

1. Initialize `max_sum` as the first element of the array.
2. Iterate over the array from the second element to the end.
3. For each element, calculate the sum of the subarray starting from this element and ending at the last element of the array. Reverse this subarray and add it to the current element.
4. Compare this sum with `max_sum`. If it's greater, update `max_sum`.
5. Return `max_sum` as the result.

Time complexity: O(n^2), where n is the length of the array. This is because we are iterating over each element and then calculating the sum of a subarray.

Space complexity: O(1), as we are only using a constant amount of space to store the maximum sum and other variables.

## Optimized Solutions

### Java
```java
public int findInvertingFactor(int[] arr) {
    int max_sum = arr[0];
    for (int i = 1; i < arr.length; i++) {
        int temp_sum = 0;
        for (int j = i; j < arr.length; j++) {
            temp_sum += arr[j];
        }
        temp_sum = reverse(temp_sum);
        if (temp_sum + arr[i] > max_sum) {
            max_sum = temp_sum + arr[i];
        }
    }
    return max_sum;
}

private int reverse(int n) {
    int rev = 0;
    while (n != 0) {
        rev = rev * 10 + n % 10;
        n /= 10;
    }
    return rev;
}
```

### Python
```python
def find_inverting_factor(arr):
    max_sum = arr[0]
    for i in range(1, len(arr)):
        temp_sum = sum(arr[i:])
        temp_sum = int(str(temp_sum)[::-1])
        if temp_sum + arr[i] > max_sum:
            max_sum = temp_sum + arr[i]
    return max_sum
```

### C++
```cpp
int findInvertingFactor(int* arr, int n) {
    int max_sum = arr[0];
    for (int i = 1; i < n; i++) {
        int temp_sum = 0;
        for (int j = i; j < n; j++) {
            temp_sum += arr[j];
        }
        temp_sum = reverse(temp_sum);
        if (temp_sum + arr[i] > max_sum) {
            max_sum = temp_sum + arr[i];
        }
    }
    return max_sum;
}

int reverse(int n) {
    int rev = 0;
    while (n != 0) {
        rev = rev * 10 + n % 10;
        n /= 10;
    }
    return rev;
}
```

### JavaScript
```javascript
function findInvertingFactor(arr) {
    let max_sum = arr[0];
    for (let i = 1; i < arr.length; i++) {
        let temp_sum = 0;
        for (let j = i; j < arr.length; j++) {
            temp_sum += arr[j];
        }
        temp_sum = parseInt(temp_sum.toString().split("").reverse().join(""));
        if (temp_sum + arr[i] > max_sum) {
            max_sum = temp_sum + arr[i];
        }
    }
    return max_sum;
}
```

Note: These solutions are for the problem description provided and might not work exactly as described in GeeksforGeeks.