---
id: "714121"
title: "Max Level Sum in Binary Tree"
slug: "max-level-sum-in-binary-tree--170647"
difficulty: "Easy"
companyTags: ["Amazon"]
tags: ["Binary Search Tree", "Binary Search", "Tree"]
---

# Max Level Sum in Binary Tree
## Slug: max-level-sum-in-binary-tree--170647
## Difficulty: Easy
## Topic Tags: Binary Search Tree, Binary Search, Tree
## Company Tags: Amazon

### Summary
Given a binary tree, find the maximum sum of all nodes at any level.

The key concept involved is traversing and manipulating a binary tree to calculate the sum of its nodes at each level.

### Detailed Explanation
To solve this problem, we can use a depth-first search (DFS) approach. We will start by initializing an empty list `max_sum` to store the maximum sum at each level. Then, we will perform DFS traversal on the given binary tree.

Here's the step-by-step breakdown of the solution:

1. Initialize an empty list `max_sum`.
2. Perform DFS traversal on the given binary tree.
3. At each level, calculate the sum of all nodes and store it in the `max_sum` list.
4. Return the maximum sum from the `max_sum` list.

Here's a simple example to illustrate this:

```
        1
       / \
      2   3
     / \   \
    4   5   6
```

The maximum sum at each level is: `[1], [7], [8]`. So, the final answer will be `8`.

Time complexity analysis:

* The time complexity of DFS traversal on a binary tree is O(n), where n is the number of nodes in the tree.
* Since we are performing this traversal once and calculating the sum at each level, the overall time complexity is also O(n).

Space complexity analysis:

* The space complexity depends on the maximum depth of the binary tree. In the worst-case scenario, it can be O(logn), where n is the number of nodes in the tree.

### Optimized Solutions

#### Java
```java
class Solution {
    public int maxLevelSum(TreeNode root) {
        if (root == null)
            return 0;
        
        List<Integer> max_sum = new ArrayList<>();
        int max = Integer.MIN_VALUE;
        
        dfs(root, 1, max_sum);
        
        for (int i : max_sum) {
            if (i > max)
                max = i;
        }
        
        return max;
    }
    
    private void dfs(TreeNode node, int level, List<Integer> max_sum) {
        if (node == null)
            return;
        
        if (max_sum.size() < level) {
            max_sum.add(0);
        }
        
        max_sum.set(level - 1, max_sum.get(level - 1) + node.val);
        
        dfs(node.left, level + 1, max_sum);
        dfs(node.right, level + 1, max_sum);
    }
}
```

#### Python
```python
class Solution:
    def maxLevelSum(self, root):
        if not root:
            return 0
        
        max_sum = []
        max_val = float('-inf')
        
        self.dfs(root, 1, max_sum)
        
        for i in max_sum:
            if i > max_val:
                max_val = i
        return max_val
    
    def dfs(self, node, level, max_sum):
        if not node:
            return
        
        if len(max_sum) < level:
            max_sum.append(0)
        
        max_sum[level - 1] += node.val
        
        self.dfs(node.left, level + 1, max_sum)
        self.dfs(node.right, level + 1, max_sum)
```

#### C++
```cpp
class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        if (!root)
            return 0;
        
        vector<int> max_sum;
        int max = INT_MIN;
        
        dfs(root, 1, max_sum);
        
        for (int i : max_sum) {
            if (i > max)
                max = i;
        }
        
        return max;
    }
    
    void dfs(TreeNode* node, int level, vector<int>& max_sum) {
        if (!node)
            return;
        
        if (max_sum.size() < level) {
            max_sum.push_back(0);
        }
        
        max_sum[level - 1] += node->val;
        
        dfs(node->left, level + 1, max_sum);
        dfs(node->right, level + 1, max_sum);
    }
};
```

#### JavaScript
```javascript
class Solution {
    maxLevelSum(root) {
        if (!root)
            return 0;
        
        let max_sum = [];
        let max_val = -Infinity;
        
        this.dfs(root, 1, max_sum);
        
        for (let i of max_sum) {
            if (i > max_val)
                max_val = i;
        }
        
        return max_val;
    }
    
    dfs(node, level, max_sum) {
        if (!node)
            return;
        
        if (max_sum.length < level) {
            max_sum.push(0);
        }
        
        max_sum[level - 1] += node.val;
        
        this.dfs(node.left, level + 1, max_sum);
        this.dfs(node.right, level + 1, max_sum);
    }
}
```