---
id: "712195"
title: "Subarrays with K Distinct Integers"
slug: "subarrays-with-k-different-integers"
difficulty: "Medium"
companyTags: []
tags: ["sliding-window", "Arrays", "Data Structures", "Algorithms"]
---

**Subarrays with K Distinct Integers**
==============================

## Summary
Given an array `arr` and an integer `k`, find the number of subarrays that contain exactly `k` distinct integers. This problem involves sliding window, arrays, data structures, and algorithms.

## Detailed Explanation
The idea is to use a sliding window approach to count the number of subarrays with `k` distinct integers. Initialize two pointers, `start` and `end`, to the beginning of the array. Initialize an empty set `distinct` to store unique elements in the current window.

1.  Expand the window by moving the `end` pointer to the right.
2.  For each new element encountered, update the `distinct` set accordingly (add or remove as necessary).
3.  Count the number of subarrays with exactly `k` distinct integers within the current window.
4.  Shrink the window by moving the `start` pointer to the right when the size of `distinct` exceeds `k`.
5.  Repeat steps 1-4 until the end of the array is reached.

Time Complexity: O(n)
Space Complexity: O(min(k, n)) where `n` is the length of the array

## Optimized Solutions
### Java
```java
import java.util.*;

public class Main {
    public static int subarraysWithKDistinct(int[] arr, int k) {
        Map<Integer, Integer> distinctCount = new HashMap<>();
        int start = 0;
        int end = 0;
        int count = 0;

        while (end < arr.length) {
            if (!distinctCount.containsKey(arr[end])) {
                distinctCount.put(arr[end], 1);
            } else {
                distinctCount.put(arr[end], distinctCount.get(arr[end]) + 1);
            }

            while (distinctCount.size() > k && start <= end) {
                if (distinctCount.get(arr[start]) == 1) {
                    distinctCount.remove(arr[start]);
                } else {
                    distinctCount.put(arr[start], distinctCount.get(arr[start]) - 1);
                }
                start++;
            }

            count += end - start + 1;
            end++;
        }

        return count;
    }
}
```

### Python
```python
def subarraysWithKDistinct(arr, k):
    distinct_count = {}
    start = 0
    end = 0
    count = 0

    while end < len(arr):
        if arr[end] not in distinct_count:
            distinct_count[arr[end]] = 1
        else:
            distinct_count[arr[end]] += 1

        while len(distinct_count) > k and start <= end:
            if distinct_count[arr[start]] == 1:
                del distinct_count[arr[start]]
            else:
                distinct_count[arr[start]] -= 1
            start += 1

        count += end - start + 1
        end += 1

    return count
```

### C++
```cpp
#include <iostream>
#include <unordered_map>
#include <vector>

int subarraysWithKDistinct(std::vector<int> arr, int k) {
    std::unordered_map<int, int> distinctCount;
    int start = 0;
    int end = 0;
    int count = 0;

    while (end < arr.size()) {
        if (!distinctCount.count(arr[end])) {
            distinctCount[arr[end]] = 1;
        } else {
            distinctCount[arr[end]]++;
        }

        while (distinctCount.size() > k && start <= end) {
            if (distinctCount[arr[start]] == 1) {
                distinctCount.erase(arr[start]);
            } else {
                distinctCount[arr[start]]--;
            }
            start++;
        }

        count += end - start + 1;
        end++;
    }

    return count;
}
```

### JavaScript
```javascript
function subarraysWithKDistinct(arr, k) {
    let distinctCount = new Map();
    let start = 0;
    let end = 0;
    let count = 0;

    while (end < arr.length) {
        if (!distinctCount.has(arr[end])) {
            distinctCount.set(arr[end], 1);
        } else {
            distinctCount.set(arr[end], distinctCount.get(arr[end]) + 1);
        }

        while (distinctCount.size > k && start <= end) {
            if (distinctCount.get(arr[start]) === 1) {
                distinctCount.delete(arr[start]);
            } else {
                distinctCount.set(arr[start], distinctCount.get(arr[start]) - 1);
            }
            start++;
        }

        count += end - start + 1;
        end++;
    }

    return count;
}
```