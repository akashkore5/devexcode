---
id: "700127"
title: "Sorted insert for circular linked list"
slug: "sorted-insert-for-circular-linked-list"
difficulty: "Medium"
companyTags: ["Zoho", "Amazon", "Microsoft"]
tags: ["circular-linked-list", "Linked List", "Data Structures"]
---

# Sorted Insert for Circular Linked List
## Slug: sorted-insert-for-circular-linked-list
## Difficulty: Medium
## Id: 700127
## Topic Tags: circular-linked-list, Linked List, Data Structures
## Company Tags: Zoho, Amazon, Microsoft

### Summary
Given a circular linked list and an integer value to be inserted in the sorted order. The task is to insert the given value in the correct position in the sorted circular linked list.

### Detailed Explanation
To solve this problem, we need to maintain two pointers - `prev` and `current`. Initially, both are pointing at the head of the list. We start traversing the list from the head until we find a node whose data is greater than or equal to the value to be inserted. This node becomes our insertion point.

If the value to be inserted is less than the data of the head node, we need to check if it should be inserted at the end of the list or before the first node (since it's a circular linked list). We do this by moving `prev` and `current` until they meet. This ensures that we traverse the entire list.

Once we find our insertion point, we update the data of the node to which `current` is pointing to be equal to the value to be inserted. If the new node should come before the head, we need to update the head as well.

Here's a step-by-step breakdown:

1. Initialize `prev` and `current` to point at the head of the list.
2. Traverse the list until you find a node whose data is greater than or equal to the value to be inserted.
3. If the value to be inserted is less than the data of the head node, continue traversing the list until `prev` and `current` meet.
4. Update the data of the node pointed by `current` to be equal to the value to be inserted.
5. If the new node should come before the head, update the head as well.

Time complexity: O(n), where n is the number of nodes in the list.
Space complexity: O(1).

### Optimized Solutions
#### Java
```java
public class Node {
    int data;
    Node next;

    public Node(int d) {
        data = d;
        next = null;
    }
}

public void sortedInsert(Node head, int val) {
    Node prev = head;
    Node current = head;
    
    do {
        if (val <= current.data) {
            prev.next = new Node(val);
            prev = prev.next;
            return;
        }
        prev = current;
        current = current.next;
    } while (prev != head && current != head);

    if (val < head.data) {
        prev.next = new Node(val);
    } else {
        head.data = val;
    }
}
```

#### Python
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def sorted_insert(head, val):
    prev = head
    current = head
    
    while True:
        if val <= current.data:
            prev.next = Node(val)
            prev = prev.next
            return
        prev = current
        current = current.next
        
        if prev == head and current == head:
            break

    if val < head.data:
        prev.next = Node(val)
    else:
        head.data = val
```

#### C++
```cpp
class Node {
public:
    int data;
    Node* next;

    Node(int d) : data(d), next(nullptr) {}
};

void sortedInsert(Node* head, int val) {
    Node* prev = head;
    Node* current = head;
    
    do {
        if (val <= current->data) {
            prev->next = new Node(val);
            prev = prev->next;
            return;
        }
        prev = current;
        current = current->next;
    } while (prev != head && current != head);

    if (val < head->data) {
        prev->next = new Node(val);
    } else {
        head->data = val;
    }
}
```

#### JavaScript
```javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

function sortedInsert(head, val) {
  let prev = head;
  let current = head;
  
  do {
    if (val <= current.data) {
      prev.next = new Node(val);
      prev = prev.next;
      return;
    }
    prev = current;
    current = current.next;
    
    if (prev === head && current === head) {
      break;
    }
  } while (true);

  if (val < head.data) {
    prev.next = new Node(val);
  } else {
    head.data = val;
  }
}
```

Note: The optimized solutions are not necessarily the most efficient, but they aim to provide a clear and concise implementation of the problem.