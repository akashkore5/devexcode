---
id: "700355"
title: "Sum of permutations"
slug: "sum-of-permutations"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Modular Arithmetic", "Data Structures", "Algorithms"]
---

Here is the detailed Markdown blog post for the "Sum of permutations" problem:

# Sum of permutations
## Summary
The problem is to calculate the sum of all possible permutations of a given array of integers. The key concept involved is modular arithmetic, as we will be performing calculations with large numbers and taking their remainder when divided by a certain number.

## Detailed Explanation

Given an array `arr` of size `n`, our task is to find the sum of all possible permutations of this array modulo some prime number `p`. This problem can be solved using dynamic programming. We first initialize a 2D table `dp` of size `(1 << n) x p`, where each cell `dp[i][j]` will store the cumulative sum of all permutations ending at index `i` with remainder `j`.

Here's a step-by-step breakdown of the solution:

1. Initialize the table `dp` with zeros.
2. Iterate over the array `arr`. For each element `x`, calculate the new cumulative sums by adding `x` to the previous cumulative sums and taking their remainder modulo `p`.
3. Update the table `dp` accordingly.
4. Finally, return the sum of all permutations, which is stored in the last cell of the table `dp`.

Here's a diagram illustrating this approach:
```
     +---------------+
     |  arr = [1, 2, 3]  |
     +---------------+
                  |
                  v
     +---------------+
     |  dp[0][0] = 0   |
     |  dp[0][1] = 1   |
     |  ...            |
     +---------------+
                  |
                  v
     +---------------+
     |  dp[1][0] = 1   |
     |  dp[1][1] = 2   |
     |  ...            |
     +---------------+
                  |
                  v
     +---------------+
     |  dp[2][0] = 3   |
     |  dp[2][1] = 4   |
     |  ...            |
     +---------------+
                  |
                  v
     +---------------+
     |  Return sum of all  |
     |  permutations: dp[(1 << n) - 1][p-1]  |
     +---------------+
```
The time complexity of this solution is O(n \* p), where `n` is the size of the array and `p` is the prime number. The space complexity is O(p).

## Optimized Solutions

### Java
```java
public int sumOfPermutations(int[] arr, int p) {
    int n = arr.length;
    int MOD = 1000000007;
    long[][] dp = new long[1 << n][p];
    
    for (int i = 0; i < (1 << n); i++) {
        for (int j = 0; j < p; j++) {
            dp[i][j] = 0;
        }
    }
    
    for (int x : arr) {
        int carry = 0;
        for (int i = (1 << n) - 1; i >= 0; i--) {
            long sum = dp[i][x % p];
            sum += carry;
            sum %= MOD;
            if ((i & 1) == 1) {
                sum = (sum * 2 + x) % MOD;
            }
            dp[i][x % p] = sum;
        }
    }
    
    return (int) ((dp[(1 << n) - 1][p-1]) % MOD);
}
```

### Python
```python
def sum_of_permutations(arr, p):
    n = len(arr)
    MOD = 10**9 + 7
    
    dp = [[0] * p for _ in range(2**n)]
    
    for x in arr:
        carry = 0
        for i in range(2**n - 1, -1, -1):
            sum_val = dp[i][x % p]
            sum_val += carry
            sum_val %= MOD
            if i & 1:
                sum_val = (sum_val * 2 + x) % MOD
            dp[i][x % p] = sum_val
    
    return ((dp[2**n - 1][p-1]) % MOD)
```

### C++
```cpp
int sumOfPermutations(int* arr, int n, int p) {
    long long MOD = 1000000007;
    long long dp[(1 << n)][p];
    
    for (int i = 0; i < (1 << n); i++) {
        for (int j = 0; j < p; j++) {
            dp[i][j] = 0;
        }
    }
    
    int carry = 0;
    for (int x : arr) {
        for (int i = (1 << n) - 1; i >= 0; i--) {
            long long sum = dp[i][x % p];
            sum += carry;
            sum %= MOD;
            if ((i & 1) == 1) {
                sum = (sum * 2 + x) % MOD;
            }
            dp[i][x % p] = sum;
        }
    }
    
    return (int)((dp[(1 << n) - 1][p-1]) % MOD);
}
```

### JavaScript
```javascript
function sumOfPermutations(arr, p) {
    const n = arr.length;
    let MOD = 10**9 + 7;
    let dp = new Array((1 << n)).fill(0).map(() => new Array(p).fill(0));
    
    for (let x of arr) {
        let carry = 0;
        for (let i = (1 << n) - 1; i >= 0; i--) {
            let sum = dp[i][x % p];
            sum += carry;
            sum %= MOD;
            if ((i & 1) == 1) {
                sum = (sum * 2 + x) % MOD;
            }
            dp[i][x % p] = sum;
        }
    }
    
    return Math.floor((dp[(1 << n) - 1][p-1]) % MOD);
}
```