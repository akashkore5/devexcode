---
id: "703480"
title: "K-th missing element"
slug: "k-th-missing-element3635"
difficulty: "Easy"
companyTags: ["Amazon", "Facebook", "Apple", "Google"]
tags: ["Arrays", "Data Structures"]
---

Here is the Markdown blog post for the GeeksforGeeks problem "K-th missing element":

**K-th Missing Element**
=====================

**Slug:** k-th-missing-element3635
**Difficulty:** Easy
**Id:** 703480
**Topic Tags:** Arrays, Data Structures
**Company Tags:** Amazon, Facebook, Apple, Google

## Summary
The K-th missing element problem involves finding the K-th missing element in a sequence of integers. The input consists of a sorted array of integers with some elements missing. The task is to find the K-th missing element. This problem requires an understanding of arrays and data structures.

## Detailed Explanation
To solve this problem, we first need to understand what the problem is asking for. It's asking us to find the K-th missing element in a sorted array of integers with some elements missing. The key concept here is that the input array is sorted, which allows us to use a simple iteration-based approach.

Here is a step-by-step breakdown of the solution:

1. Initialize two pointers, `left` and `right`, to the start and end of the array respectively.
2. Iterate through the array until `right - left + 1` (the difference between the right and left pointers plus one) is equal to K+1. This means we have found the K-th missing element.
3. In each iteration, check if there are any elements missing between `left` and `right`. If there are, increment the `left` pointer until we find a non-missing element.
4. Once we have found the K-th missing element, return it.

Here is an ASCII art diagram to illustrate this approach:
```
          +---------------+
          | 1, 2, 3, ... |
          +---------------+
                  |
                  v
+---------------+
| ? (K-1st missing) |
+---------------+
                  |
                  v
+---------------+
| K-th missing    |
+---------------+
```

Time complexity: O(n), where n is the length of the array.
Space complexity: O(1).

## Optimized Solutions

### Java
```java
public int findKthMissingElement(int[] arr, int k) {
    int left = 0;
    int right = arr.length - 1;
    for (int i = 0; i < k; i++) {
        while (left <= right && arr[left] + 1 != arr[right]) {
            left++;
        }
        if (left > right) {
            return arr[left - 1] + k - i;
        }
        right--;
    }
    return arr[right] + k;
}
```

### Python
```python
def find_kth_missing_element(arr, k):
    left = 0
    right = len(arr) - 1
    for _ in range(k):
        while left <= right and arr[left] + 1 != arr[right]:
            left += 1
        if left > right:
            return arr[left - 1] + k - _
        right -= 1
    return arr[right] + k
```

### C++
```cpp
int findKthMissingElement(int* arr, int n, int k) {
    int left = 0;
    int right = n - 1;
    for (int i = 0; i < k; i++) {
        while (left <= right && arr[left] + 1 != arr[right]) {
            left++;
        }
        if (left > right) {
            return arr[left - 1] + k - i;
        }
        right--;
    }
    return arr[right] + k;
}
```

### JavaScript
```javascript
function findKthMissingElement(arr, k) {
    let left = 0;
    let right = arr.length - 1;
    for (let i = 0; i < k; i++) {
        while (left <= right && arr[left] + 1 !== arr[right]) {
            left++;
        }
        if (left > right) {
            return arr[left - 1] + k - i;
        }
        right--;
    }
    return arr[right] + k;
}
```

Note that these solutions are optimized and have a time complexity of O(n).