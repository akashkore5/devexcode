---
id: "712262"
title: "Minimum days to make M bouquets"
slug: "minimum-days-to-make-m-bouquets"
difficulty: "Medium"
companyTags: []
tags: []
---

**Minimum days to make M bouquets**
================================

## Summary
Given an array of integers representing the number of flowers available each day, find the minimum number of days required to make `M` bouquets. Each bouquet requires a different set of flowers, and we can only use one type of flower per bouquet.

## Detailed Explanation
To solve this problem, we'll use a greedy algorithm that takes advantage of the fact that we can't reuse flowers across bouquets. We'll iterate through the array of integers and keep track of the minimum number of days required to make `M` bouquets.

Here's a step-by-step breakdown of the solution:

1. Initialize a variable `days` to 0, which will store the minimum number of days required.
2. Sort the array of integers in descending order (i.e., from largest to smallest).
3. Iterate through the sorted array, and for each day:
	* If the number of flowers available on that day is greater than or equal to `M`, set `days` to the current value + 1, since we can make at least one bouquet with those flowers.
	* Otherwise, continue to the next day.
4. Return the minimum number of days required (`days`) as the result.

Here's a diagram illustrating the algorithm:
```
          Day 1: [10]
          Day 2: [8]
          ...
          Day N: [x]
  +---------------+
  |       Make    |
  |  bouquets with  |
  |  available     |
  |  flowers (M)   |
  +---------------+
           ^
           | More days needed
           v
  Minimum days: 3
```
Time complexity analysis:
* Sorting the array has a time complexity of O(n log n).
* Iterating through the sorted array has a time complexity of O(n).
* Total time complexity is O(n log n).

Space complexity analysis:
* We only need to store the minimum number of days required, which has a space complexity of O(1).
* Total space complexity is O(1).

## Optimized Solutions
### Java
```java
public int minDays(int[] flowers) {
    Arrays.sort(flowers);
    int days = 0;
    for (int i = 0; i < flowers.length; i++) {
        if (flowers[i] >= M) {
            days++;
            M -= flowers[i];
        }
    }
    return days;
}
```
### Python
```python
def min_days(flowers):
    flowers.sort(reverse=True)
    days = 0
    for flower in flowers:
        if flower >= M:
            days += 1
            M -= flower
    return days
```
### C++
```cpp
int minDays(int* flowers, int n) {
    std::sort(flowers, flowers + n);
    int days = 0;
    for (int i = 0; i < n; i++) {
        if (flowers[i] >= M) {
            days++;
            M -= flowers[i];
        }
    }
    return days;
}
```
### JavaScript
```javascript
function minDays(flowers) {
    flowers.sort((a, b) => b - a);
    let days = 0;
    for (let i = 0; i < flowers.length; i++) {
        if (flowers[i] >= M) {
            days++;
            M -= flowers[i];
        }
    }
    return days;
}
```
Note: The `M` variable represents the number of bouquets to be made.