---
id: "700265"
title: "Merge K sorted linked lists"
slug: "merge-k-sorted-linked-lists"
difficulty: "Medium"
companyTags: ["VMWare", "Amazon", "Microsoft", "Oracle"]
tags: ["Linked List", "Heap", "Data Structures"]
---

# Merge K sorted linked lists
## Slug: merge-k-sorted-linked-lists
## Difficulty: Medium
## Id: 700265
## Topic Tags: Linked List, Heap, Data Structures
## Company Tags: VMWare, Amazon, Microsoft, Oracle

### Summary
Given k sorted linked lists, the task is to merge these lists into a single sorted linked list. This problem involves manipulating and combining multiple linked lists while maintaining their original order.

### Detailed Explanation
To solve this problem, we can use a priority queue or a heap data structure. The idea is to treat each node of the linked lists as an element in the priority queue. We continuously pop the smallest element from the priority queue and add it to our result list. This process continues until all elements are processed.

Here's a step-by-step breakdown of the solution:

1. Create a min-heap.
2. Insert all nodes from each of the k linked lists into the heap.
3. While the heap is not empty:
   - Extract the smallest node from the heap (which will be the next element in our result list).
   - If the extracted node has children, insert them into the heap.
   - Add the extracted node to our result list.
4. Once the heap is empty, return the result list.

### Optimized Solutions

#### Java
```java
import java.util.PriorityQueue;

public class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> queue = new PriorityQueue<>((a, b) -> a.val - b.val);
        
        for (ListNode node : lists) {
            if (node != null) {
                queue.offer(node);
            }
        }
        
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (!queue.isEmpty()) {
            ListNode node = queue.poll();
            current.next = node;
            current = current.next;
            
            if (node.next != null) {
                queue.offer(node.next);
            }
        }
        
        return dummy.next;
    }
}
```

#### Python
```python
import heapq

class Solution:
    def mergeKLists(self, lists):
        heap = []
        for node in lists:
            if node:
                heapq.heappush(heap, (node.val, node))
                
        dummy = ListNode(0)
        current = dummy
        
        while heap:
            val, node = heapq.heappop(heap)
            current.next = node
            current = current.next
            
            if node.next:
                heapq.heappush(heap, (node.next.val, node.next))
        
        return dummy.next
```

#### C++
```cpp
#include <queue>
#include <vector>

class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*> >, greater<pair<int, ListNode*> > > queue;
        
        for (ListNode* node : lists) {
            if (node != nullptr) {
                queue.push({node->val, node});
            }
        }
        
        ListNode dummy(0);
        ListNode* current = &dummy;
        
        while (!queue.empty()) {
            auto& pair = queue.top();
            queue.pop();
            
            current->next = pair.second;
            current = current->next;
            
            if (pair.second->next != nullptr) {
                queue.push({pair.second->next->val, pair.second->next});
            }
        }
        
        return dummy.next;
    }
};
```

#### JavaScript
```javascript
class Solution {
  mergeKLists(lists) {
    const heap = [];
    
    for (const node of lists) {
      if (node) {
        heap.push({ val: node.val, node });
      }
    }
    
    let dummy = { val: 0, next: null };
    let current = dummy;
    
    while (heap.length > 0) {
      const { val, node } = heap.shift();
      current.next = node;
      current = current.next;
      
      if (node.next) {
        heap.push({ val: node.next.val, node: node.next });
      }
    }
    
    return dummy.next;
  }
}
```
Time complexity: O(N log k), where N is the total number of nodes in all linked lists and k is the number of linked lists. The space complexity is O(k) for storing the priority queue.