---
id: "884343"
title: "Pair Sum in a Sorted and Rotated Array"
slug: "pair-sum-in-a-sorted-and-rotated-array"
difficulty: "Medium"
companyTags: []
tags: []
---

# Pair Sum in a Sorted and Rotated Array
Slug: pair-sum-in-a-sorted-and-rotated-array
Difficulty: Medium
Id: 884343

## Summary
Given an array that is sorted in ascending order, but has been rotated by some unknown number of positions, find all pairs of elements whose sum equals to a given target value. This problem requires understanding of binary search and two-pointer technique.

## Detailed Explanation
The problem can be solved using a combination of binary search and two-pointer technique. First, we need to find the pivot element in the rotated array. The pivot is the middle element that has been rotated. We do this by comparing the first and last elements of the array. If the first element is less than or equal to the last element, then the array is not rotated and the pivot is at the middle index. If the first element is greater than the last element, then the array is rotated and the pivot is one of the two ends (first or last).

Once we have found the pivot, we can use binary search on the left side of the pivot to find the pair with sum equal to the target value. We start by comparing the middle element of the left side with the target value. If the sum of the middle element and the next element is less than the target value, then we move towards the right half. If the sum of the middle element and the previous element is greater than the target value, then we move towards the left half. We repeat this process until we find the pair or reach the beginning or end of the array.

Here's a step-by-step breakdown:

1. Find the pivot element in the rotated array.
2. Use binary search on the left side of the pivot to find the pair with sum equal to the target value.
3. Compare the middle element and the next element, if the sum is less than the target value, move towards the right half.
4. If the sum is greater than the target value, move towards the left half.
5. Repeat steps 2-4 until you find the pair or reach the beginning or end of the array.

Time complexity: O(logn)
Space complexity: O(1)

## Optimized Solutions
### Java
```java
import java.util.*;

public class PairSum {
    public static List<int[]> findPairs(int[] nums, int target) {
        int pivot = findPivot(nums);
        List<int[]> pairs = new ArrayList<>();
        
        // Search on the left side of the pivot
        int left = 0;
        while (left < pivot) {
            if (binarySearch(nums, left, pivot - 1, target)) {
                pairs.add(new int[]{nums[left], target - nums[left]});
            }
            left++;
        }
        
        return pairs;
    }

    private static int findPivot(int[] nums) {
        if (nums[0] <= nums[nums.length - 1]) {
            return nums.length / 2;
        }
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] > nums[i + 1]) {
                return i;
            }
        }
        return nums.length - 1;
    }

    private static boolean binarySearch(int[] nums, int left, int right, int target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] * 2 == target) {
                return true;
            }
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }
}
```

### Python
```python
class PairSum:
    def find_pairs(self, nums, target):
        pivot = self.find_pivot(nums)
        pairs = []
        
        # Search on the left side of the pivot
        left = 0
        while left < pivot:
            if self.binary_search(nums, left, pivot - 1, target):
                pairs.append([nums[left], target - nums[left]])
            left += 1
        
        return pairs

    def find_pivot(self, nums):
        if nums[0] <= nums[-1]:
            return len(nums) // 2
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                return i
        return len(nums) - 1

    def binary_search(self, nums, left, right, target):
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] * 2 == target:
                return True
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return False
```

### C++
```cpp
#include <vector>
#include <algorithm>

class PairSum {
public:
    std::vector<std::vector<int>> findPairs(int* nums, int length, int target) {
        int pivot = findPivot(nums, length);
        std::vector<std::vector<int>> pairs;
        
        // Search on the left side of the pivot
        for (int i = 0; i < pivot; i++) {
            if (binarySearch(nums, i, pivot - 1, target)) {
                pairs.push_back({nums[i], target - nums[i]});
            }
        }
        
        return pairs;
    }

    int findPivot(int* nums, int length) {
        if (nums[0] <= nums[length - 1]) {
            return length / 2;
        }
        for (int i = 0; i < length - 1; i++) {
            if (nums[i] > nums[i + 1]) {
                return i;
            }
        }
        return length - 1;
    }

    bool binarySearch(int* nums, int left, int right, int target) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] * 2 == target) {
                return true;
            }
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return false;
    }
};
```

### JavaScript
```javascript
class PairSum {
  findPairs(nums, target) {
    const pivot = this.findPivot(nums);
    let pairs = [];
    
    // Search on the left side of the pivot
    for (let i = 0; i < pivot; i++) {
      if (this.binarySearch(nums, i, pivot - 1, target)) {
        pairs.push([nums[i], target - nums[i]]);
      }
    }
    
    return pairs;
  }

  findPivot(nums) {
    if (nums[0] <= nums[nums.length - 1]) {
      return Math.floor(nums.length / 2);
    }
    for (let i = 0; i < nums.length - 1; i++) {
      if (nums[i] > nums[i + 1]) {
        return i;
      }
    }
    return nums.length - 1;
  }

  binarySearch(nums, left, right, target) {
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (nums[mid] * 2 === target) {
        return true;
      }
      if (nums[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return false;
  }
}
```