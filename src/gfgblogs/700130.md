---
id: "700130"
title: "Split a Linked List into two halves"
slug: "split-a-circular-linked-list-into-two-halves"
difficulty: "Easy"
companyTags: ["Yahoo"]
tags: ["circular-linked-list", "Linked List", "Data Structures"]
---

**Split a Linked List into two halves**
==================================================

### Summary
This problem is about splitting a circular linked list into two halves. A circular linked list is a type of linked list where the last node points back to the first node, forming a circle. The goal is to divide the list into two halves such that each half contains roughly the same number of nodes.

### Detailed Explanation
To solve this problem, we can start by assuming we have a pointer at the beginning of the circular linked list. We then move the pointer along the list until it reaches the middle node (or the node just before the middle node if the total number of nodes is odd). 

Next, we set the second pointer to the starting point and move it forward until it meets the first pointer. This will give us two halves of roughly equal length.

Here's a step-by-step breakdown:

1. Initialize two pointers: one at the beginning of the list (`p1`) and another at the starting point (`p2`).
2. Move `p1` along the list until it reaches the middle node (or the node just before the middle node if the total number of nodes is odd). 
3. Set `p2` to the starting point.
4. Move `p2` forward until it meets `p1`. This will give us two halves of roughly equal length.

Time complexity: O(n), where n is the total number of nodes in the list.

Space complexity: O(1), as we only use a constant amount of space to store the pointers.

### Optimized Solutions

#### Java
```java
public class Solution {
    Node* splitList(Node* head) {
        if (head == null || head.next == head) return head;
        
        Node* slow = head;
        Node* fast = head;
        while (fast.next != head && fast.next.next != head) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        Node* newHead = slow.next;
        slow.next = null;
        return head;
    }
}
```

#### Python
```python
class Solution:
    def split_list(self, head):
        if not head or head.next == head: 
            return head
        
        slow = head
        fast = head
        while fast.next != head and fast.next.next != head:
            slow = slow.next
            fast = fast.next.next
        
        new_head = slow.next
        slow.next = None
        return head
```

#### C++
```cpp
class Solution {
public:
    Node* splitList(Node* head) {
        if (head == nullptr || head->next == head) return head;
        
        Node* slow = head;
        Node* fast = head;
        while (fast->next != head && fast->next->next != head) {
            slow = slow->next;
            fast = fast->next->next;
        }
        
        Node* newHead = slow->next;
        slow->next = nullptr;
        return head;
    }
};
```

#### JavaScript
```javascript
class Solution {
  splitList(head) {
    if (!head || head.next === head) return head;

    let slow = head;
    let fast = head;
    while (fast.next !== head && fast.next.next !== head) {
      slow = slow.next;
      fast = fast.next.next;
    }

    let newHead = slow.next;
    slow.next = null;
    return head;
  }
}
```
Note: The Node class represents a node in the linked list, with attributes for the data and the next pointer.