---
id: "710026"
title: "Largest rectangular sub-matrix whose sum is 0"
slug: "largest-rectangular-sub-matrix-whose-sum-is-0"
difficulty: "Hard"
companyTags: []
tags: ["prefix-sum", "Hash", "Dynamic Programming", "Matrix", "Data Structures", "Algorithms"]
---

# Largest rectangular sub-matrix whose sum is 0
## Slug: largest-rectangular-sub-matrix-whose-sum-is-0
## Difficulty: Hard
## Topic Tags: prefix-sum, Hash, Dynamic Programming, Matrix, Data Structures, Algorithms

### Summary
Given a two-dimensional matrix of integers, find the largest rectangular sub-matrix whose sum is 0. The problem can be viewed as finding all possible sub-matrices and then calculating their sums. Then, it's necessary to find the maximum size of those sub-matrices that have a sum equal to 0.

## Detailed Explanation
To solve this problem, we will use a prefix sum technique along with dynamic programming. The idea is to first calculate the prefix sum for each row in the matrix. This means that for each cell `matrix[i][j]`, we will store the sum of all elements above it (both on the left and right sides). Then, for each sub-matrix, we can calculate its sum by subtracting the prefix sum of the top-right corner from the prefix sum of the bottom-left corner. This way, we effectively eliminate the need to calculate the sum of each sub-matrix separately.

Here is a step-by-step breakdown of the solution:

1.  Initialize an array `prefix_sum` with the same number of rows as the input matrix.
2.  Iterate over each row in the input matrix and for each cell, update the corresponding prefix sum accordingly.
3.  Initialize variables to store the maximum size of the sub-matrix found so far and its top-left corner.
4.  Iterate over each possible sub-matrix (with varying sizes) starting from the top-left corner of the input matrix.
5.  For each sub-matrix, calculate its sum using the prefix sum technique described above.
6.  If the calculated sum is equal to 0 and the size of the sub-matrix is greater than the maximum size found so far, update the maximum size and the top-left corner of the sub-matrix.

Time complexity: O(m \* n), where m is the number of rows and n is the number of columns in the input matrix. This is because we are iterating over each cell in the matrix once.
Space complexity: O(m), as we need to store the prefix sum array for each row.

### Optimized Solutions

#### Java
```java
public class Solution {
    public int largestRectangle(int[][] matrix) {
        int rows = matrix.length;
        if (rows == 0) return 0;

        int cols = matrix[0].length;
        if (cols == 0) return 0;

        // Calculate prefix sum for each row
        int[] prefixSum = new int[cols + 1];
        for (int i = 0; i < rows; i++) {
            int sum = 0;
            for (int j = 0; j < cols; j++) {
                sum += matrix[i][j];
                prefixSum[j + 1] = sum;
            }
        }

        // Find the maximum size of rectangular sub-matrix
        int maxArea = 0, topRow = 0;
        for (int i = 0; i < rows; i++) {
            int[] rowPrefixSum = new int[cols + 1];
            for (int j = i; j < rows; j++) {
                // Calculate sum of the current sub-matrix
                int subMatrixSum = prefixSum[cols] - (j == i ? 0 : prefixSum[0]);
                for (int k = 0; k <= cols; k++) {
                    rowPrefixSum[k] = (k == 0 ? 0 : rowPrefixSum[k - 1]) + (prefixSum[k] - rowPrefixSum[k - 1]);
                }
                for (int j = 0; j < cols; j++) {
                    // Calculate sum of the current sub-matrix
                    int left = prefixSum[j];
                    int right = rowPrefixSum[cols] - rowPrefixSum[j];
                    if (left + right == 0) {
                        int area = (j + 1) * (rows - i);
                        if (area > maxArea) {
                            maxArea = area;
                            topRow = i;
                        }
                    }
                }
            }
        }

        return maxArea;
    }
}
```

#### Python
```python
def largest_rectangle(matrix):
    rows, cols = len(matrix), len(matrix[0])
    
    if not matrix:
        return 0

    # Calculate prefix sum for each row
    prefix_sum = [0] * (cols + 1)
    for i in range(rows):
        for j in range(cols):
            prefix_sum[j + 1] += matrix[i][j]
    
    max_area = 0, 0
    
    for i in range(rows):
        for j in range(i, rows):
            # Calculate sum of the current sub-matrix
            sub_matrix_sum = prefix_sum[cols] - (j == i or 0)
            row_prefix_sum = [0] * (cols + 1)
            for k in range(cols):
                row_prefix_sum[k] = row_prefix_sum[k - 1] if k > 0 else 0
            row_prefix_sum[cols] = prefix_sum[cols]
            
            for j in range(cols):
                # Calculate sum of the current sub-matrix
                left = prefix_sum[j]
                right = row_prefix_sum[cols] - row_prefix_sum[j]
                if left + right == 0:
                    area = (j + 1) * (rows - i)
                    if area > max_area[0]:
                        max_area = (area, i)
    
    return max_area[0]

```

#### C++
```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int largestRectangle(vector<vector<int>>& matrix) {
        int rows = matrix.size();
        if (rows == 0) return 0;

        int cols = matrix[0].size();
        if (cols == 0) return 0;

        // Calculate prefix sum for each row
        vector<int> prefixSum(cols + 1);
        for (int i = 0; i < rows; i++) {
            int sum = 0;
            for (int j = 0; j < cols; j++) {
                sum += matrix[i][j];
                prefixSum[j + 1] = sum;
            }
        }

        // Find the maximum size of rectangular sub-matrix
        int maxArea = 0, topRow = 0;
        for (int i = 0; i < rows; i++) {
            vector<int> rowPrefixSum(cols + 1);
            for (int j = i; j < rows; j++) {
                // Calculate sum of the current sub-matrix
                int subMatrixSum = prefixSum[cols] - (j == i ? 0 : prefixSum[0]);
                for (int k = 0; k <= cols; k++) {
                    rowPrefixSum[k] = (k == 0 ? 0 : rowPrefixSum[k - 1]) + (prefixSum[k] - rowPrefixSum[k - 1]);
                }
                for (int j = 0; j < cols; j++) {
                    // Calculate sum of the current sub-matrix
                    int left = prefixSum[j];
                    int right = rowPrefixSum[cols] - rowPrefixSum[j];
                    if (left + right == 0) {
                        int area = (j + 1) * (rows - i);
                        if (area > maxArea) {
                            maxArea = area;
                            topRow = i;
                        }
                    }
                }
            }
        }

        return maxArea;
    }
};
```

#### Java
```java
import java.util.List;

public class Solution {
    public int largestRectangle(int[][] matrix) {
        int rows = matrix.length;
        if (rows == 0) return 0;

        int cols = matrix[0].length;
        if (cols == 0) return 0;

        // Calculate prefix sum for each row
        int[] prefixSum = new int[cols + 1];
        for (int i = 0; i < rows; i++) {
            int sum = 0;
            for (int j = 0; j < cols; j++) {
                sum += matrix[i][j];
                prefixSum[j + 1] = sum;
            }
        }

        // Find the maximum size of rectangular sub-matrix
        int maxArea = 0, topRow = 0;
        for (int i = 0; i < rows; i++) {
            int[] rowPrefixSum = new int[cols + 1];
            for (int j = i; j < rows; j++) {
                // Calculate sum of the current sub-matrix
                int subMatrixSum = prefixSum[cols] - (j == i ? 0 : prefixSum[0]);
                for (int k = 0; k <= cols; k++) {
                    rowPrefixSum[k] = (k == 0 ? 0 : rowPrefixSum[k - 1]) + (prefixSum[k] - rowPrefixSum[k - 1]);
                }
                for (int j = 0; j < cols; j++) {
                    // Calculate sum of the current sub-matrix
                    int left = prefixSum[j];
                    int right = rowPrefixSum[cols] - rowPrefixSum[j];
                    if (left + right == 0) {
                        int area = (j + 1) * (rows - i);
                        if (area > maxArea) {
                            maxArea = area;
                            topRow = i;
                        }
                    }
                }
            }
        }

        return maxArea;
    }
}
```

This algorithm has a time complexity of O(n*m), where n is the number of rows in the matrix and m is the number of columns. The space complexity is O(1) since we only use a constant amount of space to store the prefix sum array.