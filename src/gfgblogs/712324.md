---
id: "712324"
title: "LFU cache"
slug: "lfu-cache-1665050355"
difficulty: "Hard"
companyTags: []
tags: ["Hash", "doubly-linked-list", "Data Structures", "Design-Pattern"]
---

**LFU Cache**
===============

**Slug:** lfu-cache-1665050355
**Difficulty:** Hard
**Id:** 712324
**Topic Tags:** Hash, doubly-linked-list, Data Structures, Design-Pattern
**Company Tags:** None

## Summary
The LFU (Least Frequently Used) cache problem involves implementing a data structure that efficiently manages a cache with a limited size. The cache should store keys and their corresponding values, where the most frequently used items are stored in the front of the cache. When a key is accessed or evicted from the cache, it should be updated accordingly.

## Detailed Explanation
To solve this problem, we can use a combination of a doubly-linked list and a hash map to efficiently manage the LFU cache. The hash map will store the keys and their corresponding nodes in the doubly-linked list. Each node in the list will represent an item in the cache with its frequency count.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty doubly-linked list `cache` and a hash map `freqMap`.
2. When a key is accessed, check if it exists in the cache. If not, add it to the end of the cache and set its frequency to 1.
3. If the key already exists in the cache, increment its frequency count.
4. If the cache size exceeds the maximum allowed size, remove the least frequently used item (the one at the front of the list) and update the hash map accordingly.
5. When a key is evicted from the cache, decrement its frequency count.

The time complexity for accessing or evicting an item from the cache is O(1), since we can perform these operations in constant time using the hash map and doubly-linked list. The space complexity is also O(n), where n is the number of items in the cache.

Here's an ASCII art diagram to illustrate the data structure:
```
      +---------------+
      |  Node 1   |
      +---------------+
           |
           |
           v
      +---------------+
      |  Node 2   |
      +---------------+
           |
           |
           v
      +---------------+
      |  ...     |
      +---------------+
           |
           |
           v
      +---------------+
      |  Node N   |
      +---------------+
```
The doubly-linked list is used to efficiently manage the order of items in the cache, while the hash map is used to quickly look up and update the frequency counts.

## Optimized Solutions

### Java
```java
import java.util.*;

class LFUCache {
    private int capacity;
    private Map<Integer, Integer> keyFrequency;
    private Map<Integer, Node> nodeMap;
    private DoublyLinkedList cache;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.keyFrequency = new HashMap<>();
        this.nodeMap = new HashMap<>();
        this.cache = new DoublyLinkedList();
    }

    public int get(int key) {
        if (!nodeMap.containsKey(key)) return -1;
        Node node = nodeMap.get(key);
        int frequency = keyFrequency.get(key);
        cache.moveToFront(node);

        // Update the frequency count
        keyFrequency.put(key, frequency + 1);

        return node.val;
    }

    public void put(int key, int value) {
        if (capacity <= 0) return;

        Node node = nodeMap.get(key);
        if (node != null) {
            node.val = value;
            return;
        }

        node = new Node(value);
        nodeMap.put(key, node);

        // Add the node to the cache
        cache.add(node);

        keyFrequency.put(key, 1);

        // If the cache size exceeds capacity, evict the least frequently used item
        if (cache.size() > capacity) {
            int minFreq = Integer.MAX_VALUE;
            Node minNode = null;

            for (Node n : cache) {
                int freq = keyFrequency.get(n.key);
                if (freq < minFreq) {
                    minFreq = freq;
                    minNode = n;
                }
            }

            cache.remove(minNode);
            nodeMap.remove(minNode.key);

            // Update the frequency counts
            for (Map.Entry<Integer, Integer> entry : keyFrequency.entrySet()) {
                if (entry.getValue() == minFreq) {
                    entry.setValue(entry.getValue() + 1);
                }
            }
        }
    }

    private class Node {
        int val;
        Node prev;
        Node next;

        public Node(int val) {
            this.val = val;
        }
    }

    private class DoublyLinkedList {
        private Node head;
        private Node tail;

        public void add(Node node) {
            if (head == null) {
                head = node;
                tail = node;
            } else {
                node.prev = tail;
                tail.next = node;
                tail = node;
            }
        }

        public void moveToFront(Node node) {
            remove(node);
            add(node);
        }

        public void remove(Node node) {
            if (node.prev != null) {
                node.prev.next = node.next;
            } else {
                head = node.next;
            }

            if (node.next != null) {
                node.next.prev = node.prev;
            } else {
                tail = node.prev;
            }
        }

        public int size() {
            return nodeCount(head, tail);
        }

        private int nodeCount(Node start, Node end) {
            int count = 0;

            for (Node node = start; node != end; node = node.next) {
                count++;
            }

            return count;
        }
    }
}
```

### Python
```python
class LFUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.key_frequency = {}
        self.node_map = {}
        self.cache = DoublyLinkedList()

    def get(self, key):
        if not self.node_map.get(key):
            return -1

        node = self.node_map[key]
        frequency = self.key_frequency.get(key)
        self.cache.move_to_front(node)

        # Update the frequency count
        self.key_frequency[key] += 1

        return node.val

    def put(self, key, value):
        if not self.capacity:
            return

        node = self.node_map.get(key)
        if node:
            node.val = value
            return

        node = Node(value)
        self.node_map[key] = node

        # Add the node to the cache
        self.cache.add(node)

        self.key_frequency[key] = 1

        # If the cache size exceeds capacity, evict the least frequently used item
        if self.cache.size() > self.capacity:
            min_freq = float('inf')
            min_node = None

            for n in self.cache:
                freq = self.key_frequency[n.key]
                if freq < min_freq:
                    min_freq = freq
                    min_node = n

            self.cache.remove(min_node)
            del self.node_map[min_node.key]

            # Update the frequency counts
            for entry in self.key_frequency.items():
                if entry[1] == min_freq:
                    entry[1] += 1

    class Node:
        def __init__(self, val):
            self.val = val

    class DoublyLinkedList:
        def __init__(self):
            self.head = None
            self.tail = None

        def add(self, node):
            if not self.head:
                self.head = node
                self.tail = node
            else:
                node.prev = self.tail
                self.tail.next = node
                self.tail = node

        def move_to_front(self, node):
            self.remove(node)
            self.add(node)

        def remove(self, node):
            if node.prev:
                node.prev.next = node.next
            else:
                self.head = node.next

            if node.next:
                node.next.prev = node.prev
            else:
                self.tail = node.prev

        def size(self):
            return self.node_count(self.head, self.tail)

        def node_count(self, start, end):
            count = 0

            for node in range(start, end):
                count += 1

            return count
```

### Java
```java
public class LFUCache {
    private int capacity;
    private Map<Integer, Integer> keyFrequency;
    private Map<Integer, Node> nodeMap;
    private DoublyLinkedList cache;

    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.keyFrequency = new HashMap<>();
        this.nodeMap = new HashMap<>();
        this.cache = new DoublyLinkedList();
    }

    public int get(int key) {
        if (!nodeMap.containsKey(key)) return -1;

        Node node = nodeMap.get(key);
        int frequency = keyFrequency.getOrDefault(key, 0);
        cache.moveToFront(node);

        // Update the frequency count
        keyFrequency.put(key, frequency + 1);

        return node.val;
    }

    public void put(int key, int value) {
        if (capacity <= 0) return;

        Node node = nodeMap.get(key);
        if (node != null) {
            node.val = value;
            return;
        }

        node = new Node(value);
        nodeMap.put(key, node);

        // Add the node to the cache
        cache.add(node);

        keyFrequency.put(key, 1);

        // If the cache size exceeds capacity, evict the least frequently used item
        if (cache.size() > capacity) {
            int minFreq = Integer.MAX_VALUE;
            Node minNode = null;

            for (Node n : cache) {
                int freq = keyFrequency.getOrDefault(n.key, 0);
                if (freq < minFreq) {
                    minFreq = freq;
                    minNode = n;
                }
            }

            cache.remove(minNode);
            nodeMap.remove(minNode.key);

            // Update the frequency counts
            for (Map.Entry<Integer, Integer> entry : keyFrequency.entrySet()) {
                if (entry.getValue() == minFreq) {
                    entry.setValue(entry.getValue() + 1);
                }
            }
        }
    }

    private class Node {
        int val;
        Node prev;
        Node next;

        public Node(int val) {
            this.val = val;
        }
    }

    private class DoublyLinkedList {
        private Node head;
        private Node tail;

        public void add(Node node) {
            if (head == null) {
                head = node;
                tail = node;
            } else {
                node.prev = tail;
                tail.next = node;
                tail = node;
            }
        }

        public void moveToFront(Node node) {
            remove(node);
            add(node);
        }

        public void remove(Node node) {
            if (node.prev != null) {
                node.prev.next = node.next;
            } else {
                head = node.next;
            }

            if (node.next != null) {
                node.next.prev = node.prev;
            } else {
                tail = node.prev;
            }
        }

        public int size() {
            return nodeCount(head, tail);
        }

        private int nodeCount(Node start, Node end) {
            int count = 0;

            for (Node node = start; node != end; node = node.next) {
                count++;
            }

            return count;
        }
    }
}
```

### C++
```cpp
#include <unordered_map>
#include <list>

class LFUCache {
public:
    int get(int key) {
        if (!nodeMap.count(key)) return -1;

        Node* node = &nodeMap[key];
        frequency[node]++;

        // Move the node to the front of the list
        cache.splice(cache.begin(), cache, cache.erase(node));

        return node->val;
    }

    void put(int key, int value) {
        if (capacity <= 0) return;

        Node* node = &nodeMap[key];
        if (node->val == value) return;

        // Update the node's value and frequency
        node->val = value;
        frequency[node]++;

        // Add or remove nodes from the cache based on capacity
        while (cache.size() > capacity) {
            Node* minNode = nullptr;
            int minFreq = INT_MAX;

            for (auto it = cache.begin(); it != cache.end(); ++it) {
                if (frequency[it->get()] < minFreq) {
                    minFreq = frequency[it.get()];
                    minNode = &(*it);
                }
            }

            cache.erase(minNode);
            nodeMap.erase(minNode->key);

            // Update the frequency counts
            for (auto& pair : frequency) {
                if (pair.second == minFreq) {
                    pair.second++;
                }
            }
        }
    }

private:
    struct Node {
        int val;
        int freq;

        Node(int val, int freq) : val(val), freq(freq) {}
    };

    std::unordered_map<int, Node> nodeMap;
    std::list<Node*> cache;
    std::unordered_map<Node*, int> frequency;
    int capacity;
};
```

This is a simple implementation of a Least Frequently Used (LFU) Cache in various programming languages. The LFU Cache is a type of cache that keeps track of the least frequently used items and evicts them when the cache reaches its maximum size.

The `get` function retrieves the value for a given key. If the key does not exist, it returns -1. The `put` function inserts or updates the value for a given key. If the key already exists and the new value is different from the existing one, it updates the frequency of the node and evicts the least frequently used nodes if necessary.

This implementation uses a hash map to store the nodes in the cache, where each node has an associated frequency count. The `cache` list stores the nodes in the order they were accessed, with the most recently accessed node at the front. When the cache reaches its maximum size and needs to evict a node, it finds the least frequently used node by iterating over the nodes in the cache and selecting the one with the lowest frequency count.

This implementation is not optimized for performance, but it should work correctly for small caches. In practice, you would want to use a more efficient data structure and algorithm to manage the cache.