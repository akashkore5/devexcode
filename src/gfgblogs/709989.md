---
id: "709989"
title: "Maximum Meetings in One Room"
slug: "maximum-meetings-in-one-room"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Greedy", "Sorting", "Data Structures", "Algorithms"]
---

**Maximum Meetings in One Room**
==================================================================

**Slug:** maximum-meetings-in-one-room
**Difficulty:** Medium
**Id:** 709989
**Topic Tags:** Arrays, Greedy, Sorting, Data Structures, Algorithms
**Company Tags:** None

## Summary
The problem is to find the maximum number of meetings that can be held in a single room given a list of meeting start and end times. The goal is to schedule as many meetings as possible without any conflicts.

## Detailed Explanation
To solve this problem, we will use a greedy approach with sorting. First, we sort all the meetings by their end times. Then, we iterate over the sorted meetings and select the ones that do not conflict with each other. A meeting does not conflict if its start time is greater than or equal to the end time of the previously selected meeting.

Here's a step-by-step breakdown:

1. Sort the meetings by their end times.
2. Initialize an empty list `scheduled_meetings` to store the scheduled meetings.
3. Iterate over the sorted meetings:
    * For each meeting, check if it does not conflict with the previously scheduled meetings (i.e., its start time is greater than or equal to the end time of the last scheduled meeting).
    * If the meeting does not conflict, add it to the `scheduled_meetings` list.
4. Return the length of the `scheduled_meetings` list as the maximum number of meetings that can be held.

Time complexity: O(n log n) due to sorting
Space complexity: O(n) for storing the scheduled meetings

## Optimized Solutions
### Java
```java
import java.util.Arrays;
import java.util.List;

public class MaximumMeetings {
    public static int maxMeetings(int[][] meetings) {
        Arrays.sort(meetings, (a, b) -> a[1] - b[1]);
        List<int[]> scheduledMeetings = new ArrayList<>();
        int lastEndTime = 0;
        for (int[] meeting : meetings) {
            if (meeting[0] >= lastEndTime) {
                scheduledMeetings.add(meeting);
                lastEndTime = meeting[1];
            }
        }
        return scheduledMeetings.size();
    }
}
```

### Python
```python
def max_meetings(meetings):
    meetings.sort(key=lambda x: x[1])
    scheduled_meetings = []
    last_end_time = 0
    for meeting in meetings:
        if meeting[0] >= last_end_time:
            scheduled_meetings.append(meeting)
            last_end_time = meeting[1]
    return len(scheduled_meetings)
```

### C++
```cpp
#include <algorithm>
#include <vector>

int maxMeetings(std::vector<std::pair<int, int>>& meetings) {
    std::sort(meetings.begin(), meetings.end(), [](const auto& a, const auto& b) { return a.second < b.second; });
    std::vector<std::pair<int, int>> scheduledMeetings;
    int lastEndTime = 0;
    for (const auto& meeting : meetings) {
        if (meeting.first >= lastEndTime) {
            scheduledMeetings.push_back(meeting);
            lastEndTime = meeting.second;
        }
    }
    return scheduledMeetings.size();
}
```

### JavaScript
```javascript
function maxMeetings(meetings) {
  meetings.sort((a, b) => a[1] - b[1]);
  let scheduledMeetings = [];
  let lastEndTime = 0;
  for (const meeting of meetings) {
    if (meeting[0] >= lastEndTime) {
      scheduledMeetings.push(meeting);
      lastEndTime = meeting[1];
    }
  }
  return scheduledMeetings.length;
}
```