---
id: "712383"
title: "Number of Longest Increasing Subsequence"
slug: "number-of-longest-increasing-subsequence"
difficulty: "Medium"
companyTags: []
tags: []
---

Here is the detailed Markdown blog post for the problem:

# Number of Longest Increasing Subsequence
## Summary

Given an array of integers, find the number of longest increasing subsequences (LIS) in the array. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.

The key concept involved is dynamic programming.

## Detailed Explanation

To solve this problem, we will use dynamic programming to find the number of longest increasing subsequences (LIS) in the array. The idea is to create a 2D array `dp` where `dp[i][j]` represents whether there exists an increasing subsequence with length `j` ending at index `i`.

Here's the step-by-step breakdown:

1. Initialize a 2D array `dp` of size `(n x (max + 1))`, where `n` is the length of the input array and `max` is the maximum value in the array.
2. Iterate through the array from left to right:
	* For each element at index `i`, iterate from `j = 1` to `max`:
		+ Check if there exists an increasing subsequence with length `j-1` ending at index `i-1`. If yes, and the current element is greater than or equal to the last element of that subsequence, then update `dp[i][j]` to `dp[i-1][j-1] + 1`.
		+ If no such subsequence exists, set `dp[i][j] = 0`.
3. The value at `dp[n-1][max]` represents the number of longest increasing subsequences (LIS) in the array.

Time complexity: O(n \* max)
Space complexity: O(n \* max)

## Optimized Solutions

### Java
```java
public int findNumberLongestIncreasingSubsequence(int[] arr) {
    int n = arr.length;
    int max = Arrays.stream(arr).max().getAsInt();
    int[][] dp = new int[n][max + 1];
    
    for (int i = 0; i < n; i++) {
        for (int j = 1; j <= max; j++) {
            if (i == 0 || arr[i] >= arr[i-1]) {
                dp[i][j] = (dp[i-1][j-1] > 0) ? dp[i-1][j-1] + 1 : 0;
            } else {
                dp[i][j] = 0;
            }
        }
    }
    
    return dp[n-1][max];
}
```

### Python
```python
def find_number_longest_increasing_subsequence(arr):
    n = len(arr)
    max_val = max(arr)
    dp = [[0] * (max_val + 1) for _ in range(n)]
    
    for i in range(n):
        for j in range(1, max_val + 1):
            if i == 0 or arr[i] >= arr[i-1]:
                dp[i][j] = dp[i-1][j-1] + 1 if dp[i-1][j-1] > 0 else 0
            else:
                dp[i][j] = 0
    
    return dp[-1][-1]
```

### C++
```cpp
#include <vector>
using namespace std;

int findNumberLongestIncreasingSubsequence(vector<int>& arr) {
    int n = arr.size();
    int max_val = *max_element(arr.begin(), arr.end());
    vector<vector<int>> dp(n, vector<int>(max_val + 1));
    
    for (int i = 0; i < n; i++) {
        for (int j = 1; j <= max_val; j++) {
            if (i == 0 || arr[i] >= arr[i-1]) {
                dp[i][j] = (dp[i-1][j-1] > 0) ? dp[i-1][j-1] + 1 : 0;
            } else {
                dp[i][j] = 0;
            }
        }
    }
    
    return dp[n-1][max_val];
}
```

### JavaScript
```javascript
function findNumberLongestIncreasingSubsequence(arr) {
    let n = arr.length;
    let max_val = Math.max(...arr);
    let dp = new Array(n).fill(0).map(() => new Array(max_val + 1).fill(0));
    
    for (let i = 0; i < n; i++) {
        for (let j = 1; j <= max_val; j++) {
            if (i === 0 || arr[i] >= arr[i-1]) {
                dp[i][j] = (dp[i-1][j-1] > 0) ? dp[i-1][j-1] + 1 : 0;
            } else {
                dp[i][j] = 0;
            }
        }
    }
    
    return dp[n-1][max_val];
}
```

Note: The optimized solutions are provided in the corresponding programming languages.