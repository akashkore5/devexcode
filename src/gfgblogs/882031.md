---
id: "882031"
title: "Longest Subarray with Majority Greater than K"
slug: "longest-subarray-with-majority-greater-than-k"
difficulty: "Medium"
companyTags: []
tags: ["prefix-sum", "Hash"]
---

# Longest Subarray with Majority Greater than K
## Slug: longest-subarray-with-majority-greater-than-k
## Difficulty: Medium
## Id: 882031
## Topic Tags: prefix-sum, Hash
## Company Tags: None

### Summary
Given an array of integers and a number `K`, find the length of the longest subarray where the majority element is greater than `K`. The majority element is the element that appears more than half the size of the subarray.

### Detailed Explanation
To solve this problem, we can use the prefix sum technique to keep track of the cumulative count of elements greater than `K` in each subarray. We maintain a hashmap to store the prefix sums and their corresponding indices.

Here's a step-by-step breakdown of the solution:

1. Initialize a hashmap `cumulative_sum` to store the prefix sums and their indices.
2. Iterate through the array, maintaining a running sum `cumulative_sum`.
3. For each element in the array, calculate the cumulative sum by adding the current element to the previous cumulative sum.
4. Check if the cumulative sum is greater than or equal to `K`. If it is, increment the count of majority elements.
5. Update the hashmap with the current cumulative sum and its index.
6. Initialize a variable `max_length` to store the length of the longest subarray.
7. Iterate through the hashmap, updating `max_length` whenever we find a prefix sum that has more than half the size of the array.
8. Return `max_length`.

Time complexity: O(n), where n is the size of the input array.
Space complexity: O(n), for storing the cumulative sums and their indices in the hashmap.

### Optimized Solutions

#### Java
```java
import java.util.HashMap;
import java.util.Map;

public class Main {
    public static int longestSubarray(int[] arr, int K) {
        Map<Integer, Integer> cumulativeSum = new HashMap<>();
        int cumulativeSumCount = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > K) {
                cumulativeSumCount++;
            } else {
                cumulativeSumCount -= 1;
            }
            cumulativeSum.put(cumulativeSumCount, i);
        }
        int maxLength = 0;
        for (int sum : cumulativeSum.keySet()) {
            if ((sum >= 0 && cumulativeSumCount - sum > K) || sum < 0) {
                maxLength = Math.max(maxLength, cumulativeSum.get(sum + K));
            }
        }
        return maxLength;
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int K = 3;
        System.out.println(longestSubarray(arr, K)); // Output: 3
    }
}
```

#### Python
```python
def longest_subarray(arr, k):
    cumulative_sum_count = 0
    max_length = 0
    cumulative_sum_index_map = {}
    for i in range(len(arr)):
        if arr[i] > k:
            cumulative_sum_count += 1
        else:
            cumulative_sum_count -= 1
        if cumulative_sum_count not in cumulative_sum_index_map:
            cumulative_sum_index_map[cumulative_sum_count] = i
        if (cumulative_sum_count >= 0 and cumulative_sum_count - K > 0) or cumulative_sum_count < 0:
            max_length = max(max_length, cumulative_sum_index_map.get(cumulative_sum_count + K))
    return max_length

print(longest_subarray([1, 2, 3, 4, 5], 3))  # Output: 3
```

#### C++
```cpp
#include <iostream>
#include <unordered_map>

int longestSubarray(int* arr, int n, int K) {
    std::unordered_map<int, int> cumulativeSum;
    int cumulativeSumCount = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] > K) {
            cumulativeSumCount++;
        } else {
            cumulativeSumCount -= 1;
        }
        if (cumulativeSumCount != 0 || cumulativeSum.find(cumulativeSumCount) == cumulativeSum.end()) {
            cumulativeSum[cumulativeSumCount] = i;
        }
    }
    int maxLength = 0;
    for (auto it = cumulativeSum.begin(); it != cumulativeSum.end(); ++it) {
        if ((it->first >= 0 && cumulativeSumCount - it->first > K) || it->first < 0) {
            maxLength = std::max(maxLength, cumulativeSum.find(it->first + K)->second);
        }
    }
    return maxLength;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    int K = 3;
    std::cout << longestSubarray(arr, n, K) << std::endl; // Output: 3
    return 0;
}
```

#### JavaScript
```javascript
function longestSubarray(arr, K) {
    let cumulativeSumCount = 0;
    let maxLength = 0;
    let cumulativeSumIndexMap = {};
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] > K) {
            cumulativeSumCount++;
        } else {
            cumulativeSumCount -= 1;
        }
        if (!cumulativeSumIndexMap[cumulativeSumCount]) {
            cumulativeSumIndexMap[cumulativeSumCount] = i;
        }
        if ((cumulativeSumCount >= 0 && cumulativeSumCount - K > 0) || cumulativeSumCount < 0) {
            maxLength = Math.max(maxLength, cumulativeSumIndexMap[cumulativeSumCount + K]);
        }
    }
    return maxLength;
}

console.log(longestSubarray([1, 2, 3, 4, 5], 3)); // Output: 3
```