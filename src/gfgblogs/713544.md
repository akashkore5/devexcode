---
id: "713544"
title: "Intersection Point in Y Shaped Linked Lists"
slug: "intersection-point-in-y-shaped-linked-lists--170645"
difficulty: "Medium"
companyTags: ["VMWare", "Flipkart", "Accolite", "Amazon", "Microsoft", "Snapdeal", "D-E-Shaw", "FactSet", "MakeMyTrip", "Visa", "Goldman Sachs", "MAQ Software", "Adobe", "Qualcomm"]
tags: ["Linked List", "Data Structures"]
---

**Intersection Point in Y Shaped Linked Lists**
=====================================================

## Summary
The problem involves finding the intersection point between two linked lists that are part of a larger "Y" shaped structure. The two linked lists share a common node, but their lengths may vary. The goal is to find this shared node.

## Detailed Explanation
The approach to solve this problem is to first find the length of both linked lists by counting the number of nodes in each list. Then, we can adjust the pointers of one of the lists so that it starts at a point where both lists are aligned, effectively allowing us to compare the nodes from both lists simultaneously.

Here's a step-by-step breakdown:

1. Find the lengths of both linked lists using a simple loop.
2. Adjust the pointer of one of the lists (let's say `list1`) so that it points to the node at a distance equal to the length difference between the two lists minus 1. This is because we want to align the pointers in such a way that they point to the same node when `list1` and `list2` are traversed simultaneously.
3. Now, traverse both linked lists simultaneously using two pointers (`p1` for `list1` and `p2` for `list2`). As long as `p1` and `p2` are not equal (i.e., they don't point to the same node), move them forward one step each.
4. When `p1` and `p2` become equal, it means we have found the intersection point.

Time complexity: O(N + M) where N and M are the lengths of the two linked lists.
Space complexity: O(1) as no extra space is used.

```
          list1     |       list2
         /         \        /
        /           \      /
  +----+--------+   +----+--------+
  |     |       |   |     |       |
  |  A  | B C D |   |  E  | F G H I |
  +----+--------+   +----+--------+

```

In this example, the intersection point is node `E`. The lengths of the two linked lists are 5 and 3 respectively. We adjust the pointer of one of the lists so that it points to the node at a distance equal to the length difference minus 1 (in this case, 2 nodes ahead). Then, we traverse both lists simultaneously until we find the intersection point.

## Optimized Solutions
### Java
```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) return null;

    int lenA = 0;
    int lenB = 0;

    ListNode p1 = headA;
    while (p1 != null) {
        lenA++;
        p1 = p1.next;
    }

    ListNode p2 = headB;
    while (p2 != null) {
        lenB++;
        p2 = p2.next;
    }

    p1 = headA;
    for (int i = 0; i < lenA - lenB; i++) {
        p1 = p1.next;
    }

    p2 = headB;
    for (int i = 0; i < lenB - lenA; i++) {
        p2 = p2.next;
    }

    while (p1 != null && p2 != null) {
        if (p1 == p2) return p1;
        p1 = p1.next;
        p2 = p2.next;
    }

    return null;
}
```

### Python
```python
def get_intersection_node(headA, headB):
    if not headA or not headB:
        return None

    len_a = 0
    len_b = 0

    p1 = headA
    while p1:
        len_a += 1
        p1 = p1.next

    p2 = headB
    while p2:
        len_b += 1
        p2 = p2.next

    p1 = headA
    for _ in range(len_a - len_b):
        p1 = p1.next

    p2 = headB
    for _ in range(len_b - len_a):
        p2 = p2.next

    while p1 and p2:
        if p1 == p2:
            return p1
        p1 = p1.next
        p2 = p2.next

    return None
```

### C++
```cpp
ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    if (!headA || !headB)
        return nullptr;

    int lenA = 0;
    int lenB = 0;

    ListNode* p1 = headA;
    while (p1 != nullptr) {
        lenA++;
        p1 = p1->next;
    }

    ListNode* p2 = headB;
    while (p2 != nullptr) {
        lenB++;
        p2 = p2->next;
    }

    p1 = headA;
    for (int i = 0; i < lenA - lenB; i++) {
        p1 = p1->next;
    }

    p2 = headB;
    for (int i = 0; i < lenB - lenA; i++) {
        p2 = p2->next;
    }

    while (p1 != nullptr && p2 != nullptr) {
        if (p1 == p2)
            return p1;
        p1 = p1->next;
        p2 = p2->next;
    }

    return nullptr;
}
```

### JavaScript
```javascript
function getIntersectionNode(headA, headB) {
  if (!headA || !headB)
    return null;

  let lenA = 0;
  let lenB = 0;

  let p1 = headA;
  while (p1) {
    lenA++;
    p1 = p1.next;
  }

  let p2 = headB;
  while (p2) {
    lenB++;
    p2 = p2.next;
  }

  p1 = headA;
  for (let i = 0; i < lenA - lenB; i++) {
    p1 = p1.next;
  }

  p2 = headB;
  for (let i = 0; i < lenB - lenA; i++) {
    p2 = p2.next;
  }

  while (p1 && p2) {
    if (p1 === p2)
      return p1;
    p1 = p1.next;
    p2 = p2.next;
  }

  return null;
}
```

These optimized solutions have the same time and space complexity as the detailed explanation, which is O(N + M) and O(1), respectively.