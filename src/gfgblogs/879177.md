---
id: "879177"
title: "Insertion in deque"
slug: "insertion-in-deque--141904"
difficulty: "Basic"
companyTags: []
tags: ["Java", "Queue", "STL", "Java-Collections", "Data Structures"]
---

**Insertion in deque**
=====================

## Summary
Insertion in a deque (double-ended queue) is a fundamental operation that involves adding an element at either end of the data structure. This problem focuses on efficiently inserting elements into a deque, highlighting key concepts like queue operations and STL (Standard Template Library) usage.

## Detailed Explanation
To solve this problem, we'll employ the `std::deque` class from the C++ Standard Template Library, which provides efficient insertion and deletion at both ends. Our goal is to write a function that inserts an element into the deque at a specified position.

### Algorithmic Approach

1.  Check if the given position is within the valid range (i.e., not exceeding the size of the deque). If it's invalid, return an error or handle it accordingly.
2.  Calculate the actual position to be used for insertion by considering wrap-around behavior at both ends. For example, if the desired position is greater than the current size, consider inserting at the beginning (front) of the deque, and vice versa.
3.  Use the `std::deque::insert` method to insert the element at the calculated position.

### Time Complexity Analysis

The time complexity for this operation depends on the insertion position:

*   If the desired position is within the existing size of the deque, the time complexity remains O(1), as only a single element needs to be shifted.
*   When inserting at either end (front or back), the time complexity becomes O(k), where k is the distance from the current end to the desired insertion point. This occurs when the deque grows by shifting existing elements.

### Space Complexity Analysis

The space complexity remains constant, as we only use additional memory for the inserted element itself, independent of the size of the deque.

## Optimized Solutions
Here are optimized solutions in various programming languages:

### #### Java
```java
import java.util.Deque;
import java.util.LinkedList;

public class InsertionInDeque {
    public static void insertAtPosition(Deque<Integer> deque, int position, int element) {
        if (position > deque.size()) {
            // Handle invalid position or wrap-around at the beginning
            deque.addFirst(element);
        } else {
            // Calculate actual position for insertion
            int actualPosition = position % deque.size();
            // Use std::deque::insert to insert the element at the calculated position
            if (actualPosition == 0) {
                deque.addFirst(element);
            } else {
                deque.addLast(element);
            }
        }
    }
}
```

### #### Python
```python
from collections import deque

def insertion_in_deque(deque, position, element):
    if position > len(deque):
        # Handle invalid position or wrap-around at the beginning
        deque.appendleft(element)
    else:
        actual_position = position % len(deque)
        if actual_position == 0:
            deque.appendleft(element)
        else:
            deque.append(element)
```

### #### C++
```cpp
#include <deque>
#include <iostream>

void insertionInDeque(std::deque<int>& deque, int position, int element) {
    if (position > deque.size()) {
        // Handle invalid position or wrap-around at the beginning
        deque.push_front(element);
    } else {
        int actualPosition = position % deque.size();
        if (actualPosition == 0) {
            deque.push_front(element);
        } else {
            deque.push_back(element);
        }
    }
}
```

### #### JavaScript
```javascript
class InsertionInDeque {
    static insertAtPosition(deque, position, element) {
        if (position > deque.length) {
            // Handle invalid position or wrap-around at the beginning
            deque.unshift(element);
        } else {
            const actualPosition = position % deque.length;
            if (actualPosition === 0) {
                deque.unshift(element);
            } else {
                deque.push(element);
            }
        }
    }
}
```

These optimized solutions demonstrate efficient insertion in a deque, taking into account wrap-around behavior at both ends and considering the size of the deque.