---
id: "700013"
title: "Linked List Group Reverse"
slug: "reverse-a-linked-list-in-groups-of-given-size"
difficulty: "Hard"
companyTags: ["Paytm", "VMWare", "Accolite", "Amazon", "Microsoft", "Snapdeal", "Hike", "MakeMyTrip", "Walmart", "Goldman Sachs", "Adobe", "SAP Labs"]
tags: ["Linked List", "Data Structures"]
---

# Reverse a Linked List in Groups of Given Size

## Slug: reverse-a-linked-list-in-groups-of-given-size

## Difficulty: Hard

## Topic Tags: Linked List, Data Structures

## Company Tags: Paytm, VMWare, Accolite, Amazon, Microsoft, Snapdeal, Hike, MakeMyTrip, Walmart, Goldman Sachs, Adobe, SAP Labs

## Summary
Given a linked list and an integer k, reverse the linked list in groups of size k. If the length of the linked list is not divisible by k, the remaining elements should be reversed as well.

This problem involves manipulating a linked list using recursion or iteration, while also considering the size of the groups to be reversed.

## Detailed Explanation
The algorithm for this problem can be implemented using either recursion or iteration. We will use an iterative approach for simplicity and clarity.

Here's a step-by-step breakdown of the solution:

1. Initialize three pointers: `prev`, `curr`, and `next`. Set `prev` to `NULL` and `curr` to the head of the linked list.
2. Loop through the linked list in groups of size k:
   - Set `count` to 0. This variable will keep track of the number of nodes in each group.
   - Loop until `count` is less than or equal to k:
     - Move the `curr` pointer to the next node in the linked list (`curr = curr->next;`).
     - Increment `count`.
   - When `count` is greater than or equal to k, reverse the current group of nodes:
     - Set a temporary pointer `temp` to `prev`. This will keep track of the previous node.
     - Move the `curr` pointer back to the start of the group (`curr = prev->next;`).
     - Loop until the end of the group is reached:
       - Set the next pointer of each node in the group to the previous node (`temp->next = curr;`).
       - Move the `temp` and `curr` pointers one step forward.
     - Reset `count` to 0.
   - If there are remaining nodes that were not part of a complete group (i.e., `count < k`), reverse these nodes as well:
     - Set `prev` to the last node in the group (`prev = curr;`).
     - Move the `curr` pointer to the next node in the linked list (`curr = curr->next;`).
     - Loop until the end of the remaining nodes is reached:
       - Set the next pointer of each node to the previous node (`prev->next = curr;`).
       - Move the `prev` and `curr` pointers one step forward.
3. Return the modified linked list.

The time complexity for this algorithm is O(n), where n is the length of the linked list, since we are traversing the linked list once. The space complexity is O(1), since we are using a constant amount of extra space to store the temporary pointer and other variables.

## Optimized Solutions

### Java
```java
public class Solution {
    public ListNode reverseBetween(ListNode head, int k) {
        if (head == null || k < 1) {
            return head;
        }
        
        int count = 0;
        ListNode prev = null;
        ListNode curr = head;
        
        while (count < k - 1) {
            prev = curr;
            curr = curr.next;
            count++;
        }
        
        ListNode start = curr;
        ListNode end = curr;
        
        while (end.next != null) {
            end = end.next;
        }
        
        while (curr != end) {
            ListNode nextNode = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextNode;
        }
        
        start.next = end;
        
        return head;
    }
}
```

### Python
```python
class Solution:
    def reverseBetween(self, head: ListNode, k: int) -> ListNode:
        if not head or k < 1:
            return head
        
        count = 0
        prev = None
        curr = head
        
        while count < k - 1:
            prev = curr
            curr = curr.next
            count += 1
        
        start = curr
        end = curr
        
        while end.next is not None:
            end = end.next
        
        while curr != end:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        
        start.next = end
        
        return head
```

### C++
```cpp
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int k) {
        if (head == nullptr || k < 1) {
            return head;
        }
        
        int count = 0;
        ListNode* prev = nullptr;
        ListNode* curr = head;
        
        while (count < k - 1) {
            prev = curr;
            curr = curr->next;
            count++;
        }
        
        ListNode* start = curr;
        ListNode* end = curr;
        
        while (end->next != nullptr) {
            end = end->next;
        }
        
        while (curr != end) {
            ListNode* nextNode = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextNode;
        }
        
        start->next = end;
        
        return head;
    }
};
```

### JavaScript
```javascript
class Solution {
  reverseBetween(head, k) {
    if (!head || k < 1) {
      return head;
    }
    
    let count = 0;
    let prev = null;
    let curr = head;
    
    while (count < k - 1) {
      prev = curr;
      curr = curr.next;
      count++;
    }
    
    let start = curr;
    let end = curr;
    
    while (end.next !== null) {
      end = end.next;
    }
    
    while (curr !== end) {
      let nextNode = curr.next;
      curr.next = prev;
      prev = curr;
      curr = nextNode;
    }
    
    start.next = end;
    
    return head;
  }
}
```
Note that the code blocks are marked with the corresponding language tags (`java`, `python`, `cpp`, and `javascript`).