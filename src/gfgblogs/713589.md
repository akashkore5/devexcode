---
id: "713589"
title: "Balloon Everywhere"
slug: "balloon-everywhere--170646"
difficulty: "Easy"
companyTags: []
tags: ["Map", "Data Structures"]
---

**Balloon Everywhere**
=====================

**Slug:** balloon-everywhere--170646
**Difficulty:** Easy
**Id:** 713589
**Topic Tags:** Map, Data Structures
**Company Tags:** None

## Summary
Given a map with certain cells marked as having balloons, the task is to find the number of ways to place a new balloon at each cell such that no two adjacent cells have a balloon. The problem involves mapping and data structures.

## Detailed Explanation
The approach to this problem is to use dynamic programming. We can start by initializing a 2D array `dp` where `dp[i][j]` represents the number of ways to place balloons at cell `(i, j)`. Then we iterate over each cell in the map and for each cell, we consider all possible directions (up, down, left, right). If the adjacent cell has no balloon, we add 1 to the current value of `dp[i][j]` because we can place a new balloon at this cell. Finally, we return the sum of values in the last row or column of `dp`, which represents the total number of ways to place balloons.

Here is an ASCII art diagram representing the map:
```
 1 | 2 | 3
 ---------
4 | X | 6
 ---------
7 | 8 | 9
```
In this example, cell `(4, 5)` has a balloon (marked as `X`). We want to find the number of ways to place balloons at each cell such that no two adjacent cells have a balloon.

Time complexity: O(m * n), where m is the number of rows and n is the number of columns in the map. Space complexity: O(m * n) for the dynamic programming array `dp`.

## Optimized Solutions
### Java
```java
public int balloonEverywhere(int[][] map) {
    int m = map.length, n = map[0].length;
    int[][] dp = new int[m][n];
    
    // Initialize dp array
    for (int i = 0; i < m; i++) {
        if (i == 0) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = map[i][j] ? 0 : 1;
            }
        } else {
            for (int j = 0; j < n; j++) {
                if (map[i][j] == 0) {
                    dp[i][j] = dp[i - 1][j] + 1;
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
    }
    
    // Calculate total number of ways
    int totalWays = 0;
    for (int i = 0; i < n; i++) {
        totalWays += dp[m - 1][i];
    }
    
    return totalWays;
}
```

### Python
```python
def balloon_everywhere(map):
    m, n = len(map), len(map[0])
    dp = [[0] * n for _ in range(m)]
    
    # Initialize dp array
    for i in range(m):
        if i == 0:
            for j in range(n):
                dp[i][j] = int(not map[i][j])
        else:
            for j in range(n):
                if not map[i][j]:
                    dp[i][j] = dp[i - 1][j] + 1
                else:
                    dp[i][j] = dp[i - 1][j]
    
    # Calculate total number of ways
    total_ways = 0
    for i in range(n):
        total_ways += dp[m - 1][i]
    
    return total_ways
```

### C++
```cpp
int balloonEverywhere(int **map, int m, int n) {
    int** dp = new int*[m];
    for (int i = 0; i < m; i++) {
        dp[i] = new int[n];
    }
    
    // Initialize dp array
    for (int i = 0; i < m; i++) {
        if (i == 0) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = map[i][j] ? 0 : 1;
            }
        } else {
            for (int j = 0; j < n; j++) {
                if (map[i][j] == 0) {
                    dp[i][j] = dp[i - 1][j] + 1;
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
    }
    
    // Calculate total number of ways
    int totalWays = 0;
    for (int i = 0; i < n; i++) {
        totalWays += dp[m - 1][i];
    }
    
    // Free memory
    for (int i = 0; i < m; i++) {
        delete[] dp[i];
    }
    delete[] dp;
    
    return totalWays;
}
```

### JavaScript
```javascript
function balloonEverywhere(map) {
    let m = map.length, n = map[0].length;
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
    
    // Initialize dp array
    for (let i = 0; i < m; i++) {
        if (i == 0) {
            for (let j = 0; j < n; j++) {
                dp[i][j] = map[i][j] ? 0 : 1;
            }
        } else {
            for (let j = 0; j < n; j++) {
                if (!map[i][j]) {
                    dp[i][j] = dp[i - 1][j] + 1;
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
    }
    
    // Calculate total number of ways
    let totalWays = 0;
    for (let i = 0; i < n; i++) {
        totalWays += dp[m - 1][i];
    }
    
    return totalWays;
}
```