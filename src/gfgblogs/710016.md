---
id: "710016"
title: "Buy Maximum Stocks"
slug: "buy-maximum-stocks-if-i-stocks-can-be-bought-on-i-th-day"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

**Buy Maximum Stocks**
=====================

**Slug:** buy-maximum-stocks-if-i-stocks-can-be-bought-on-i-th-day
**Difficulty:** Medium
**Id:** 710016
**Topic Tags:** Arrays, Data Structures
**Company Tags:** None

## Summary
Given an array of integers `prices` representing the stock prices on each day from `i` to `n`, where `i` is a given integer, find the maximum number of stocks that can be bought such that at most one stock can be bought on any day.

The problem requires understanding arrays and data structures concepts. The key idea is to identify the days when the price drops to buy the stock and maximize the profit.

## Detailed Explanation
To solve this problem, we need to iterate through the array of prices and keep track of the maximum number of stocks that can be bought. We start by initializing a variable `max_stocks` to 0, which represents the maximum number of stocks that can be bought so far. Then, we iterate through the array from day `i` to day `n`.

For each day `j`, if the price is lower than the previous day's price, it means the stock price has dropped, and we can buy a new stock. In this case, we increment `max_stocks` by 1.

Here's the step-by-step breakdown of the solution:

```
max_stocks = 0
prev_price = prices[i - 1]
for j in range(i, n + 1):
    if prices[j - 1] < prev_price:
        max_stocks += 1
    prev_price = prices[j - 1]
```

The time complexity of this solution is O(n), where `n` is the number of days. This is because we need to iterate through the array once.

The space complexity is O(1), as we only use a constant amount of space to store the variables `max_stocks` and `prev_price`.

## Optimized Solutions

### Java
```java
public int maxStocks(int[] prices, int i) {
    int maxStocks = 0;
    int prevPrice = prices[i - 1];
    for (int j = i; j <= prices.length; j++) {
        if (prices[j - 1] < prevPrice) {
            maxStocks++;
        }
        prevPrice = prices[j - 1];
    }
    return maxStocks;
}
```

### Python
```python
def max_stocks(prices, i):
    max_stocks = 0
    prev_price = prices[i - 1]
    for j in range(i, len(prices) + 1):
        if prices[j - 1] < prev_price:
            max_stocks += 1
        prev_price = prices[j - 1]
    return max_stocks
```

### C++
```cpp
int maxStocks(int* prices, int i) {
    int maxStocks = 0;
    int prevPrice = prices[i - 1];
    for (int j = i; j <= prices + sizeof(prices); j++) {
        if (prices[j - 1] < prevPrice) {
            maxStocks++;
        }
        prevPrice = prices[j - 1];
    }
    return maxStocks;
}
```

### JavaScript
```javascript
function maxStocks(prices, i) {
    let maxStocks = 0;
    let prevPrice = prices[i - 1];
    for (let j = i; j <= prices.length; j++) {
        if (prices[j - 1] < prevPrice) {
            maxStocks++;
        }
        prevPrice = prices[j - 1];
    }
    return maxStocks;
}
```

Note that the optimized solutions are provided in different programming languages, and they all follow the same algorithmic approach.