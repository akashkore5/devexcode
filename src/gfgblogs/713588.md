---
id: "713588"
title: "Maximum Bipartite Matching"
slug: "maximum-bipartite-matching--170646"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "Data Structures"]
---

# Maximum Bipartite Matching

## Summary
The problem is about finding the maximum matching in a bipartite graph. The goal is to find the maximum number of edges that can be added to the graph while ensuring that no edge connects two vertices of the same set (i.e., the graph remains bipartite). This problem involves concepts related to graph theory and algorithms.

## Detailed Explanation
The problem can be solved using the Hopcroft-Karp algorithm, which is an efficient algorithm for finding a maximum matching in a bipartite graph. The algorithm works by iteratively improving a matching until no further improvements are possible.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty matching.
2. While there are still unmatched vertices in the graph:
   1. Find an augmenting path using BFS or DFS. An augmenting path is a path that starts and ends at unmatched vertices and only contains edges not yet used in the matching.
   2. If no augmenting path is found, stop the algorithm (since it's impossible to improve the matching further).
3. Update the matching by adding the edges from the augmenting path.

Time complexity: O(|E| + |V| log |V|)
Space complexity: O(|V| + |E|)

Here's an ASCII art diagram of a bipartite graph:
```
  U1 -- U2
  |       |
  V1 -- V3
  |       |
  U3 -- U4
  |       |
  V2 -- V4
```
In this example, the sets are {U1, U2, U3, U4} and {V1, V2, V3, V4}. The goal is to find the maximum matching that doesn't connect vertices within the same set.

## Optimized Solutions

### Java
```java
import java.util.*;

class Vertex {
    int id;
    boolean visited;
    List<Vertex> neighbors;

    public Vertex(int id) {
        this.id = id;
        this.visited = false;
        this.neighbors = new ArrayList<>();
    }
}

public class MaximumBipartiteMatching {
    public static void main(String[] args) {
        // Create the graph
        Map<Integer, Vertex> vertices = new HashMap<>();
        for (int i = 1; i <= 4; i++) {
            vertices.put(i, new Vertex(i));
        }
        vertices.get(1).neighbors.add(vertices.get(2));
        vertices.get(1).neighbors.add(vertices.get(3));
        vertices.get(2).neighbors.add(vertices.get(4));
        vertices.get(3).neighbors.add(vertices.get(4));

        // Find the maximum matching
        int maxMatchingSize = 0;
        for (Vertex v : vertices.values()) {
            if (!v.visited) {
                maxMatchingSize += bfs(v, vertices);
            }
        }

        System.out.println("Maximum bipartite matching size: " + maxMatchingSize);
    }

    private static int bfs(Vertex start, Map<Integer, Vertex> vertices) {
        Queue<Vertex> queue = new LinkedList<>();
        queue.add(start);
        start.visited = true;
        int matchedCount = 0;

        while (!queue.isEmpty()) {
            Vertex current = queue.poll();
            for (Vertex neighbor : current.neighbors) {
                if (!neighbor.visited) {
                    queue.add(neighbor);
                    neighbor.visited = true;
                    matchedCount++;
                }
            }
        }

        return matchedCount;
    }
}
```

### Python
```python
class Vertex:
    def __init__(self, id):
        self.id = id
        self.visited = False
        self.neighbors = []

def maximum_bipartite_matching(graph):
    max_matching_size = 0
    for start in graph.values():
        if not start.visited:
            max_matching_size += bfs(start, graph)
    return max_matching_size

def bfs(start, graph):
    queue = [start]
    start.visited = True
    matched_count = 0

    while queue:
        current = queue.pop(0)
        for neighbor in current.neighbors:
            if not neighbor.visited:
                queue.append(neighbor)
                neighbor.visited = True
                matched_count += 1
    return matched_count

# Example usage:
graph = {1: Vertex(1), 2: Vertex(2), 3: Vertex(3), 4: Vertex(4)}
graph[1].neighbors.extend([graph[2], graph[3]])
graph[2].neighbors.append(graph[4])
graph[3].neighbors.append(graph[4])

print("Maximum bipartite matching size:", maximum_bipartite_matching(graph))
```

### C++
```cpp
#include <iostream>
#include <queue>
#include <unordered_map>
#include <vector>

class Vertex {
public:
    int id;
    bool visited;
    std::vector<Vertex*> neighbors;

    Vertex(int id) : id(id), visited(false) {}
};

int maximumBipartiteMatching(const std::unordered_map<int, Vertex*>& graph) {
    int maxMatchingSize = 0;
    for (auto& pair : graph) {
        if (!pair.second->visited) {
            maxMatchingSize += bfs(pair.second, graph);
        }
    }

    return maxMatchingSize;
}

int bfs(Vertex* start, const std::unordered_map<int, Vertex*>& graph) {
    std::queue<Vertex*> queue;
    queue.push(start);
    start->visited = true;
    int matchedCount = 0;

    while (!queue.empty()) {
        Vertex* current = queue.front();
        queue.pop();
        for (Vertex* neighbor : current->neighbors) {
            if (!neighbor->visited) {
                queue.push(neighbor);
                neighbor->visited = true;
                matchedCount++;
            }
        }
    }

    return matchedCount;
}

int main() {
    // Create the graph
    std::unordered_map<int, Vertex*> vertices;
    for (int i = 1; i <= 4; i++) {
        vertices[i] = new Vertex(i);
    }
    vertices[1]->neighbors.push_back(vertices[2]);
    vertices[1]->neighbors.push_back(vertices[3]);
    vertices[2]->neighbors.push_back(vertices[4]);
    vertices[3]->neighbors.push_back(vertices[4]);

    // Find the maximum matching
    int maxMatchingSize = maximumBipartiteMatching(vertices);

    std::cout << "Maximum bipartite matching size: " << maxMatchingSize << std::endl;

    return 0;
}
```

### JavaScript
```javascript
class Vertex {
    constructor(id) {
        this.id = id;
        this.visited = false;
        this.neighbors = [];
    }
}

function maximumBipartiteMatching(graph) {
    let maxMatchingSize = 0;
    for (let start in Object.values(graph)) {
        if (!start.visited) {
            maxMatchingSize += bfs(start, graph);
        }
    }

    return maxMatchingSize;
}

function bfs(start, graph) {
    const queue = [start];
    start.visited = true;
    let matchedCount = 0;

    while (queue.length > 0) {
        const current = queue.shift();
        for (let neighbor of current.neighbors) {
            if (!neighbor.visited) {
                queue.push(neighbor);
                neighbor.visited = true;
                matchedCount++;
            }
        }
    }

    return matchedCount;
}

// Example usage:
const graph = {};
for (let i = 1; i <= 4; i++) {
    graph[i] = new Vertex(i);
}
graph[1].neighbors.push(graph[2]);
graph[1].neighbors.push(graph[3]);
graph[2].neighbors.push(graph[4]);
graph[3].neighbors.push(graph[4]);

console.log(`Maximum bipartite matching size: ${maximumBipartiteMatching(graph)}`);
```

Note that these implementations assume a graph represented as an adjacency list, where each vertex has a list of neighboring vertices. The `bfs` function implements the breadth-first search algorithm to find the maximum matching in the graph.