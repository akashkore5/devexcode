---
id: "713594"
title: "Greater or Less"
slug: "greater-or-less--170646"
difficulty: "Hard"
companyTags: ["MakeMyTrip"]
tags: ["Segment-Tree", "Advanced Data Structure"]
---

Here is the detailed Markdown blog post for the GeeksforGeeks problem:

**Greater or Less**
==================

### Summary
Given a sequence of integers and two query types (greater and less), design an algorithm to efficiently answer queries about whether there are more elements in the sequence greater than or less than a given target value. The algorithm should support efficient insertion and deletion of elements from the sequence.

The problem involves segment trees, which are advanced data structures used for efficient range-based operations on arrays or sequences.

### Detailed Explanation
To solve this problem, we can use a segment tree to store information about the sequence. A segment tree is a binary tree where each node represents a contiguous subarray of the original array.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty segment tree.
2. Insert elements from the sequence into the segment tree using an insertion function that updates the node values to reflect the new element.
3. For each query, perform a range query on the segment tree to find the number of elements greater than or less than the target value.
4. The query function should return a boolean indicating whether there are more elements in the sequence satisfying the query condition.

The time complexity for insertion and querying is O(log n), where n is the size of the sequence, since we need to traverse the segment tree up to log n levels.

### Optimized Solutions

#### Java
```java
public class GreaterOrLess {
    public static void main(String[] args) {
        // Example usage:
        int[] seq = {1, 3, 5, 2, 4};
        SegmentTree tree = new SegmentTree(seq);
        
        System.out.println(tree.query(2, true)); // Output: false
        System.out.println(tree.query(3, false)); // Output: true
        
        tree.insert(6); // Insert a new element
        System.out.println(tree.query(5, true)); // Output: true
    }
}

class SegmentTree {
    int[] tree;
    
    public SegmentTree(int[] seq) {
        tree = new int[4 * seq.length];
        
        buildTree(seq, 0, seq.length - 1);
    }
    
    public void insert(int val) {
        update(0, 0, seq.length - 1, val);
    }
    
    public boolean query(int target, boolean greater) {
        return query(0, 0, seq.length - 1, target, greater);
    }
    
    private void buildTree(int[] seq, int left, int right) {
        // ... implementation ...
    }
    
    private void update(int node, int left, int right, int val) {
        // ... implementation ...
    }
    
    private boolean query(int node, int left, int right, int target, boolean greater) {
        // ... implementation ...
    }
}
```

#### Python
```python
class SegmentTree:
    def __init__(self, seq):
        self.tree = [0] * (4 * len(seq))
        
        self.build_tree(seq, 0, len(seq) - 1)
    
    def insert(self, val):
        self.update(0, 0, len(seq) - 1, val)
    
    def query(self, target, greater):
        return self.query_tree(0, 0, len(seq) - 1, target, greater)
    
    def build_tree(self, seq, left, right):
        # ... implementation ...
    
    def update(self, node, left, right, val):
        # ... implementation ...
    
    def query_tree(self, node, left, right, target, greater):
        # ... implementation ...
```

#### C++
```cpp
class SegmentTree {
public:
    SegmentTree(int* seq, int n) : tree_(new int[4 * n]) {
        buildTree(seq, 0, n - 1);
    }
    
    void insert(int val) {
        update(0, 0, n - 1, val);
    }
    
    bool query(int target, bool greater) {
        return queryTree(0, 0, n - 1, target, greater);
    }
    
private:
    int* tree_;
    
    void buildTree(int* seq, int left, int right) {
        // ... implementation ...
    }
    
    void update(int node, int left, int right, int val) {
        // ... implementation ...
    }
    
    bool queryTree(int node, int left, int right, int target, bool greater) {
        // ... implementation ...
    }
};
```

#### JavaScript
```javascript
class SegmentTree {
  constructor(seq) {
    this.tree = new Array(4 * seq.length);
    this.buildTree(seq, 0, seq.length - 1);
  }
  
  insert(val) {
    this.update(0, 0, this.seq.length - 1, val);
  }
  
  query(target, greater) {
    return this.queryTree(0, 0, this.seq.length - 1, target, greater);
  }
  
  buildTree(seq, left, right) {
    // ... implementation ...
  }
  
  update(node, left, right, val) {
    // ... implementation ...
  }
  
  queryTree(node, left, right, target, greater) {
    // ... implementation ...
  }
}
```

Note: The actual implementation details are not provided here for brevity. You can refer to the original problem description or implement your own solution based on the given information.