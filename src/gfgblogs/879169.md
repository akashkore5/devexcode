---
id: "879169"
title: "Queue using two Stacks"
slug: "queue-using-two-stacks--115418"
difficulty: "Easy"
companyTags: ["Flipkart", "Morgan Stanley", "Accolite", "Amazon", "Microsoft", "D-E-Shaw", "Hike", "MakeMyTrip", "Oracle", "Walmart", "Goldman Sachs", "MAQ Software", "Adobe", "InfoEdge", "InMobi"]
tags: ["Stack", "Queue", "STL", "Data Structures"]
---

**Queue using two Stacks**
=====================================================

## Summary
Given a queue data structure, design and implement an algorithm to simulate its functionality using two stacks. This problem involves implementing the basic operations of enqueue and dequeue using stack-based approach.

## Detailed Explanation
The idea is to use two stacks, one for enqueue operation and another for dequeue operation. The first stack (enqueue stack) is used to store elements as they are added to the queue. When an element needs to be dequeued, it is moved from the enqueue stack to the dequeue stack. If the dequeue stack is empty, all elements from the enqueue stack are moved to the dequeue stack.

Here's a step-by-step breakdown of the solution:

1. Initialize two stacks: `enqueueStack` and `dequeueStack`.
2. To enqueue an element:
	* Push the element onto `enqueueStack`.
3. To dequeue an element:
	* If `dequeueStack` is empty, pop all elements from `enqueueStack` and push them onto `dequeueStack`. This ensures that the order of elements remains the same.
	* Pop the top element from `dequeueStack`, which represents the dequeued element.

Time complexity: O(1) for enqueue and O(n) for dequeue operations (where n is the number of elements in the queue).
Space complexity: O(n), where n is the maximum size of the queue.

## Optimized Solutions
### Java
```java
class QueueUsingTwoStacks {
    Stack<Integer> enqueueStack;
    Stack<Integer> dequeueStack;

    public QueueUsingTwoStacks() {
        enqueueStack = new Stack<>();
        dequeueStack = new Stack<>();
    }

    public void enqueue(int element) {
        enqueueStack.push(element);
    }

    public int dequeue() {
        if (dequeueStack.isEmpty()) {
            while (!enqueueStack.isEmpty()) {
                dequeueStack.push(enqueueStack.pop());
            }
        }
        return dequeueStack.pop();
    }
}
```

### Python
```python
class QueueUsingTwoStacks:
    def __init__(self):
        self.enqueue_stack = []
        self.dequeue_stack = []

    def enqueue(self, element):
        self.enqueue_stack.append(element)

    def dequeue(self):
        if not self.dequeue_stack:
            while self.enqueue_stack:
                self.dequeue_stack.append(self.enqueue_stack.pop(0))
        return self.dequeue_stack.pop()
```

### C++
```cpp
class QueueUsingTwoStacks {
public:
    std::stack<int> enqueueStack;
    std::stack<int> dequeueStack;

    void enqueue(int element) {
        enqueueStack.push(element);
    }

    int dequeue() {
        if (dequeueStack.empty()) {
            while (!enqueueStack.empty()) {
                dequeueStack.push(enqueueStack.top());
                enqueueStack.pop();
            }
        }
        return dequeueStack.top();
    }
};
```

### JavaScript
```javascript
class QueueUsingTwoStacks {
  constructor() {
    this.enqueueStack = [];
    this.dequeueStack = [];
  }

  enqueue(element) {
    this.enqueueStack.push(element);
  }

  dequeue() {
    if (this.dequeueStack.length === 0) {
      while (this.enqueueStack.length > 0) {
        this.dequeueStack.push(this.enqueueStack.shift());
      }
    }
    return this.dequeueStack.pop();
  }
}
```

Note that the JavaScript solution uses an array-based implementation of stacks, whereas the other languages use built-in stack implementations.