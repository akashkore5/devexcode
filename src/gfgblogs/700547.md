---
id: "700547"
title: "Sum of leaf nodes in BST"
slug: "sum-of-leaf-nodes-in-bst"
difficulty: "Easy"
companyTags: []
tags: ["Binary Search Tree", "Data Structures"]
---

Here is a detailed Markdown blog post for the problem "Sum of leaf nodes in BST":

# Sum of leaf nodes in BST
## Summary
Given a Binary Search Tree (BST), find the sum of all leaf nodes. A leaf node is an internal node that has no children.

## Detailed Explanation
To solve this problem, we can start by recursively traversing the tree and keeping track of whether each node is a leaf or not. We'll use an in-order traversal to ensure that we visit the left subtree before the current node, then the right subtree. This way, we'll encounter all leaf nodes first.

Here's the step-by-step breakdown:

1. Start at the root of the tree.
2. If the current node is a leaf (i.e., it has no children), add its value to our sum.
3. Recursively traverse the left subtree (if it exists).
4. Recursively traverse the right subtree (if it exists).

Here's an ASCII art diagram to help illustrate this:
```
       5
     /   \
    2     8
   / \   / \
 1   3 6   9
```

In this example, the leaf nodes are 1, 3, and 9. Our algorithm would visit these nodes first and add their values to our sum.

The time complexity of this algorithm is O(n), where n is the number of nodes in the tree, because we visit each node once. The space complexity is O(h), where h is the height of the tree, due to the recursive call stack.

## Optimized Solutions

### Java
```java
class Node {
    int val;
    Node left, right;

    Node(int v) {
        val = v;
        left = right = null;
    }
}

public class Main {
    public static int sumLeafNodes(Node root) {
        if (root == null) return 0;
        int sum = 0;
        if (root.left == null && root.right == null) {
            sum += root.val;
        } else {
            sum += sumLeafNodes(root.left);
            sum += sumLeafNodes(root.right);
        }
        return sum;
    }

    public static void main(String[] args) {
        Node root = new Node(5);
        root.left = new Node(2);
        root.right = new Node(8);
        root.left.left = new Node(1);
        root.left.right = new Node(3);
        root.right.left = new Node(6);
        root.right.right = new Node(9);

        System.out.println(sumLeafNodes(root)); // Output: 13
    }
}
```

### Python
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def sum_leaf_nodes(node):
    if node is None:
        return 0
    sum = 0
    if node.left is None and node.right is None:
        sum += node.val
    else:
        sum += sum_leaf_nodes(node.left)
        sum += sum_leaf_nodes(node.right)
    return sum

root = Node(5)
root.left = Node(2)
root.right = Node(8)
root.left.left = Node(1)
root.left.right = Node(3)
root.right.left = Node(6)
root.right.right = Node(9)

print(sum_leaf_nodes(root))  # Output: 13
```

### C++
```cpp
class Node {
public:
    int val;
    Node* left, *right;

    Node(int v) {
        val = v;
        left = right = nullptr;
    }
};

int sumLeafNodes(Node* root) {
    if (root == nullptr) return 0;
    int sum = 0;
    if (root->left == nullptr && root->right == nullptr) {
        sum += root->val;
    } else {
        sum += sumLeafNodes(root->left);
        sum += sumLeafNodes(root->right);
    }
    return sum;
}

int main() {
    Node* root = new Node(5);
    root->left = new Node(2);
    root->right = new Node(8);
    root->left->left = new Node(1);
    root->left->right = new Node(3);
    root->right->left = new Node(6);
    root->right->right = new Node(9);

    std::cout << sumLeafNodes(root) << std::endl;  // Output: 13
}
```

### JavaScript
```javascript
class Node {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function sumLeafNodes(node) {
    if (node === null) return 0;
    let sum = 0;
    if (node.left === null && node.right === null) {
        sum += node.val;
    } else {
        sum += sumLeafNodes(node.left);
        sum += sumLeafNodes(node.right);
    }
    return sum;
}

let root = new Node(5);
root.left = new Node(2);
root.right = new Node(8);
root.left.left = new Node(1);
root.left.right = new Node(3);
root.right.left = new Node(6);
root.right.right = new Node(9);

console.log(sumLeafNodes(root));  // Output: 13
```

Note that these solutions assume a binary tree node structure, where each node has a value and references to its left and right children.