---
id: "702719"
title: "Minimum Energy"
slug: "minimum-energy1107"
difficulty: "Easy"
companyTags: ["Amazon"]
tags: ["Arrays", "Data Structures"]
---

**Minimum Energy**
================

**Slug:** minimum-energy1107
**Difficulty:** Easy
**Id:** 702719
**Topic Tags:** Arrays, Data Structures
**Company Tags:** Amazon

## Summary
The "Minimum Energy" problem involves finding the minimum energy required to sort an array of integers. This is a classic example of a dynamic programming problem, where we need to optimize a solution by breaking it down into smaller subproblems and solving each one recursively.

## Detailed Explanation
Given an array `arr` of size `n`, we need to find the minimum energy required to sort this array in ascending order. The energy required for sorting is calculated as the sum of absolute differences between adjacent elements in the sorted array.

To solve this problem, we can use dynamic programming. First, we initialize a 2D array `dp` of size `(n+1) x (n+1)` to store the minimum energy required to sort the first `i` elements and have the last element as `j`. Then, for each pair of adjacent elements `i` and `j`, we calculate the minimum energy required to move `j` to its correct position in the sorted array. This is done by considering two cases: either `j` is placed at its correct position immediately after `i`, or it's placed at a different position.

Here's the step-by-step breakdown of the solution:

1. Initialize `dp[0][0] = 0`.
2. For each `i` from 1 to `n`, and for each `j` from 1 to `n`, calculate `dp[i][j]` as follows:
	* If `j == i`, set `dp[i][j] = dp[i-1][j-1] + |arr[j]-arr[j-1]|`.
	* Otherwise, consider two cases: either `j` is placed at its correct position immediately after `i`, or it's placed at a different position. Calculate the minimum energy required for each case and choose the smaller one.
3. The minimum energy required to sort the entire array is stored in `dp[n][n]`.

Time complexity: O(n^2)
Space complexity: O(n^2)

## Optimized Solutions

### Java
```
java
public class MinimumEnergy {
    public static int minEnergy(int[] arr) {
        int n = arr.length;
        int[][] dp = new int[n+1][n+1];
        for (int i = 0; i <= n; i++) {
            dp[i][i] = 0;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (j == i) {
                    dp[i][j] = dp[i-1][j-1] + Math.abs(arr[j]-arr[j-1]);
                } else {
                    int left = dp[i-1][j-1] + Math.abs(arr[j]-arr[j-1]);
                    int right = dp[i-1][j] + (i-j > 0 ? arr[j] - arr[i-1] : 0);
                    dp[i][j] = Math.min(left, right);
                }
            }
        }
        return dp[n][n];
    }
}
```

### Python
```
python
def min_energy(arr):
    n = len(arr)
    dp = [[0] * (n+1) for _ in range(n+1)]
    for i in range(n+1):
        dp[i][i] = 0
    for i in range(1, n+1):
        for j in range(1, n+1):
            if j == i:
                dp[i][j] = dp[i-1][j-1] + abs(arr[j]-arr[j-1])
            else:
                left = dp[i-1][j-1] + abs(arr[j]-arr[j-1])
                right = dp[i-1][j] + (i-j > 0 and arr[j] - arr[i-1] or 0)
                dp[i][j] = min(left, right)
    return dp[n][n]
```

### C++
```
cpp
#include <iostream>
using namespace std;

int minEnergy(int arr[], int n) {
    int dp[n+1][n+1];
    for (int i = 0; i <= n; i++) {
        dp[i][i] = 0;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (j == i) {
                dp[i][j] = dp[i-1][j-1] + abs(arr[j]-arr[j-1]);
            } else {
                int left = dp[i-1][j-1] + abs(arr[j]-arr[j-1]);
                int right = dp[i-1][j] + (i-j > 0 ? arr[j] - arr[i-1] : 0);
                dp[i][j] = min(left, right);
            }
        }
    }
    return dp[n][n];
}

int main() {
    int arr[] = {10, 20, 30, 40};
    int n = sizeof(arr) / sizeof(arr[0]);
    cout << "Minimum energy required to sort the array: " << minEnergy(arr, n);
    return 0;
}
```

### JavaScript
```
javascript
function minEnergy(arr) {
    let n = arr.length;
    let dp = new Array(n+1).fill(0).map(() => new Array(n+1).fill(0));
    for (let i = 0; i <= n; i++) {
        dp[i][i] = 0;
    }
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= n; j++) {
            if (j == i) {
                dp[i][j] = dp[i-1][j-1] + Math.abs(arr[j]-arr[j-1]);
            } else {
                let left = dp[i-1][j-1] + Math.abs(arr[j]-arr[j-1]);
                let right = dp[i-1][j] + (i-j > 0 ? arr[j] - arr[i-1] : 0);
                dp[i][j] = Math.min(left, right);
            }
        }
    }
    return dp[n][n];
}
```