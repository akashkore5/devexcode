---
id: "703450"
title: "Maximum number of partitions that can be sorted individually to make sorted"
slug: "maximum-number-of-partitions-that-can-be-sorted-individually-to-make-sorted2926"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Sorting", "Data Structures", "Algorithms"]
---

**Maximum Number of Partitions that can be Sorted Individually to make Sorted**
==================================================================

## Summary
Given an unsorted array, find the maximum number of partitions that can be sorted individually to make the entire array sorted. This problem involves sorting arrays and partitioning them into smaller subarrays. The key concept is to identify the optimal way to split the array into smaller parts, ensuring that each part can be sorted independently.

## Detailed Explanation
To solve this problem, we will use a divide-and-conquer approach. We will first find the middle element of the array and then partition it into two halves. Then, we will recursively apply this process to each half until the base case is reached (i.e., when the length of the subarray becomes 1).

Here's a step-by-step breakdown of the solution:

* Find the middle element of the array.
* Partition the array into two halves: `left` and `right`.
* Recursively apply the same process to each half until the base case is reached.
* Combine the results from the left and right partitions to form the final sorted array.

Time complexity analysis:
The time complexity of this algorithm is O(n log n), where n is the length of the input array. This is because we are using a divide-and-conquer approach, which involves recursively partitioning the array into smaller subarrays. The space complexity is O(log n) due to the recursive function calls.

## Optimized Solutions

#### Java
```java
public class MaximumSortedPartitions {
    public static int maxPartitions(int[] arr) {
        if (arr == null || arr.length == 0) return 0;
        
        int n = arr.length;
        int left = 0, right = n - 1;
        int partitions = 0;
        
        while (left < right) {
            if (arr[left] <= arr[right]) {
                left++;
            } else {
                right--;
            }
            partitions++;
        }
        
        return partitions + 1;
    }
}
```

#### Python
```python
def max_partitions(arr):
    if not arr:
        return 0
    
    n = len(arr)
    left, right = 0, n - 1
    partitions = 0
    
    while left < right:
        if arr[left] <= arr[right]:
            left += 1
        else:
            right -= 1
        partitions += 1
    
    return partitions + 1
```

#### C++
```cpp
class MaximumSortedPartitions {
public:
    int maxPartitions(int* arr, int n) {
        if (arr == nullptr || n == 0) return 0;
        
        int left = 0, right = n - 1;
        int partitions = 0;
        
        while (left < right) {
            if (arr[left] <= arr[right]) {
                left++;
            } else {
                right--;
            }
            partitions++;
        }
        
        return partitions + 1;
    }
};
```

#### JavaScript
```javascript
function maxPartitions(arr) {
    if (!arr.length) return 0;
    
    let n = arr.length;
    let left = 0, right = n - 1;
    let partitions = 0;
    
    while (left < right) {
        if (arr[left] <= arr[right]) {
            left++;
        } else {
            right--;
        }
        partitions++;
    }
    
    return partitions + 1;
}
```
Note: The above code assumes that the input array is unsorted and contains distinct elements.