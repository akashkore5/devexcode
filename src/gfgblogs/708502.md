---
id: "708502"
title: "Articulation Point - I"
slug: "articulation-point-1"
difficulty: "Hard"
companyTags: []
tags: ["Graph", "Data Structures"]
---

# Articulation Point - I
Slug: articulation-point-1
Difficulty: Hard
Id: 708502
Topic Tags: Graph, Data Structures
Company Tags: None

## Summary
The problem is about finding all the articulation points in a given graph. An articulation point is a vertex that, when removed, increases the number of connected components in the graph. The key concept involved is graph traversal and manipulation.

## Detailed Explanation
To solve this problem, we can use a Depth-First Search (DFS) algorithm to traverse the graph. We will keep track of two types of vertices: root nodes and articulation points. A root node is any vertex that has no incoming edges. An articulation point is a vertex that becomes disconnected when its parent node is removed.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty list `articulationPoints` to store all the articulation points.
2. Perform DFS on the graph, starting from any arbitrary vertex (let's say `v`).
3. For each visited vertex `u`, check if it is a root node or not. If `u` has no incoming edges, mark it as a root node and recursively traverse its children.
4. While traversing the graph, keep track of the parent nodes for each vertex. When we visit a vertex `u` with parent node `p`, increment a counter `lowlink[u]` to represent the lowest reachable ancestor from `u`. If `p` has no incoming edges, mark `u` as an articulation point.
5. After DFS traversal is complete, iterate over all vertices and check if they are articulation points or not.

Here's an ASCII art diagram of a graph with articulation points:
```
      A
     / \
    B   C
   / \ / \
  D---E--F
```
In this example, vertices `B` and `C` are root nodes. When removing vertex `A`, the graph becomes disconnected. Therefore, `A` is an articulation point.

Time complexity: O(V + E), where V is the number of vertices and E is the number of edges.
Space complexity: O(V), as we need to store the parent nodes for each vertex.

## Optimized Solutions

### Java
```java
public class ArticulationPoint {
    public static List<Integer> findArticulationPoints(int[][] graph) {
        List<Integer> articulationPoints = new ArrayList<>();
        int[] lowlink = new int[graph.length];
        int[] disc = new int[graph.length];
        int time = 0;
        for (int i = 0; i < graph.length; i++) {
            if (!visited(graph, i, lowlink, disc, time, articulationPoints)) {
                dfs(graph, i, -1, lowlink, disc, time, articulationPoints);
            }
        }
        return articulationPoints;
    }

    private static boolean visited(int[][] graph, int u, int[] lowlink, int[] disc, int time, List<Integer> articulationPoints) {
        if (disc[u] == -1) {
            dfsUtil(graph, u, lowlink, disc, time, articulationPoints);
            return true;
        }
        return false;
    }

    private static void dfs(int[][] graph, int v, int parent, int[] lowlink, int[] disc, int time, List<Integer> articulationPoints) {
        disc[v] = time++;
        lowlink[v] = time++;
        for (int neighbor : graph[v]) {
            if (disc[neighbor] == -1) {
                dfs(graph, neighbor, v, lowlink, disc, time, articulationPoints);
                lowlink[v] = Math.min(lowlink[v], lowlink[neighbor]);
                if ((parent != -1 && lowlink[neighbor] >= disc[v]) || (parent == -1 && lowlink[neighbor] >= disc[v])) {
                    articulationPoints.add(v);
                }
            } else if (neighbor != parent) {
                lowlink[v] = Math.min(lowlink[v], disc[neighbor]);
            }
        }
    }

    private static void dfsUtil(int[][] graph, int v, int[] lowlink, int[] disc, int time, List<Integer> articulationPoints) {
        visited(graph, v, lowlink, disc, time, articulationPoints);
    }
}
```

### Python
```python
def find_articulation_points(graph):
    articulation_points = []
    lowlink = [0] * len(graph)
    disc = [0] * len(graph)
    time = 0
    for i in range(len(graph)):
        if not visited(i, graph, lowlink, disc, time, articulation_points):
            dfs(i, -1, graph, lowlink, disc, time, articulation_points)
    return articulation_points

def visited(u, graph, lowlink, disc, time, articulation_points):
    if disc[u] == -1:
        dfs_util(u, graph, lowlink, disc, time, articulation_points)
        return True
    return False

def dfs(v, parent, graph, lowlink, disc, time, articulation_points):
    global time
    disc[v] = time
    lowlink[v] = time + 1
    for neighbor in graph[v]:
        if disc[neighbor] == -1:
            dfs(neighbor, v, graph, lowlink, disc, time + 1, articulation_points)
            lowlink[v] = min(lowlink[v], lowlink[neighbor])
            if parent != -1 and lowlink[neighbor] >= disc[v]:
                articulation_points.append(v)
            elif parent == -1 and lowlink[neighbor] >= disc[v]:
                articulation_points.append(v)
        elif neighbor != parent:
            lowlink[v] = min(lowlink[v], disc[neighbor])
    time += 1
```

### C++
```cpp
#include <vector>
using namespace std;

vector<int> findArticulationPoints(vector<vector<int>>& graph) {
    vector<int> articulationPoints;
    int* lowlink = new int[graph.size()];
    int* disc = new int[graph.size()];
    int time = 0;
    for (int i = 0; i < graph.size(); i++) {
        if (!visited(graph, i, lowlink, disc, time, articulationPoints)) {
            dfs(graph, i, -1, lowlink, disc, time, articulationPoints);
        }
    }
    delete[] lowlink;
    delete[] disc;
    return articulationPoints;
}

bool visited(vector<vector<int>>& graph, int u, int* lowlink, int* disc, int time, vector<int>& articulationPoints) {
    if (disc[u] == -1) {
        dfsUtil(graph, u, lowlink, disc, time, articulationPoints);
        return true;
    }
    return false;
}

void dfs(vector<vector<int>>& graph, int v, int parent, int* lowlink, int* disc, int time, vector<int>& articulationPoints) {
    disc[v] = time++;
    lowlink[v] = time++;
    for (int neighbor : graph[v]) {
        if (disc[neighbor] == -1) {
            dfs(graph, neighbor, v, lowlink, disc, time++, articulationPoints);
            lowlink[v] = min(lowlink[v], lowlink[neighbor]);
            if ((parent != -1 && lowlink[neighbor] >= disc[v]) || (parent == -1 && lowlink[neighbor] >= disc[v])) {
                articulationPoints.push_back(v);
            }
        } else if (neighbor != parent) {
            lowlink[v] = min(lowlink[v], disc[neighbor]);
        }
    }
}

void dfsUtil(vector<vector<int>>& graph, int v, int* lowlink, int* disc, int time, vector<int>& articulationPoints) {
    visited(graph, v, lowlink, disc, time, articulationPoints);
}
```

### JavaScript
```javascript
function findArticulationPoints(graph) {
  let articulationPoints = [];
  let lowlink = new Array(graph.length).fill(0);
  let disc = new Array(graph.length).fill(0);
  let time = 0;
  for (let i = 0; i < graph.length; i++) {
    if (!visited(i, graph, lowlink, disc, time, articulationPoints)) {
      dfs(i, -1, graph, lowlink, disc, time, articulationPoints);
    }
  }
  return articulationPoints;
}

function visited(u, graph, lowlink, disc, time, articulationPoints) {
  if (disc[u] === -1) {
    dfsUtil(u, graph, lowlink, disc, time, articulationPoints);
    return true;
  }
  return false;
}

function dfs(v, parent, graph, lowlink, disc, time, articulationPoints) {
  disc[v] = time++;
  lowlink[v] = time++;
  for (let neighbor of graph[v]) {
    if (disc[neighbor] === -1) {
      dfs(neighbor, v, graph, lowlink, disc, time++, articulationPoints);
      lowlink[v] = Math.min(lowlink[v], lowlink[neighbor]);
      if ((parent !== -1 && lowlink[neighbor] >= disc[v]) || (parent === -1 && lowlink[neighbor] >= disc[v])) {
        articulationPoints.push(v);
      }
    } else if (neighbor !== parent) {
      lowlink[v] = Math.min(lowlink[v], disc[neighbor]);
    }
  }
}

function dfsUtil(v, graph, lowlink, disc, time, articulationPoints) {
  visited(v, graph, lowlink, disc, time, articulationPoints);
}
```

Note: The above code is written in Markdown format and is intended to be used as a reference implementation. It may not be optimized for performance or error handling.