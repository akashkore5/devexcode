---
id: "703229"
title: "Numbers with prime frequencies greater than or equal to k"
slug: "numbers-with-prime-frequencies-greater-than-or-equal-to-k5823"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Hash", "Data Structures"]
---

**Numbers with prime frequencies greater than or equal to k**
==================================================

### Summary

Given a list of integers, find all numbers that have prime frequencies greater than or equal to `k`. A frequency is considered prime if it's not divisible by any number except for 1 and the number itself. For example, if we have the list `[2, 3, 4, 5]`, the prime frequencies are `1`, `1`, `2`, and `1` respectively. The output should include all numbers from the original list that have a prime frequency greater than or equal to `k`.

### Detailed Explanation

To solve this problem, we can first calculate the frequency of each number in the list. Then, for each frequency, check if it's prime by iterating from 2 to the square root of the frequency and checking if it's divisible by any of these numbers. If a frequency is not prime, we skip it. Finally, return all numbers that have a prime frequency greater than or equal to `k`.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty list to store the results.
2. Iterate through the input list and calculate the frequency of each number.
3. For each frequency, check if it's prime by iterating from 2 to the square root of the frequency.
4. If the frequency is not divisible by any of these numbers (except for 1 and the frequency itself), consider it prime.
5. Add all numbers that have a prime frequency greater than or equal to `k` to the result list.

Time complexity: O(n log n) where n is the length of the input list, as we're iterating through the list once and then checking if each frequency is prime.
Space complexity: O(n) for storing the results.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class Main {
    public static List<Integer> numbersWithPrimeFrequencies(int[] arr, int k) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        List<Integer> result = new ArrayList<>();

        for (int num : arr) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
            int freq = entry.getValue();
            boolean isPrime = true;

            if (freq < 2) continue;

            for (int i = 2; i * i <= freq; i++) {
                if (freq % i == 0) {
                    isPrime = false;
                    break;
                }
            }

            if (isPrime && freq >= k) result.add(entry.getKey());
        }

        return result;
    }
}
```

#### Python
```python
def numbers_with_prime_frequencies(arr, k):
    frequency_map = {}
    result = []

    for num in arr:
        frequency_map[num] = frequency_map.get(num, 0) + 1

    for freq in frequency_map.values():
        is_prime = True

        if freq < 2: continue

        for i in range(2, int(freq ** 0.5) + 1):
            if freq % i == 0:
                is_prime = False
                break

        if is_prime and freq >= k: result.append(next(key for key, val in frequency_map.items() if val == freq))

    return result
```

#### C++
```cpp
#include <unordered_map>
#include <vector>

std::vector<int> numbersWithPrimeFrequencies(int arr[], int n, int k) {
    std::unordered_map<int, int> frequencyMap;
    std::vector<int> result;

    for (int i = 0; i < n; i++) {
        frequencyMap[arr[i]] = frequencyMap.get(arr[i], 0) + 1;
    }

    for (auto& entry : frequencyMap) {
        int freq = entry.second;
        bool isPrime = true;

        if (freq < 2) continue;

        for (int i = 2; i * i <= freq; i++) {
            if (freq % i == 0) {
                isPrime = false;
                break;
            }
        }

        if (isPrime && freq >= k) result.push_back(entry.first);
    }

    return result;
}
```

#### JavaScript
```javascript
function numbersWithPrimeFrequencies(arr, k) {
    const frequencyMap = {};
    const result = [];

    for (const num of arr) {
        frequencyMap[num] = (frequencyMap[num] || 0) + 1;
    }

    for (const freq in frequencyMap) {
        let isPrime = true;

        if (freq < 2) continue;

        for (let i = 2; i * i <= freq; i++) {
            if (freq % i === 0) {
                isPrime = false;
                break;
            }
        }

        if (isPrime && +freq >= k) result.push(+freq);
    }

    return result;
}
```

Note: These solutions assume that the input list does not contain duplicate numbers. If duplicates are possible, you may need to modify the solution accordingly.