---
id: "893334"
title: "Longest Valid Word with All Prefixes"
slug: "longest-valid-word-with-all-prefixes"
difficulty: "Medium"
companyTags: []
tags: []
---

# Longest Valid Word with All Prefixes

## Summary
Given a list of words, find the longest word that has all its prefixes as valid English words. For example, if the input is ["apple", "banana", "app", "appl"], the output should be "apple" because it's the longest word that has all its prefixes ("app" and "") as valid English words.

## Detailed Explanation

To solve this problem, we can iterate through each word in the list. For each word, we check if all its prefixes are valid English words. If a prefix is not valid, we immediately move on to the next word. If a word has all its prefixes as valid English words and it's the longest so far, we update our result.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty string `result` to store the longest valid word.
2. Iterate through each word in the input list.
3. For each word, iterate from its first character to its last character (inclusive).
4. For each prefix, check if it's a valid English word. We can do this by checking if the prefix is present in our dictionary of valid words.
5. If a prefix is not valid, break out of the inner loop and move on to the next word.
6. If a word has all its prefixes as valid English words and it's longer than our current result, update `result`.
7. Return `result`.

Time complexity: O(N*M), where N is the number of words in the input list and M is the maximum length of a word.

Space complexity: O(M), where M is the maximum length of a word.

## Optimized Solutions

### Java
```java
import java.util.*;

public class Main {
    public static String longestValidWord(String[] dictionary) {
        String result = "";
        for (String word : dictionary) {
            boolean isValid = true;
            for (int i = 0; i < word.length(); i++) {
                if (!isValid(word.substring(0, i + 1))) {
                    isValid = false;
                    break;
                }
            }
            if (isValid && word.length() > result.length()) {
                result = word;
            }
        }
        return result;
    }

    public static boolean isValid(String word) {
        // implement your dictionary lookup logic here
        // for example, you can use a HashSet to store the valid words
        Set<String> dictionary = new HashSet<>(Arrays.asList(dictionary));
        return dictionary.contains(word);
    }
}
```

### Python
```python
def longest_valid_word(dictionary):
    result = ""
    for word in dictionary:
        is_valid = True
        for i in range(len(word)):
            if not is_valid_word(word[:i+1]):
                is_valid = False
                break
        if is_valid and len(word) > len(result):
            result = word
    return result

def is_valid_word(word):
    # implement your dictionary lookup logic here
    # for example, you can use a set to store the valid words
    dictionary = set(dictionary)
    return word in dictionary
```

### C++
```cpp
#include <iostream>
#include <string>
#include <vector>

std::string longestValidWord(std::vector<std::string>& dictionary) {
    std::string result = "";
    for (const auto& word : dictionary) {
        bool isValid = true;
        for (int i = 0; i <= word.size(); i++) {
            if (!isValid(word.substr(0, i))) {
                isValid = false;
                break;
            }
        }
        if (isValid && word.size() > result.size()) {
            result = word;
        }
    }
    return result;
}

bool isValid(const std::string& word) {
    // implement your dictionary lookup logic here
    // for example, you can use a set to store the valid words
    std::set<std::string> dictionary(dictionary.begin(), dictionary.end());
    return dictionary.count(word) > 0;
}
```

### JavaScript
```javascript
function longestValidWord(dictionary) {
    let result = "";
    for (const word of dictionary) {
        let isValid = true;
        for (let i = 0; i <= word.length; i++) {
            if (!isValid(word.slice(0, i + 1))) {
                isValid = false;
                break;
            }
        }
        if (isValid && word.length > result.length) {
            result = word;
        }
    }
    return result;
}

function isValid(word) {
    // implement your dictionary lookup logic here
    // for example, you can use a set to store the valid words
    const dictionary = new Set(dictionary);
    return dictionary.has(word);
}
```