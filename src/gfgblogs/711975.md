---
id: "711975"
title: "Minimum travel time"
slug: "minimum-travel-time"
difficulty: "Hard"
companyTags: []
tags: []
---

**Minimum Travel Time**
===============

## Summary
The problem "Minimum travel time" is a classic algorithmic challenge that requires us to find the minimum time it takes to visit a set of cities. The key concept involved in this problem is graph theory, specifically finding the shortest path between nodes.

## Detailed Explanation
We are given a list of cities and their corresponding coordinates (x, y). We need to find the minimum travel time required to visit each city exactly once and return to the starting point. This can be modeled as a traveling salesman problem (TSP).

To solve this problem, we can use a greedy algorithm that involves selecting the closest unvisited city at each step. The algorithm starts by choosing an arbitrary city as the first stop. Then, it repeatedly selects the closest unvisited city until all cities have been visited.

Here is a step-by-step breakdown of the solution:

1. Initialize the current city and set it to the starting point.
2. Create a list of unvisited cities.
3. While there are still unvisited cities:
   - Calculate the distance from the current city to each unvisited city using the Euclidean distance formula (sqrt((x2-x1)^2 + (y2-y1)^2)).
   - Choose the closest unvisited city and set it as the new current city.
4. Once all cities have been visited, calculate the total travel time by summing up the distances between each pair of consecutive cities.

Time complexity: O(n^2), where n is the number of cities.
Space complexity: O(1), since we only need a constant amount of space to store the current city and unvisited cities list.

## Optimized Solutions
### Java
```java
public class MinimumTravelTime {
    public static double calculate(int[][] coordinates) {
        int n = coordinates.length;
        double totalDistance = 0.0;
        boolean[] visited = new boolean[n];
        
        for (int i = 0; i < n; i++) {
            visited[i] = false;
        }
        
        int currentCity = 0;
        while (true) {
            visited[currentCity] = true;
            
            int minDistance = Integer.MAX_VALUE;
            int nextCity = -1;
            
            for (int j = 0; j < n; j++) {
                if (!visited[j]) {
                    double distance = calculateDistance(coordinates, currentCity, j);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nextCity = j;
                    }
                }
            }
            
            totalDistance += minDistance;
            currentCity = nextCity;
        }
        
        return totalDistance;
    }
    
    private static double calculateDistance(int[][] coordinates, int city1, int city2) {
        return Math.sqrt(Math.pow(coordinates[city2][0] - coordinates[city1][0], 2) + 
                          Math.pow(coordinates[city2][1] - coordinates[city1][1], 2));
    }
}
```

### Python
```python
class MinimumTravelTime:
    def calculate(self, coordinates):
        n = len(coordinates)
        total_distance = 0.0
        visited = [False for _ in range(n)]
        
        current_city = 0
        while True:
            visited[current_city] = True
            
            min_distance = float('inf')
            next_city = -1
            
            for j in range(n):
                if not visited[j]:
                    distance = self.calculate_distance(coordinates, current_city, j)
                    if distance < min_distance:
                        min_distance = distance
                        next_city = j
            total_distance += min_distance
            current_city = next_city
        
        return total_distance
    
    def calculate_distance(self, coordinates, city1, city2):
        return math.sqrt((coordinates[city2][0] - coordinates[city1][0])**2 + 
                          (coordinates[city2][1] - coordinates[city1][1])**2)
```

### C++
```cpp
class MinimumTravelTime {
public:
    double calculate(int** coordinates, int n) {
        double totalDistance = 0.0;
        bool* visited = new bool[n];
        
        for (int i = 0; i < n; i++) {
            visited[i] = false;
        }
        
        int currentCity = 0;
        while (true) {
            visited[currentCity] = true;
            
            double minDistance = INFINITY;
            int nextCity = -1;
            
            for (int j = 0; j < n; j++) {
                if (!visited[j]) {
                    double distance = calculateDistance(coordinates, currentCity, j);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nextCity = j;
                    }
                }
            }
            
            totalDistance += minDistance;
            currentCity = nextCity;
        }
        
        return totalDistance;
    }
    
    double calculateDistance(int** coordinates, int city1, int city2) {
        return sqrt(pow(coordinates[city2][0] - coordinates[city1][0], 2) + 
                    pow(coordinates[city2][1] - coordinates[city1][1], 2));
    }
};
```

### JavaScript
```javascript
class MinimumTravelTime {
    calculate(coordinates) {
        const n = coordinates.length;
        let totalDistance = 0.0;
        let visited = new Array(n).fill(false);
        
        let currentCity = 0;
        while (true) {
            visited[currentCity] = true;
            
            let minDistance = Infinity;
            let nextCity = -1;
            
            for (let j = 0; j < n; j++) {
                if (!visited[j]) {
                    const distance = this.calculateDistance(coordinates, currentCity, j);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nextCity = j;
                    }
                }
            }
            
            totalDistance += minDistance;
            currentCity = nextCity;
        }
        
        return totalDistance;
    }
    
    calculateDistance(coordinates, city1, city2) {
        return Math.sqrt(Math.pow(coordinates[city2][0] - coordinates[city1][0], 2) + 
                          Math.pow(coordinates[city2][1] - coordinates[city1][1], 2));
    }
}
```