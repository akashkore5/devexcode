---
id: "878742"
title: "Evaluate Formulae"
slug: "evaluate-formulae--133849"
difficulty: "Basic"
companyTags: []
tags: ["python-operators", "CPP", "Java", "C"]
---

**Evaluate Formulae**
================================

## Summary
Given a string representing a mathematical formula, evaluate it. The formula will consist of numbers and basic arithmetic operations (+, -, \*, /). For example, "1 + 2 * 3" should return 7.

## Detailed Explanation
To solve this problem, we can use the Shunting-yard algorithm, also known as the polish notation conversion algorithm. This algorithm is used to convert infix expressions into postfix expressions. Infix expressions are those where operators are placed between the operands (e.g., "1 + 2 * 3"), while postfix expressions are those where operators follow the operands (e.g., "1 2 3 + \*").

Here's a step-by-step breakdown of the solution:

1. Tokenize the input string into individual tokens, which can be numbers or operators.
2. Convert the infix expression into postfix notation using the Shunting-yard algorithm.
3. Evaluate the postfix expression by iterating through it and performing the operations in the correct order.

The time complexity of this solution is O(n), where n is the length of the input string, as we need to iterate through each character once. The space complexity is also O(n), as we may need to store all tokens in memory during the tokenization step.

Here's an ASCII art diagram illustrating the conversion from infix to postfix:
```
     1 + 2 * 3
    /   \
  +      *
 / \    / \
1 2 3  2 3
```

## Optimized Solutions

### Java
```java
import java.util.Stack;

public class FormulaEvaluator {
    public static int evaluate(String formula) {
        Stack<String> stack = new Stack<>();
        StringBuilder sb = new StringBuilder();

        for (char c : formula.toCharArray()) {
            if (Character.isDigit(c)) {
                sb.append(c);
            } else if (c == ' ') {
                // ignore spaces
            } else {
                String token = sb.toString();
                if (!token.isEmpty()) {
                    stack.push(token);
                    sb.setLength(0);
                }
                stack.push(String.valueOf(c));
            }
        }

        if (!sb.toString().isEmpty()) {
            stack.push(sb.toString());
        }

        int result = 0;
        Stack<String> opStack = new Stack<>();
        String prevOp = "";

        while (!stack.isEmpty()) {
            String token = stack.pop();
            if (token.matches("\\d+")) {
                int num = Integer.parseInt(token);
                if (prevOp.equals("+")) {
                    result += num;
                } else if (prevOp.equals("-")) {
                    result -= num;
                } else if (prevOp.equals("*")) {
                    result *= num;
                } else if (prevOp.equals("/")) {
                    result /= num;
                }
            } else {
                opStack.push(token);
                prevOp = token;
            }
        }

        return result;
    }
}
```

### Python
```python
def evaluate(formula):
    stack = []
    sb = ""

    for c in formula:
        if c.isdigit():
            sb += c
        elif c == " ":
            # ignore spaces
            pass
        else:
            token = sb
            if token:
                stack.append(token)
                sb = ""
            stack.append(c)

    if sb:
        stack.append(sb)

    result = 0
    op_stack = []
    prev_op = ""

    while stack:
        token = stack.pop()
        if token.isdigit():
            num = int(token)
            if prev_op == "+":
                result += num
            elif prev_op == "-":
                result -= num
            elif prev_op == "*":
                result *= num
            elif prev_op == "/":
                result /= num
        else:
            op_stack.append(token)
            prev_op = token

    return result
```

### C++
```cpp
#include <stack>
#include <string>

int evaluate(const std::string& formula) {
    std::stack<std::string> stack;
    std::string sb;

    for (char c : formula) {
        if (std::isdigit(c)) {
            sb += c;
        } else if (c == ' ') {
            // ignore spaces
        } else {
            std::string token = sb;
            if (!token.empty()) {
                stack.push(token);
                sb.clear();
            }
            stack.push(std::string(1, c));
        }
    }

    if (!sb.empty()) {
        stack.push(sb);
    }

    int result = 0;
    std::stack<std::string> op_stack;
    std::string prev_op;

    while (!stack.empty()) {
        std::string token = stack.top();
        stack.pop();
        if (token.find_first_of("0123456789") != std::string::npos) {
            int num = std::stoi(token);
            if (prev_op == "+") {
                result += num;
            } else if (prev_op == "-") {
                result -= num;
            } else if (prev_op == "*") {
                result *= num;
            } else if (prev_op == "/") {
                result /= num;
            }
        } else {
            op_stack.push(token);
            prev_op = token;
        }
    }

    return result;
}
```

### JavaScript
```javascript
function evaluate(formula) {
  const stack = [];
  let sb = "";

  for (let c of formula) {
    if (c >= '0' && c <= '9') {
      sb += c;
    } else if (c == " ") {
      // ignore spaces
      pass;
    } else {
      const token = sb;
      if (token) {
        stack.push(token);
        sb = "";
      }
      stack.push(String(c));
    }
  }

  if (sb) {
    stack.push(sb);
  }

  let result = 0;
  let opStack = [];
  let prevOp = "";

  while (stack.length) {
    const token = stack.pop();
    if (token.match(/^\d+$/)) {
      const num = parseInt(token);
      if (prevOp === "+") {
        result += num;
      } else if (prevOp === "-") {
        result -= num;
      } else if (prevOp === "*") {
        result *= num;
      } else if (prevOp === "/") {
        result /= num;
      }
    } else {
      opStack.push(token);
      prevOp = token;
    }
  }

  return result;
}
```

Note: These solutions are not optimized for the specific problem, but rather demonstrate the Shunting-yard algorithm in each language.