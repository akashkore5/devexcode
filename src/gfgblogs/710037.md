---
id: "710037"
title: "Find shortest safe route in a matrix"
slug: "find-shortest-safe-route-in-a-matrix"
difficulty: "Medium"
companyTags: []
tags: ["DFS", "Graph"]
---

Here is a detailed Markdown blog post for the problem:

# Find shortest safe route in a matrix
## Slug: find-shortest-safe-route-in-a-matrix
## Difficulty: Medium
## Id: 710037
## Topic Tags: DFS, Graph
## Company Tags: None


### Summary
Given a binary matrix, find the shortest path from the top left cell to the bottom right cell while avoiding cells with value 0. This problem involves graph traversal and dynamic programming concepts.


### Detailed Explanation
The approach is based on Depth-First Search (DFS) algorithm. The DFS starts from the top-left cell and explores all neighboring cells that have a value of 1 until it reaches the bottom-right cell. We keep track of the minimum distance to reach each cell.

Here's a step-by-step breakdown:

* Initialize the distances array with infinite values for all cells.
* Start DFS from the top-left cell (0,0) and explore all neighboring cells that have a value of 1 in increasing order of their Manhattan distance.
* If we find the bottom-right cell (m-1,n-1), return the distance as it is the shortest safe route.
* If we encounter a cell with value 0 or exceed the boundaries of the matrix, backtrack and explore another path.

Here's an ASCII art diagram to illustrate this:

```
  +-----+-----+
  |     |     |
  +-----+-----+
  | 0   | 1   |
  +-----+-----+
  |     |     |
  +-----+-----+
  | 1   | 1   |
  +-----+-----+
  |     |     |
  +-----+-----+
```

Time complexity: O(mn) where m is the number of rows and n is the number of columns in the matrix.
Space complexity: O(mn) for storing distances.


### Optimized Solutions

#### Java
```java
public class Main {
    public static void main(String[] args) {
        int[][] grid = {
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {0, 0, 1, 1}
        };
        System.out.println(shortestSafeRoute(grid));
    }

    public static int shortestSafeRoute(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] distances = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(distances[i], Integer.MAX_VALUE);
        }
        dfs(grid, distances, 0, 0);
        return distances[m-1][n-1];
    }

    public static void dfs(int[][] grid, int[][] distances, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) return;
        if (distances[i][j] != Integer.MAX_VALUE) return;
        distances[i][j] = 1 + Math.min(Math.min(dfs(grid, distances, i-1, j), dfs(grid, distances, i+1, j)), dfs(grid, distances, i, j-1));
    }
}
```

#### Python
```python
def shortest_safe_route(grid):
    m, n = len(grid), len(grid[0])
    distances = [[float('inf')] * n for _ in range(m)]
    dfs(grid, distances, 0, 0)
    return distances[m-1][n-1]

def dfs(grid, distances, i, j):
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
        return
    if distances[i][j] != float('inf'):
        return
    distances[i][j] = 1 + min(min(dfs(grid, distances, i-1, j), dfs(grid, distances, i+1, j)), dfs(grid, distances, i, j-1))
```

#### C++
```cpp
#include <iostream>
using namespace std;

int shortestSafeRoute(int grid[][3][3]) {
    int m = sizeof(grid) / sizeof(grid[0]);
    int n = sizeof(grid[0]) / sizeof(grid[0][0]);
    int distances[m][n];
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            distances[i][j] = INT_MAX;
        }
    }
    dfs(grid, distances, 0, 0);
    return distances[m-1][n-1];
}

void dfs(int grid[][3][3], int distances[][3][3], int i, int j) {
    if (i < 0 || i >= sizeof(grid) / sizeof(grid[0]) ||
        j < 0 || j >= sizeof(grid[0]) / sizeof(grid[0][0]) ||
        grid[i][j][0] == 0) return;
    if (distances[i][j] != INT_MAX) return;
    distances[i][j] = 1 + min(min(dfs(grid, distances, i-1, j), dfs(grid, distances, i+1, j)),
                                  dfs(grid, distances, i, j-1));
}
```

#### JavaScript
```javascript
function shortestSafeRoute(grid) {
    let m = grid.length;
    let n = grid[0].length;
    let distances = new Array(m).fill().map(() => new Array(n).fill(Infinity));
    dfs(grid, distances, 0, 0);
    return distances[m-1][n-1];
}

function dfs(grid, distances, i, j) {
    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] === 0) return;
    if (distances[i][j] !== Infinity) return;
    distances[i][j] = 1 + Math.min(Math.min(dfs(grid, distances, i-1, j), dfs(grid, distances, i+1, j)), dfs(grid, distances, i, j-1));
}
```

I hope this helps! Let me know if you have any questions or need further clarification.