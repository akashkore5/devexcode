---
id: "712184"
title: "Grid Path 2"
slug: "grid-path-2"
difficulty: "Medium"
companyTags: []
tags: ["Matrix", "Dynamic Programming", "Arrays", "Data Structures", "Algorithms"]
---

**Grid Path 2**
================

### Slug: grid-path-2
### Difficulty: Medium
### Id: 712184
### Topic Tags: Matrix, Dynamic Programming, Arrays, Data Structures, Algorithms

## Summary
The problem "Grid Path 2" involves finding the shortest path in a grid that starts at a given cell and ends at another specified cell. The problem can be solved using dynamic programming concepts.

## Detailed Explanation

Given a grid of size `m` x `n`, where each cell contains a value, we need to find the shortest path from a starting point `(x1, y1)` to an ending point `(x2, y2)`. The cells are connected if they share an edge (i.e., either horizontally or vertically). Each step can only be taken in one of four directions: up, down, left, or right.

To solve this problem, we can use dynamic programming. We will create a 2D array `dp` of size `(m+1) x (n+1)` to store the minimum distance from each cell to the starting point. The base case is when the current cell is the starting point, in which case the minimum distance is 0.

For each cell, we consider all possible moves: up, down, left, or right. If a move is valid (i.e., it does not go out of bounds), and the new cell has not been visited before, we update the `dp` array with the minimum distance plus the value of the current cell.

The final answer will be stored in the cell corresponding to the ending point `(x2, y2)`.

Here is a step-by-step breakdown of the solution:
```
1. Initialize dp array with infinity for all cells.
2. Set dp[x1][y1] = 0 as it's the starting point.
3. For each cell (i, j) in the grid:
   - If the current cell is out of bounds or has been visited before, skip to the next cell.
   - Consider all possible moves: up, down, left, or right.
     - For each move:
       - Check if the new cell is within bounds and hasn't been visited before.
       - If it's a valid move, update dp[i][j] with the minimum distance plus the value of the current cell.
4. The final answer will be stored in dp[x2][y2].
```
Time complexity: O(m * n)
Space complexity: O(m * n)

## Optimized Solutions

### Java
```java
public class GridPath {
    public static int minPath(int[][] grid, int x1, int y1, int x2, int y2) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m+1][n+1];
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        dp[x1][y1] = 0;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == x1 && j == y1) continue;
                int minDist = Integer.MAX_VALUE;
                if (i > 0 && dp[i-1][j] + grid[i-1][j] < minDist) minDist = dp[i-1][j] + grid[i-1][j];
                if (i < m && dp[i+1][j] + grid[i+1][j] < minDist) minDist = dp[i+1][j] + grid[i+1][j];
                if (j > 0 && dp[i][j-1] + grid[i][j-1] < minDist) minDist = dp[i][j-1] + grid[i][j-1];
                if (j < n && dp[i][j+1] + grid[i][j+1] < minDist) minDist = dp[i][j+1] + grid[i][j+1];
                dp[i][j] = minDist;
            }
        }
        return dp[x2][y2];
    }
}
```

### Python
```python
def min_path(grid, x1, y1, x2, y2):
    m, n = len(grid), len(grid[0])
    dp = [[float('inf')] * (n+1) for _ in range(m+1)]
    dp[x1][y1] = 0
    for i in range(1, m+1):
        for j in range(1, n+1):
            if i == x1 and j == y1: continue
            min_dist = float('inf')
            if i > 0: min_dist = min(min_dist, dp[i-1][j] + grid[i-1][j])
            if i < m: min_dist = min(min_dist, dp[i+1][j] + grid[i+1][j])
            if j > 0: min_dist = min(min_dist, dp[i][j-1] + grid[i][j-1])
            if j < n: min_dist = min(min_dist, dp[i][j+1] + grid[i][j+1])
            dp[i][j] = min_dist
    return dp[x2][y2]
```

### C++
```cpp
#include <vector>
using namespace std;

int minPath(vector<vector<int>>& grid, int x1, int y1, int x2, int y2) {
    int m = grid.size();
    int n = grid[0].size();
    vector<vector<int>> dp(m+1, vector<int>(n+1));
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= n; j++) {
            dp[i][j] = INT_MAX;
        }
    }
    dp[x1][y1] = 0;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (i == x1 && j == y1) continue;
            int minDist = INT_MAX;
            if (i > 0) minDist = min(minDist, dp[i-1][j] + grid[i-1][j]);
            if (i < m) minDist = min(minDist, dp[i+1][j] + grid[i+1][j]);
            if (j > 0) minDist = min(minDist, dp[i][j-1] + grid[i][j-1]);
            if (j < n) minDist = min(minDist, dp[i][j+1] + grid[i][j+1]);
            dp[i][j] = minDist;
        }
    }
    return dp[x2][y2];
}
```

### JavaScript
```javascript
function minPath(grid, x1, y1, x2, y2) {
    let m = grid.length;
    let n = grid[0].length;
    let dp = new Array(m+1).fill(0).map(() => new Array(n+1).fill(Number.MAX_VALUE));
    dp[x1][y1] = 0;
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (i == x1 && j == y1) continue;
            let minDist = Number.MAX_VALUE;
            if (i > 0) minDist = Math.min(minDist, dp[i-1][j] + grid[i-1][j]);
            if (i < m) minDist = Math.min(minDist, dp[i+1][j] + grid[i+1][j]);
            if (j > 0) minDist = Math.min(minDist, dp[i][j-1] + grid[i][j-1]);
            if (j < n) minDist = Math.min(minDist, dp[i][j+1] + grid[i][j+1]);
            dp[i][j] = minDist;
        }
    }
    return dp[x2][y2];
}
```