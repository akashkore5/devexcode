---
id: "703326"
title: "Smallest Subarray GCD"
slug: "smallest-sub-array4107"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Segment-Tree", "Data Structures", "Advanced Data Structure"]
---

**Smallest Subarray GCD**
================================

### Summary
Find the smallest subarray with a Greatest Common Divisor (GCD) equal to `k`. Given an array of integers, find the smallest contiguous subarray whose GCD is equal to `k`.

### Detailed Explanation
To solve this problem, we can use a segment tree data structure. The idea is to maintain a segment tree where each node represents the GCD of its corresponding range in the original array.

Here's a step-by-step breakdown:

1. Initialize an empty segment tree.
2. Traverse the input array and for each element `x`, update the segment tree as follows:
	* If the current node represents a range that includes `x`, calculate the new GCD by updating the GCD of the current node with `x`.
	* Otherwise, create a new node in the segment tree representing the range `[start, x]` (where `start` is the start index of the current node) and update its value to be the GCD of this new range.
3. Once the segment tree is constructed, traverse it to find the smallest subarray with a GCD equal to `k`. This can be done by iterating through the nodes in the segment tree and checking if the GCD of each node equals `k`.

Time complexity: O(n log n) where `n` is the size of the input array.
Space complexity: O(n) for the segment tree.

### Optimized Solutions

#### Java
```java
class SmallestSubarrayGCD {
    public static int findSmallestSubarray(int[] arr, int k) {
        int n = arr.length;
        SegmentTree tree = new SegmentTree(arr);
        int ans = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            if (tree.query(i, i) == k) {
                ans = Math.min(ans, i - tree.getStart());
            }
        }
        return ans;
    }

    static class SegmentTree {
        int[] tree;
        int start;

        public SegmentTree(int[] arr) {
            int n = arr.length;
            tree = new int[n + 1];
            start = 0;
            buildTree(arr);
        }

        void buildTree(int[] arr) {
            for (int i = n; i > 0; i--) {
                tree[i] = gcd(tree[i - 1], arr[i - 1]);
            }
        }

        int query(int l, int r) {
            return query(r) - query(l);
        }

        int query(int i) {
            int ans = tree[i];
            while (i > 0) {
                ans = gcd(ans, tree[i - 1]);
                i--;
            }
            return ans;
        }

        int gcd(int a, int b) {
            if (b == 0) {
                return a;
            }
            return gcd(b, a % b);
        }

        int getStart() {
            for (int i = tree.length - 1; i > 0; i--) {
                if (tree[i] == 1) {
                    return i;
                }
            }
            return 0;
        }
    }
}
```

#### Python
```python
class SmallestSubarrayGCD:
    def find_smallest_subarray(self, arr, k):
        n = len(arr)
        tree = self.build_tree(arr)
        ans = float('inf')
        for i in range(n):
            if self.query(tree, i, i) == k:
                ans = min(ans, i - tree.get_start())
        return ans

    def build_tree(self, arr):
        n = len(arr)
        tree = [0] * (n + 1)
        start = 0
        for i in range(n, -1, -1):
            tree[i] = self.gcd(tree[i - 1], arr[i - 1])
        return tree

    def query(self, tree, l, r):
        return self.query(tree, r) - self.query(tree, l)

    def query(self, tree, i):
        ans = tree[i]
        while i > 0:
            ans = self.gcd(ans, tree[i - 1])
            i -= 1
        return ans

    def gcd(self, a, b):
        if b == 0:
            return a
        return self.gcd(b, a % b)

    def get_start(self, tree):
        for i in range(len(tree) - 1, -1, -1):
            if tree[i] == 1:
                return i
        return 0
```

#### C++
```cpp
class SmallestSubarrayGCD {
public:
    int findSmallestSubarray(int* arr, int n, int k) {
        SegmentTree tree(arr, n);
        int ans = INT_MAX;
        for (int i = 0; i < n; i++) {
            if (tree.query(i, i) == k) {
                ans = min(ans, i - tree.getStart());
            }
        }
        return ans;
    }

private:
    struct SegmentTree {
        int* tree;
        int start;

        SegmentTree(int* arr, int n) {
            tree = new int[n + 1];
            start = 0;
            buildTree(arr);
        }

        ~SegmentTree() { delete[] tree; }

        void buildTree(int* arr) {
            for (int i = n; i > 0; i--) {
                tree[i] = gcd(tree[i - 1], arr[i - 1]);
            }
        }

        int query(int l, int r) { return query(r) - query(l); }

        int query(int i) {
            int ans = tree[i];
            while (i > 0) {
                ans = gcd(ans, tree[i - 1]);
                i--;
            }
            return ans;
        }

        int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }

        int getStart() {
            for (int i = tree[tree.length - 1]; i > 0; i--) {
                if (tree[i] == 1) {
                    return i;
                }
            }
            return 0;
        }
    };
};
```

#### JavaScript
```javascript
class SmallestSubarrayGCD {
    findSmallestSubarray(arr, k) {
        const n = arr.length;
        let tree = [];
        let start = 0;
        for (let i = 0; i < n; i++) {
            if (!tree[i]) {
                tree.push(gcd(tree[tree.length - 1], arr[i]));
            } else {
                start = i;
                break;
            }
        }
        let ans = Infinity;
        for (let i = 0; i < n; i++) {
            if (query(tree, i, i) === k) {
                ans = Math.min(ans, i - start);
            }
        }
        return ans;
    }

    query(tree, l, r) {
        return query(tree, r) - query(tree, l);
    }

    query(tree, i) {
        let ans = tree[i];
        while (i > 0) {
            ans = gcd(ans, tree[i - 1]);
            i--;
        }
        return ans;
    }

    gcd(a, b) {
        if (!b) {
            return a;
        } else {
            return gcd(b, a % b);
        }
    }
}
```

Note: The above code assumes that the input array is 0-indexed.