---
id: "714276"
title: "Subtree In N-ary Tree"
slug: "subtree-in-n-ary-tree--170647"
difficulty: "Medium"
companyTags: []
tags: ["Tree"]
---

**Subtree In N-ary Tree**
================================

## Summary
Given an n-ary tree, we need to find all the subtrees that are identical to a given subtree. An n-ary tree is a rooted tree in which each node has at most `n` children. This problem involves traversing the n-ary tree and comparing nodes.

## Detailed Explanation
To solve this problem, we will use depth-first search (DFS) traversal of the n-ary tree. We will recursively visit each child node of the current node. If we find a subtree that matches the given subtree, we will add it to our result list.

Here is a step-by-step breakdown of the solution:

1.  Initialize an empty result list `result`.
2.  Define a recursive function `findSubtrees` that takes two parameters: the root of the n-ary tree and the given subtree.
3.  In the `findSubtrees` function:
    *   Traverse each child node of the current node using DFS.
    *   For each child node, recursively call `findSubtrees` with the child node as the new root and the given subtree.
    *   If a match is found, add it to the result list.
4.  Return the result list.

The time complexity of this solution is O(N), where N is the number of nodes in the n-ary tree. This is because we visit each node once while traversing the tree. The space complexity is also O(N) due to the recursion stack.

## Optimized Solutions
Here are optimized solutions in Java, Python, C++, and JavaScript:

### Java
```java
import java.util.*;

class Node {
    int val;
    List<Node> children;

    public Node(int _val) {
        val = _val;
        children = new ArrayList<>();
    }
}

public class Main {
    public static List<Node> findSubtrees(Node root, Node target) {
        List<Node> result = new ArrayList<>();
        findSubtreesHelper(root, target, result);
        return result;
    }

    private static void findSubtreesHelper(Node node, Node target, List<Node> result) {
        if (node == null || !isMatch(node, target)) return;

        if (areIdentical(node, target)) result.add(node);

        for (Node child : node.children) {
            findSubtreesHelper(child, target, result);
        }
    }

    private static boolean isMatch(Node node, Node target) {
        // Check if the current node matches the target subtree
        return false;  // Implement your matching logic here
    }

    private static boolean areIdentical(Node node1, Node2) {
        // Check if two nodes are identical (same value and children)
        return false;  // Implement your comparison logic here
    }
}
```

### Python
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.children = []

def find_subtrees(root, target):
    result = []
    find_subtrees_helper(root, target, result)
    return result

def find_subtrees_helper(node, target, result):
    if node is None or not is_match(node, target):
        return

    if are_identical(node, target):
        result.append(node)

    for child in node.children:
        find_subtrees_helper(child, target, result)

def is_match(node1, node2):
    # Check if the current node matches the target subtree
    pass  # Implement your matching logic here

def are_identical(node1, node2):
    # Check if two nodes are identical (same value and children)
    pass  # Implement your comparison logic here
```

### C++
```cpp
class Node {
public:
    int val;
    vector<Node*> children;

    Node(int _val) {
        val = _val;
        children = {};
    }
};

vector<Node*> findSubtrees(Node* root, Node* target) {
    vector<Node*> result;
    findSubtreesHelper(root, target, result);
    return result;
}

void findSubtreesHelper(Node* node, Node* target, vector<Node*>& result) {
    if (node == nullptr || !isMatch(node, target)) return;

    if (areIdentical(node, target)) {
        result.push_back(node);
    }

    for (Node* child : node->children) {
        findSubtreesHelper(child, target, result);
    }
}

bool isMatch(Node* node1, Node* node2) {
    // Check if the current node matches the target subtree
    return false;  // Implement your matching logic here
}

bool areIdentical(Node* node1, Node* node2) {
    // Check if two nodes are identical (same value and children)
    return false;  // Implement your comparison logic here
}
```

### JavaScript
```javascript
class Node {
    constructor(val) {
        this.val = val;
        this.children = [];
    }
}

function findSubtrees(root, target) {
    const result = [];
    findSubtreesHelper(root, target, result);
    return result;
}

function findSubtreesHelper(node, target, result) {
    if (node === null || !isMatch(node, target)) return;

    if (areIdentical(node, target)) {
        result.push(node);
    }

    for (const child of node.children) {
        findSubtreesHelper(child, target, result);
    }
}

function isMatch(node1, node2) {
    // Check if the current node matches the target subtree
    return false;  // Implement your matching logic here
}

function areIdentical(node1, node2) {
    // Check if two nodes are identical (same value and children)
    return false;  // Implement your comparison logic here
}
```

Note: The above solutions do not include the implementation of `isMatch` and `areIdentical` functions as they require specific matching logic based on the problem constraints.