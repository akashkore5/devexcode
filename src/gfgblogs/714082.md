---
id: "714082"
title: "Taxi Booking"
slug: "taxi-booking--170647"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Greedy", "Data Structures", "Algorithms"]
---

**Taxi Booking**
================

## Summary
The Taxi Booking problem involves booking a taxi service. The algorithm should take an array of requests and their respective durations, and return the minimum number of taxis needed to fulfill all requests without overlapping.

This problem requires a greedy approach, as we need to minimize the number of taxis by minimizing the overlapping time slots.

## Detailed Explanation
The solution to this problem involves iterating through the array of requests and their durations. We maintain a variable `taxis` which keeps track of the minimum number of taxis needed at any given point in time.

We start by initializing `taxis` to 1, as we need at least one taxi initially. Then, for each request in the array:

* If the current request starts after the previous one ended (i.e., there's no overlap), we can reuse the same taxi, so we don't increment `taxis`.
* If the current request overlaps with the previous one, we need to use a new taxi to fulfill this request. In this case, we increment `taxis`.

Finally, we return the value of `taxis`, which represents the minimum number of taxis needed.

Here's a step-by-step breakdown of the solution:

1. Initialize `taxis` to 1.
2. Iterate through the array of requests and their durations.
3. For each request:
	* If the current request starts after the previous one ended, do nothing (reuse the same taxi).
	* If the current request overlaps with the previous one, increment `taxis`.
4. Return the value of `taxis`.

Time complexity: O(n), where n is the number of requests in the array.
Space complexity: O(1), as we only use a constant amount of space to store the `taxis` variable.

## Optimized Solutions

### Java
```java
public int minTaxis(int[] requests) {
    int taxis = 1;
    for (int request : requests) {
        if (request > taxis) {
            taxis++;
        }
    }
    return taxis;
}
```

### Python
```python
def min_taxis(requests):
    taxis = 1
    for request in requests:
        if request > taxis:
            taxis += 1
    return taxis
```

### C++
```cpp
int minTaxis(int* requests, int n) {
    int taxis = 1;
    for (int i = 0; i < n; i++) {
        if (requests[i] > taxis) {
            taxis++;
        }
    }
    return taxis;
}
```

### JavaScript
```javascript
function minTaxis(requests) {
    let taxis = 1;
    for (let request of requests) {
        if (request > taxis) {
            taxis++;
        }
    }
    return taxis;
}
```