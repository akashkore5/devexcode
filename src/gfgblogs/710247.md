---
id: "710247"
title: "Minimum time taken by each job to be completed given by a Directed Acyclic Graph"
slug: "minimum-time-taken-by-each-job-to-be-completed-given-by-a-directed-acyclic-graph"
difficulty: "Medium"
companyTags: []
tags: []
---

# Minimum time taken by each job to be completed given by a Directed Acyclic Graph
## Summary
Given a directed acyclic graph (DAG) where each node represents a job and the edges represent the dependencies between jobs, find the minimum time taken by each job to be completed. The minimum time for a job is the maximum time it takes to complete all its dependent jobs.

## Detailed Explanation

To solve this problem, we can use Topological Sorting (TS) algorithm. TS is an ordering of vertices in a directed acyclic graph such that for every edge (u,v), vertex u comes before v in the ordering.

Here's a step-by-step breakdown of the solution:

1.  Perform a DFS on the given DAG and keep track of the visited nodes.
2.  During the DFS, calculate the in-degree of each node (i.e., the number of edges pointing to it).
3.  Initialize an empty queue and add all nodes with zero in-degree to the queue.
4.  While the queue is not empty:
    *   Dequeue a node from the queue.
    *   For each neighbor of the dequeued node, decrement its in-degree by one.
    *   If the in-degree becomes zero for any neighbor, add it to the queue.
5.  The order in which nodes are dequeued from the queue is the topological sorting.

Now that we have the topological sorting, we can calculate the minimum time taken by each job as follows:

1.  Initialize a variable `minTime` to store the minimum time for each job.
2.  For each node in the topological sorting:
    *   Calculate its minimum time by taking the maximum of its own processing time and the minimum times of all its dependent jobs.
    *   Update `minTime` with this calculated value.

The time complexity of this solution is O(V + E), where V is the number of nodes (jobs) and E is the number of edges (dependencies). The space complexity is O(V), as we need to store the visited nodes, in-degrees, and the queue.

## Optimized Solutions

### Java
```java
import java.util.*;

class Job {
    int id;
    int processingTime;
    List<Job> dependencies;

    Job(int id, int processingTime) {
        this.id = id;
        this.processingTime = processingTime;
        this.dependencies = new ArrayList<>();
    }
}

public class Main {
    public static void main(String[] args) {
        // Create the DAG
        Job job1 = new Job(1, 3);
        Job job2 = new Job(2, 2);
        Job job3 = new Job(3, 5);
        Job job4 = new Job(4, 1);
        Job job5 = new Job(5, 4);

        job1.dependencies.add(job2);
        job1.dependencies.add(job4);
        job3.dependencies.add(job4);
        job4.dependencies.add(job5);

        // Perform Topological Sorting
        List<Job> topologicalOrdering = new ArrayList<>();
        Map<Job, Integer> inDegrees = new HashMap<>();
        for (Job job : Arrays.asList(job1, job2, job3, job4, job5)) {
            if (!inDegrees.containsKey(job)) {
                inDegrees.put(job, 0);
            }
            for (Job dependency : job.dependencies) {
                inDegrees.put(dependency, inDegrees.getOrDefault(dependency, 0) + 1);
            }
        }

        Queue<Job> queue = new LinkedList<>();
        for (Map.Entry<Job, Integer> entry : inDegrees.entrySet()) {
            if (entry.getValue() == 0) {
                queue.add(entry.getKey());
            }
        }

        while (!queue.isEmpty()) {
            Job job = queue.poll();
            topologicalOrdering.add(job);
            for (Job dependency : job.dependencies) {
                inDegrees.put(dependency, inDegrees.get(dependency) - 1);
                if (inDegrees.get(dependency) == 0) {
                    queue.add(dependency);
                }
            }
        }

        // Calculate the minimum time taken by each job
        Map<Job, Integer> minTimes = new HashMap<>();
        for (Job job : topologicalOrdering) {
            int minTime = Math.max(job.processingTime, Collections.max(job.dependencies, Comparator.comparingInt(dependency -> dependency.processingTime).thenComparing(Int::intValue)).processingTime);
            minTimes.put(job, minTime);
        }

        // Print the minimum time taken by each job
        for (Map.Entry<Job, Integer> entry : minTimes.entrySet()) {
            System.out.println("Job " + entry.getKey().id + ": " + entry.getValue());
        }
    }
}
```

### Python
```python
class Job:
    def __init__(self, id, processing_time):
        self.id = id
        self.processing_time = processing_time
        self.dependencies = []

def topological_sort(graph):
    in_degrees = {job: 0 for job in graph}
    queue = []
    for job in graph:
        if not in_degrees[job]:
            queue.append(job)
    while queue:
        job = queue.pop(0)
        yield job
        for dependency in job.dependencies:
            in_degrees[dependency] -= 1
            if not in_degrees[dependency]:
                queue.append(dependency)

def calculate_min_time(graph):
    min_times = {}
    for job in topological_sort(graph):
        min_time = max(job.processing_time, max(dependency.processing_time for dependency in job.dependencies))
        min_times[job] = min_time
    return min_times

# Create the DAG
job1 = Job(1, 3)
job2 = Job(2, 2)
job3 = Job(3, 5)
job4 = Job(4, 1)
job5 = Job(5, 4)

graph = [job1, job2, job3, job4, job5]
job1.dependencies.append(job2)
job1.dependencies.append(job4)
job3.dependencies.append(job4)
job4.dependencies.append(job5)

# Perform Topological Sorting
topological_ordering = list(topological_sort(graph))

# Calculate the minimum time taken by each job
min_times = calculate_min_time(graph)

# Print the minimum time taken by each job
for job, min_time in min_times.items():
    print(f"Job {job.id}: {min_time}")
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <queue>

class Job {
public:
    int id;
    int processingTime;
    std::vector<Job*> dependencies;

    Job(int id, int processingTime) {
        this->id = id;
        this->processingTime = processingTime;
        this->dependencies = {};
    }
};

void topologicalSort(std::vector<Job*>& graph) {
    std::map<Job*, int> inDegrees;
    std::queue<Job*> queue;

    for (auto job : graph) {
        if (!inDegrees.count(job)) {
            inDegrees[job] = 0;
        }
        for (auto dependency : job->dependencies) {
            inDegrees[dependency]++;
        }
    }

    while (!queue.empty()) {
        Job* job = queue.front();
        queue.pop();
        std::cout << "Job " << job->id << ": " << job->processingTime << "\n";

        for (auto dependency : job->dependencies) {
            inDegrees[dependency]--;
            if (!inDegrees[dependency]) {
                queue.push(dependency);
            }
        }
    }
}

int main() {
    // Create the DAG
    Job* job1 = new Job(1, 3);
    Job* job2 = new Job(2, 2);
    Job* job3 = new Job(3, 5);
    Job* job4 = new Job(4, 1);
    Job* job5 = new Job(5, 4);

    graph.push_back(job1);
    graph.push_back(job2);
    graph.push_back(job3);
    graph.push_back(job4);
    graph.push_back(job5);

    job1->dependencies.push_back(job2);
    job1->dependencies.push_back(job4);
    job3->dependencies.push_back(job4);
    job4->dependencies.push_back(job5);

    // Perform Topological Sorting
    topologicalSort(graph);

    return 0;
}
```

### Java
```java
import java.util.*;

class Job {
    int id;
    int processingTime;
    List<Job> dependencies;

    public Job(int id, int processingTime) {
        this.id = id;
        this.processingTime = processingTime;
        this.dependencies = new ArrayList<>();
    }
}

public class Main {
    public static void main(String[] args) {
        // Create the DAG
        Job job1 = new Job(1, 3);
        Job job2 = new Job(2, 2);
        Job job3 = new Job(3, 5);
        Job job4 = new Job(4, 1);
        Job job5 = new Job(5, 4);

        List<Job> graph = new ArrayList<>();
        graph.add(job1);
        graph.add(job2);
        graph.add(job3);
        graph.add(job4);
        graph.add(job5);

        job1.dependencies.add(job2);
        job1.dependencies.add(job4);
        job3.dependencies.add(job4);
        job4.dependencies.add(job5);

        // Perform Topological Sorting
        List<Job> topologicalOrdering = new ArrayList<>();
        Map<Job, Integer> inDegrees = new HashMap<>();

        for (Job job : graph) {
            if (!inDegrees.containsKey(job)) {
                inDegrees.put(job, 0);
            }
            for (Job dependency : job.dependencies) {
                inDegrees.put(dependency, inDegrees.getOrDefault(dependency, 0) + 1);
            }
        }

        Queue<Job> queue = new LinkedList<>();

        for (Map.Entry<Job, Integer> entry : inDegrees.entrySet()) {
            if (entry.getValue() == 0) {
                queue.add(entry.getKey());
            }
        }

        while (!queue.isEmpty()) {
            Job job = queue.poll();
            topologicalOrdering.add(job);
            for (Job dependency : job.dependencies) {
                inDegrees.put(dependency, inDegrees.get(dependency) - 1);
                if (inDegrees.get(dependency) == 0) {
                    queue.add(dependency);
                }
            }
        }

        // Calculate the minimum time taken by each job
        Map<Job, Integer> minTimes = new HashMap<>();

        for (Job job : topologicalOrdering) {
            int minTime = Math.max(job.processingTime, Collections.max(job.dependencies, Comparator.comparingInt(dependency -> dependency.processingTime).thenComparing(Int::intValue)).processingTime);
            minTimes.put(job, minTime);
        }

        // Print the minimum time taken by each job
        for (Map.Entry<Job, Integer> entry : minTimes.entrySet()) {
            System.out.println("Job " + entry.getKey().id + ": " + entry.getValue());
        }
    }
}
```

Feel free to modify the code according to your needs and preferences.