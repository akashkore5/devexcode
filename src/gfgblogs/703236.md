---
id: "703236"
title: "Product Pair"
slug: "equal-to-product3836"
difficulty: "Medium"
companyTags: ["Amazon", "Visa"]
tags: ["Arrays", "Data Structures"]
---

**Product Pair**
================

### Summary
Given an array `arr` and two integers `k1` and `k2`, find all pairs `(a, b)` in the array such that `a * b = k1 * k2`. The problem is about finding product pairs in an array based on the tags "Arrays" and "Data Structures".

### Detailed Explanation
The problem can be solved by iterating through the array and checking each pair of elements to see if their product equals `k1 * k2`. Since we need all such pairs, we'll store them in a result set. Here's a step-by-step breakdown of the solution:

1. Initialize an empty list or vector `result` to store the product pairs.
2. Iterate through the array using two nested loops. The outer loop iterates over each element `a` in the array, and the inner loop iterates over each element `b` that comes after `a`.
3. For each pair `(a, b)`, calculate their product `p`. If `p` equals `k1 * k2`, add the pair to the result set.
4. After iterating through the entire array, return the result set containing all product pairs.

Here's an ASCII art diagram of the algorithm:
```
          +---------------+
          |  Iterate over  |
          |  each element a  |
          +---------------+
                  |
                  v
+---------------+       +---------------+
|  Inner loop:   |       |  Calculate p = a * b  |
|  iterate over   |       |  If p == k1 * k2, add (a, b)  |
|  elements after |       |  to the result set     |
+---------------+       +---------------+
```
The time complexity of this algorithm is O(n^2), where `n` is the size of the array. This is because we're using two nested loops to iterate through the array. The space complexity is O(n), as in the worst-case scenario, we might need to store all pairs in the result set.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class ProductPair {
    public List<int[]> findPairs(int[] arr, int k1, int k2) {
        List<int[]> result = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] * arr[j] == k1 * k2) {
                    result.add(new int[] {arr[i], arr[j]});
                }
            }
        }
        return result;
    }
}
```

#### Python
```python
def find_pairs(arr, k1, k2):
    result = []
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] * arr[j] == k1 * k2:
                result.append([arr[i], arr[j]])
    return result
```

#### C++
```cpp
#include <vector>
#include <algorithm>

std::vector<std::pair<int, int>> findPairs(int* arr, int n, int k1, int k2) {
    std::vector<std::pair<int, int>> result;
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] * arr[j] == k1 * k2) {
                result.push_back(std::make_pair(arr[i], arr[j]));
            }
        }
    }
    return result;
}
```

#### JavaScript
```javascript
function findPairs(arr, k1, k2) {
    let result = [];
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] * arr[j] === k1 * k2) {
                result.push([arr[i], arr[j]]);
            }
        }
    }
    return result;
}
```