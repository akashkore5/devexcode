---
id: "713140"
title: "Shortest Prime Path"
slug: "shortest-prime-path--170645"
difficulty: "Medium"
companyTags: ["Adobe"]
tags: ["Prime Number", "Shortest Path", "BFS", "Algorithms"]
---

# Shortest Prime Path

## Summary
The Shortest Prime Path problem involves finding the shortest path in a grid from a given starting point to a target point, where each cell contains a prime number. The algorithm should be efficient and able to handle large grids.

## Detailed Explanation
To solve this problem, we can use Breadth-First Search (BFS) with some modifications to accommodate the prime numbers constraint. Here's a step-by-step breakdown of the solution:

1. Initialize a queue with the starting point (x1, y1).
2. Mark the starting point as visited.
3. Repeat the following steps until the queue is empty:
   - Dequeue the next cell (x, y) and check if it's the target point. If so, return the distance traveled so far (i.e., the number of cells in the path).
   - For each neighboring cell (x', y') that has not been visited yet, check if its value is a prime number.
     - If it is, mark it as visited and enqueue it along with its distance from the starting point.
4. If the queue becomes empty without finding the target point, return -1 to indicate that there's no path.

To determine whether a number is prime, we can use the following helper function:

```
function isPrime(n) {
  if (n <= 1) return false;
  for (int i = 2; i * i <= n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
```

The time complexity of this algorithm is O(m*n + k), where m and n are the dimensions of the grid, and k is the number of prime numbers in the path. The space complexity is O(m*n), as we need to store the visited cells.

## Optimized Solutions

### Java
```java
import java.util.LinkedList;
import java.util.Queue;

public class ShortestPrimePath {
    public int shortestPrimePath(int[][] grid, int x1, int y1, int x2, int y2) {
        int m = grid.length;
        int n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{x1, y1});
        visited[x1][y1] = true;
        int distance = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cell = queue.poll();
                if (cell[0] == x2 && cell[1] == y2) return distance;
                for (int dx : {-1, 0, 1}) {
                    for (int dy : {-1, 0, 1}) {
                        int nx = cell[0] + dx;
                        int ny = cell[1] + dy;
                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && isPrime(grid[nx][ny])) {
                            queue.add(new int[]{nx, ny});
                            visited[nx][ny] = true;
                        }
                    }
                }
            }
            distance++;
        }
        return -1;
    }

    private boolean isPrime(int n) {
        if (n <= 1) return false;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
}
```

### Python
```python
from collections import deque

def shortest_prime_path(grid, x1, y1, x2, y2):
    m, n = len(grid), len(grid[0])
    visited = [[False] * n for _ in range(m)]
    queue = deque([(x1, y1)])
    visited[x1][y1] = True
    distance = 0
    while queue:
        size = len(queue)
        for _ in range(size):
            x, y = queue.popleft()
            if (x, y) == (x2, y2): return distance
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and is_prime(grid[nx][ny]):
                    queue.append((nx, ny))
                    visited[nx][ny] = True
        distance += 1
    return -1

def is_prime(n):
    if n <= 1: return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0: return False
    return True
```

### C++
```cpp
#include <queue>
#include <vector>

class ShortestPrimePath {
public:
    int shortestPrimePath(int** grid, int x1, int y1, int x2, int y2) {
        int m = *grid[0]->size();
        int n = *grid->size();
        vector<vector<bool>> visited(m, vector<bool>(n));
        queue<pair<int, int>> queue;
        queue.push({x1, y1});
        visited[x1][y1] = true;
        int distance = 0;
        while (!queue.empty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                pair<int, int> cell = queue.front(); queue.pop();
                if (cell.first == x2 && cell.second == y2) return distance;
                for (int dx : {-1, 0, 1}) {
                    for (int dy : {-1, 0, 1}) {
                        int nx = cell.first + dx;
                        int ny = cell.second + dy;
                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && isPrime(grid[nx][ny])) {
                            queue.push({nx, ny});
                            visited[nx][ny] = true;
                        }
                    }
                }
            }
            distance++;
        }
        return -1;
    }

private:
    bool isPrime(int n) {
        if (n <= 1) return false;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
};
```

### JavaScript
```javascript
class ShortestPrimePath {
  shortestPrimePath(grid, x1, y1, x2, y2) {
    const m = grid.length;
    const n = grid[0].length;
    const visited = new Array(m).fill().map(() => new Array(n).fill(false));
    const queue = [[x1, y1]];
    visited[x1][y1] = true;
    let distance = 0;
    while (queue.length) {
      const size = queue.length;
      for (let i = 0; i < size; i++) {
        const [x, y] = queue.shift();
        if (x === x2 && y === y2) return distance;
        for (const dx of [-1, 0, 1]) {
          for (const dy of [-1, 0, 1]) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && isPrime(grid[nx][ny])) {
              queue.push([nx, ny]);
              visited[nx][ny] = true;
            }
          }
        }
      }
      distance++;
    }
    return -1;
  }

  isPrime(n) {
    if (n <= 1) return false;
    for (let i = 2; i * i <= n; i++) {
      if (n % i === 0) return false;
    }
    return true;
  }
}
```