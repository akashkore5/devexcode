---
id: "710356"
title: "Chinese Postman"
slug: "chinese-postman"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "Data Structures"]
---

**Chinese Postman**
=====================

### Summary
The Chinese Postman problem is a classic graph traversal problem that involves finding the shortest possible route to visit all edges in an undirected graph exactly once. The key concept involved is graph theory and more specifically, traversing graphs using algorithms.

### Detailed Explanation
To solve this problem, we can use a variation of the depth-first search (DFS) algorithm. Our goal is to find the minimum cost tour that visits every edge in the graph exactly once. We can achieve this by assigning a weight to each edge based on its length and then finding the minimum weighted Hamiltonian path.

Here's a step-by-step breakdown of the solution:

1.  Initialize a graph data structure, which could be an adjacency list or matrix.
2.  Assign a weight to each edge in the graph, representing its length.
3.  Perform DFS traversal on the graph, starting from any arbitrary node.
4.  While traversing, keep track of the nodes visited and the edges crossed.
5.  Once all nodes are visited, backtrack to find the minimum weighted Hamiltonian path.

The time complexity for this algorithm is O(E + V), where E is the number of edges and V is the number of vertices in the graph. The space complexity is O(V) because we need to store the visited nodes and edges during the traversal.

### Optimized Solutions
Here are optimized solutions in various programming languages:

#### Java
```java
import java.util.*;

class ChinesePostman {
    public static int minCostTour(int[][] graph, int n) {
        // Initialize a boolean array to keep track of visited nodes
        boolean[] visited = new boolean[n];
        
        // Perform DFS traversal and find the minimum weighted Hamiltonian path
        return dfs(graph, 0, visited);
    }
    
    public static int dfs(int[][] graph, int node, boolean[] visited) {
        if (node == -1) {
            // Backtrack to find the minimum weighted Hamiltonian path
            int minCost = Integer.MAX_VALUE;
            for (int i = 0; i < graph.length; i++) {
                if (!visited[i]) {
                    int cost = dfs(graph, i, visited);
                    if (cost < minCost) {
                        minCost = cost;
                    }
                }
            }
            return minCost;
        } else {
            // Mark the current node as visited
            visited[node] = true;
            
            // Initialize the minimum cost for this path
            int minCost = 0;
            
            // Traverse all adjacent nodes and find the minimum weighted Hamiltonian path
            for (int i = 0; i < graph.length; i++) {
                if (!visited[i]) {
                    int weight = graph[node][i];
                    int cost = dfs(graph, i, visited) + weight;
                    if (cost < minCost) {
                        minCost = cost;
                    }
                }
            }
            
            // Backtrack to find the minimum weighted Hamiltonian path
            return minCost;
        }
    }
}
```

#### Python
```python
class ChinesePostman:
    def min_cost_tour(self, graph):
        # Initialize a boolean array to keep track of visited nodes
        visited = [False] * len(graph)
        
        # Perform DFS traversal and find the minimum weighted Hamiltonian path
        return self.dfs(graph, 0, visited)
    
    def dfs(self, graph, node, visited):
        if node == -1:
            # Backtrack to find the minimum weighted Hamiltonian path
            min_cost = float('inf')
            for i in range(len(graph)):
                if not visited[i]:
                    cost = self.dfs(graph, i, visited)
                    if cost < min_cost:
                        min_cost = cost
            return min_cost
        else:
            # Mark the current node as visited
            visited[node] = True
            
            # Initialize the minimum cost for this path
            min_cost = 0
            
            # Traverse all adjacent nodes and find the minimum weighted Hamiltonian path
            for i in range(len(graph)):
                if not visited[i]:
                    weight = graph[node][i]
                    cost = self.dfs(graph, i, visited) + weight
                    if cost < min_cost:
                        min_cost = cost
            
            # Backtrack to find the minimum weighted Hamiltonian path
            return min_cost
```

#### C++
```cpp
class ChinesePostman {
public:
    int minCostTour(vector<vector<int>>& graph, int n) {
        // Initialize a boolean array to keep track of visited nodes
        bool* visited = new bool[n];
        
        // Perform DFS traversal and find the minimum weighted Hamiltonian path
        return dfs(graph, 0, visited);
    }
    
    int dfs(vector<vector<int>>& graph, int node, bool* visited) {
        if (node == -1) {
            // Backtrack to find the minimum weighted Hamiltonian path
            int minCost = INT_MAX;
            for (int i = 0; i < graph.size(); i++) {
                if (!visited[i]) {
                    int cost = dfs(graph, i, visited);
                    if (cost < minCost) {
                        minCost = cost;
                    }
                }
            }
            return minCost;
        } else {
            // Mark the current node as visited
            visited[node] = true;
            
            // Initialize the minimum cost for this path
            int minCost = 0;
            
            // Traverse all adjacent nodes and find the minimum weighted Hamiltonian path
            for (int i = 0; i < graph.size(); i++) {
                if (!visited[i]) {
                    int weight = graph[node][i];
                    int cost = dfs(graph, i, visited) + weight;
                    if (cost < minCost) {
                        minCost = cost;
                    }
                }
            }
            
            // Backtrack to find the minimum weighted Hamiltonian path
            return minCost;
        }
    }
};
```

#### JavaScript
```javascript
class ChinesePostman {
  minCostTour(graph) {
    // Initialize a boolean array to keep track of visited nodes
    let visited = new Array(graph.length).fill(false);
    
    // Perform DFS traversal and find the minimum weighted Hamiltonian path
    return this.dfs(graph, 0, visited);
  }
  
  dfs(graph, node, visited) {
    if (node === -1) {
      // Backtrack to find the minimum weighted Hamiltonian path
      let minCost = Infinity;
      for (let i = 0; i < graph.length; i++) {
        if (!visited[i]) {
          let cost = this.dfs(graph, i, visited);
          if (cost < minCost) {
            minCost = cost;
          }
        }
      }
      return minCost;
    } else {
      // Mark the current node as visited
      visited[node] = true;
      
      // Initialize the minimum cost for this path
      let minCost = 0;
      
      // Traverse all adjacent nodes and find the minimum weighted Hamiltonian path
      for (let i = 0; i < graph.length; i++) {
        if (!visited[i]) {
          let weight = graph[node][i];
          let cost = this.dfs(graph, i, visited) + weight;
          if (cost < minCost) {
            minCost = cost;
          }
        }
      }
      
      // Backtrack to find the minimum weighted Hamiltonian path
      return minCost;
    }
  }
}
```

These solutions demonstrate how to use DFS traversal and backtracking to find the minimum weighted Hamiltonian path in a graph, which is the essence of the Chinese Postman problem.