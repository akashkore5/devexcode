---
id: "710142"
title: "Minimum time to fulfil all orders"
slug: "minimum-time-to-fulfil-all-orders"
difficulty: "Hard"
companyTags: []
tags: ["Binary Search", "Algorithms"]
---

# Minimum time to fulfil all orders
## Slug: minimum-time-to-fulfil-all-orders
## Difficulty: Hard
## Topic Tags: Binary Search, Algorithms
## Company Tags: None

### Summary
Given a list of tasks with their corresponding deadlines and a single machine with an available capacity, the problem is to find the minimum time required to complete all tasks. The tasks are represented as intervals on a timeline, and the goal is to schedule them in a way that minimizes the total time taken.

### Detailed Explanation

The given task intervals can be thought of as a set of events that need to be scheduled. We can use binary search to find the minimum time required to complete all tasks. The idea is to start with a guess for the minimum time and then adjust it based on whether we can schedule all tasks within that time or not.

Here's a step-by-step breakdown of the solution:

1. Initialize a variable `low` as 0, which represents the earliest possible deadline.
2. Initialize a variable `high` as the maximum deadline, which represents the latest possible deadline.
3. Perform binary search to find the minimum time required to complete all tasks.
   * Calculate the mid-time by averaging `low` and `high`.
   * Check if it's possible to schedule all tasks within the given time frame (i.e., if the sum of task durations is less than or equal to the mid-time).
     - If yes, update `high` as the mid-time.
     - If no, update `low` as the mid-time.
4. Repeat step 3 until `high` and `low` converge.

The time complexity of this algorithm is O(log N), where N is the number of tasks. The space complexity is O(1).

### Optimized Solutions

#### Java
```java
public int minTime(int[][] orders) {
    Arrays.sort(orders, (a, b) -> a[0] - b[0]);
    
    int low = 0;
    int high = orders[orders.length - 1][1];
    
    while (low < high) {
        int mid = (low + high) / 2;
        
        boolean canSchedule = true;
        int currentTime = 0;
        for (int[] order : orders) {
            if (order[0] > mid) break;
            if (currentTime >= order[1]) continue;
            currentTime += order[0];
        }
        
        if (!canSchedule) high = mid;
        else low = mid + 1;
    }
    
    return low;
}
```

#### Python
```python
def min_time(orders):
    orders.sort(key=lambda x: x[0])
    
    low, high = 0, orders[-1][1]
    
    while low < high:
        mid = (low + high) // 2
        
        can_schedule = True
        current_time = 0
        for order in orders:
            if order[0] > mid: break
            if current_time >= order[1]: continue
            current_time += order[0]
        
        if not can_schedule: high = mid
        else: low = mid + 1
    
    return low
```

#### C++
```cpp
int minTime(int orders[][2], int n) {
    sort(orders, orders+n, [](const auto& a, const auto& b){return a[0] < b[0];});
    
    int low = 0, high = orders[n-1][1];
    
    while (low < high) {
        int mid = (low + high) / 2;
        
        bool canSchedule = true;
        int currentTime = 0;
        for (int i = 0; i < n; i++) {
            if (orders[i][0] > mid) break;
            if (currentTime >= orders[i][1]) continue;
            currentTime += orders[i][0];
        }
        
        if (!canSchedule) high = mid;
        else low = mid + 1;
    }
    
    return low;
}
```

#### JavaScript
```javascript
function minTime(orders) {
    orders.sort((a, b) => a[0] - b[0]);
    
    let low = 0, high = orders[orders.length - 1][1];
    
    while (low < high) {
        let mid = Math.floor((low + high) / 2);
        
        let canSchedule = true;
        let currentTime = 0;
        for (let i = 0; i < orders.length; i++) {
            if (orders[i][0] > mid) break;
            if (currentTime >= orders[i][1]) continue;
            currentTime += orders[i][0];
        }
        
        if (!canSchedule) high = mid;
        else low = mid + 1;
    }
    
    return low;
}
```