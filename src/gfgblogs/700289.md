---
id: "700289"
title: "Linked List to Binary Tree"
slug: "make-binary-tree"
difficulty: "Medium"
companyTags: ["Amazon"]
tags: ["Tree", "Data Structures", "Linked List", "Queue"]
---

# Linked List to Binary Tree
## Slug: make-binary-tree
## Difficulty: Medium
## Id: 700289
## Topic Tags: Tree, Data Structures, Linked List, Queue
## Company Tags: Amazon

### Summary
Given a singly linked list and its length, construct the corresponding binary tree. The linked list nodes contain integer values representing the node values in the binary tree. This problem involves converting a linear data structure (linked list) to a non-linear data structure (binary tree).

### Detailed Explanation
To convert the linked list into a binary tree, we can use a level-order traversal approach, where we visit each node in the order of its level and construct the corresponding nodes in the binary tree. We start by creating the root node with the middle value from the linked list.

Step-by-step breakdown:

1. Initialize an empty queue to store nodes for the binary tree.
2. Calculate the length of the linked list and find the middle element (if the length is odd, this will be the root node).
3. Create a new node in the binary tree with the value from the middle element and enqueue it.
4. Dequeue the first node from the queue and create its left child by taking the value from the next node in the linked list. If there are no more nodes in the linked list, set the left child to null. Enqueue this new left child.
5. Repeat steps 3-4 for the right child of the current node.
6. Continue these steps until all nodes have been visited and the binary tree is constructed.

Time complexity: O(n), where n is the length of the linked list, since we visit each node once.

Space complexity: O(n), as in the worst case, the queue can store up to n nodes.

### Optimized Solutions

#### Java
```java
public class LinkedListToBinaryTree {
    public static Node binaryTreeFromLinkedList(Node head) {
        if (head == null) return null;

        Queue<Node> queue = new LinkedList<>();
        int length = 0;
        Node current = head;
        while (current != null) {
            length++;
            current = current.next;
        }

        current = head;
        for (int i = 0; i < length / 2; i++) {
            Node leftChild = new Node(current.val);
            queue.add(leftChild);
            if (current.next != null) {
                leftChild.next = new Node(current.next.val);
                queue.add(leftChild.next);
            }
            current = current.next;
        }

        return head;
    }
}
```

#### Python
```python
class LinkedListToBinaryTree:
    def binary_tree_from_linked_list(self, head):
        if not head: return None

        queue = []
        length = 0
        current = head
        while current:
            length += 1
            current = current.next

        current = head
        for _ in range(length // 2):
            left_child = Node(current.val)
            queue.append(left_child)
            if current.next:
                left_child.next = Node(current.next.val)
                queue.append(left_child.next)
            current = current.next

        return head
```

#### C++
```cpp
class LinkedListToBinaryTree {
public:
    Node* binaryTreeFromLinkedList(Node* head) {
        if (!head) return nullptr;

        queue<Node*> queue;
        int length = 0;
        Node* current = head;
        while (current) {
            length++;
            current = current->next;
        }

        current = head;
        for (int i = 0; i < length / 2; i++) {
            Node* leftChild = new Node(current->val);
            queue.push(leftChild);
            if (current->next) {
                leftChild->next = new Node(current->next->val);
                queue.push(leftChild->next);
            }
            current = current->next;
        }

        return head;
    }
};
```

#### JavaScript
```javascript
class LinkedListToBinaryTree {
  binaryTreeFromLinkedList(head) {
    if (!head) return null;

    let queue = [];
    let length = 0;
    let current = head;
    while (current) {
      length++;
      current = current.next;
    }

    current = head;
    for (let i = 0; i < Math.floor(length / 2); i++) {
      const leftChild = new Node(current.val);
      queue.push(leftChild);
      if (current.next) {
        leftChild.next = new Node(current.next.val);
        queue.push(leftChild.next);
      }
      current = current.next;
    }

    return head;
  }
}
```

Note: The `Node` class is assumed to have a `val` property for storing the node value and a `next` property for pointing to the next node in the linked list or binary tree.