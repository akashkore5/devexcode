---
id: "712222"
title: "Ugly Number II"
slug: "ugly-number-ii"
difficulty: "Medium"
companyTags: []
tags: []
---

**Ugly Number II**
================

### Summary
An ugly number is a positive integer whose decimal representation contains only digits that are 1, 2, 3, 4, or 5. Write a function to find the nth ugly number.

### Detailed Explanation
To solve this problem, we can use a dynamic programming approach. We start by defining an array `ugly` of size `n`, where `ugly[i]` represents the `i-th` ugly number. 

We initialize `ugly[0] = 1`, since the first ugly number is 1.

Then, for each `i > 0`, we calculate `ugly[i]` as the smallest multiple of 2, 3, or 5 that is greater than `ugly[i-1]`. This is because an ugly number can only be a multiple of 2, 3, or 5 if it's not already been accounted for.

Here's a step-by-step breakdown:

1. Initialize `ugly[0] = 1`.
2. For each `i > 0`:
   - Calculate the smallest multiple of 2 that is greater than `ugly[i-1]`. Let this be `multiple_2`.
   - Calculate the smallest multiple of 3 that is greater than `ugly[i-1]`. Let this be `multiple_3`.
   - Calculate the smallest multiple of 5 that is greater than `ugly[i-1]`. Let this be `multiple_5`.
   - Set `ugly[i]` to the minimum of `multiple_2`, `multiple_3`, and `multiple_5`.

This approach ensures that we generate all ugly numbers up to the `n-th` one.

Time complexity: O(n)
Space complexity: O(1)

### Optimized Solutions

#### Java
```java
public int nthUglyNumber(int n) {
    int[] ugly = new int[n];
    ugly[0] = 1;
    for (int i = 1; i < n; i++) {
        int multiple_2 = 2 * ugly[i-1], multiple_3 = 3 * ugly[i-1], multiple_5 = 5 * ugly[i-1];
        ugly[i] = Math.min(Math.min(multiple_2, multiple_3), multiple_5);
    }
    return ugly[n-1];
}
```

#### Python
```python
def nthUglyNumber(n):
    ugly = [1]
    for i in range(1, n):
        multiple_2, multiple_3, multiple_5 = 2*ugly[i-1], 3*ugly[i-1], 5*ugly[i-1]
        ugly.append(min(multiple_2, multiple_3, multiple_5))
    return ugly[-1]
```

#### C++
```cpp
int nthUglyNumber(int n) {
    int ugly[n];
    ugly[0] = 1;
    for (int i = 1; i < n; i++) {
        int multiple_2 = 2 * ugly[i-1], multiple_3 = 3 * ugly[i-1], multiple_5 = 5 * ugly[i-1];
        ugly[i] = min(multiple_2, min(multiple_3, multiple_5));
    }
    return ugly[n-1];
}
```

#### JavaScript
```javascript
function nthUglyNumber(n) {
    let ugly = [1];
    for (let i = 1; i < n; i++) {
        const multiple_2 = 2 * ugly[i-1], multiple_3 = 3 * ugly[i-1], multiple_5 = 5 * ugly[i-1];
        ugly.push(Math.min(Math.min(multiple_2, multiple_3), multiple_5));
    }
    return ugly[n-1];
}
```

Note: The above solutions are not optimized for large values of `n`, as they have a time complexity of O(n). A more efficient solution would be to use a priority queue or a heap to keep track of the next available ugly number.