---
id: "710047"
title: "Minimum swap required to convert binary tree to binary search tree"
slug: "minimum-swap-required-to-convert-binary-tree-to-binary-search-tree"
difficulty: "Hard"
companyTags: []
tags: []
---

**Minimum Swap Required to Convert Binary Tree to Binary Search Tree**
===========================================================

### Summary
Given a binary tree, find the minimum number of swaps needed to convert it into a binary search tree (BST). This problem involves manipulating a binary tree to satisfy the properties of a BST.

## Detailed Explanation
In this problem, we are given a binary tree and asked to minimize the number of swaps required to make it a binary search tree. A binary search tree is a tree in which each node has at most two children (i.e., left child and right child) and for each node, all elements in its left subtree must be less than the element in that node, and all elements in its right subtree must be greater than the element in that node.

To solve this problem, we can use a top-down approach. First, we find the root of the binary tree and then recursively find the roots of the left and right subtrees. Once we have the roots of the left and right subtrees, we check if they are in the correct order for a BST (i.e., the root of the left subtree is less than the root of the right subtree). If they are not in the correct order, we need to swap them.

Here's a step-by-step breakdown of the solution:

1. Find the root of the binary tree.
2. Recursively find the roots of the left and right subtrees.
3. Check if the roots of the left and right subtrees are in the correct order for a BST (i.e., the root of the left subtree is less than the root of the right subtree).
4. If they are not in the correct order, swap them.
5. Recursively apply steps 2-4 to the left and right subtrees until we have processed all nodes in the binary tree.

Time complexity: O(n), where n is the number of nodes in the binary tree.
Space complexity: O(h), where h is the height of the binary tree, as we need to store the roots of the left and right subtrees in our recursive calls.

### Optimized Solutions

#### Java
```java
class Node {
    int val;
    Node left, right;

    public Node(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

public class Main {
    static int minSwaps(Node root) {
        if (root == null) return 0;

        int swaps = 0;
        process(root, null, null, &swaps);

        return swaps;
    }

    static void process(Node node, Node leftRoot, Node rightRoot, int* swaps) {
        if (node == null) return;

        process(node.right, node, null, swaps);
        process(node.left, leftRoot, node, swaps);

        if (leftRoot != null && rightRoot != null &&
            leftRoot.val > rightRoot.val) {
            *swaps += 2;
            Node temp = leftRoot.right;
            leftRoot.right = rightRoot;
            rightRoot.left = temp;
        }
    }

    public static void main(String[] args) {
        // Example usage
        Node root = new Node(4);
        root.left = new Node(2);
        root.right = new Node(5);
        root.left.left = new Node(1);
        root.left.right = new Node(3);

        int swaps = minSwaps(root);
        System.out.println("Minimum swaps required: " + swaps);
    }
}
```

#### Python
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def min_swaps(root):
    if root is None:
        return 0

    swaps = 0
    process(root, None, None, [swaps])

    return swaps[0]

def process(node, left_root, right_root, swaps):
    if node is None:
        return

    process(node.right, node, None, swaps)
    process(node.left, left_root, node, swaps)

    if left_root and right_root and left_root.val > right_root.val:
        swaps[0] += 2
        temp = left_root.right
        left_root.right = right_root
        right_root.left = temp

# Example usage
root = Node(4)
root.left = Node(2)
root.right = Node(5)
root.left.left = Node(1)
root.left.right = Node(3)

swaps = min_swaps(root)
print("Minimum swaps required:", swaps)
```

#### C++
```cpp
class Node {
public:
    int val;
    Node* left, *right;

    Node(int val) : val(val), left(nullptr), right(nullptr) {}
};

int minSwaps(Node* root) {
    if (root == nullptr) return 0;

    int swaps = 0;
    process(root, nullptr, nullptr, &swaps);

    return swaps;
}

void process(Node* node, Node* leftRoot, Node* rightRoot, int* swaps) {
    if (node == nullptr) return;

    process(node->right, node, nullptr, swaps);
    process(node->left, leftRoot, node, swaps);

    if (leftRoot != nullptr && rightRoot != nullptr &&
        leftRoot->val > rightRoot->val) {
        *swaps += 2;
        Node* temp = leftRoot->right;
        leftRoot->right = rightRoot;
        rightRoot->left = temp;
    }
}

int main() {
    // Example usage
    Node* root = new Node(4);
    root->left = new Node(2);
    root->right = new Node(5);
    root->left->left = new Node(1);
    root->left->right = new Node(3);

    int swaps = minSwaps(root);
    std::cout << "Minimum swaps required: " << swaps << std::endl;
    return 0;
}
```

#### JavaScript
```javascript
class Node {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function minSwaps(root) {
    if (root === null) return 0;

    let swaps = 0;
    process(root, null, null, swaps);

    return swaps;
}

function process(node, leftRoot, rightRoot, swaps) {
    if (node === null) return;

    process(node.right, node, null, swaps);
    process(node.left, leftRoot, node, swaps);

    if (leftRoot !== null && rightRoot !== null &&
        leftRoot.val > rightRoot.val) {
        swaps += 2;
        let temp = leftRoot.right;
        leftRoot.right = rightRoot;
        rightRoot.left = temp;
    }
}

// Example usage
let root = new Node(4);
root.left = new Node(2);
root.right = new Node(5);
root.left.left = new Node(1);
root.left.right = new Node(3);

let swaps = minSwaps(root);
console.log("Minimum swaps required:", swaps);
```

Note: The above code assumes that the binary tree is a full binary tree (i.e., every node has either 0 or 2 children). If the tree is not full, you may need to modify the code accordingly.