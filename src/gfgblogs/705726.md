---
id: "705726"
title: "Techfest and the Queue"
slug: "techfest-and-the-queue1044"
difficulty: "Medium"
companyTags: []
tags: ["Prime Number", "sieve"]
---

**Techfest and the Queue**
=====================

**Slug:** techfest-and-the-queue1044
**Difficulty:** Medium
**Id:** 705726
**Topic Tags:** Prime Number, sieve
**Company Tags:** None

## Summary
The Techfest problem "Techfest and the Queue" requires you to solve a problem related to prime numbers and queues. You are given an integer n, representing the number of people at Techfest, and your task is to determine the smallest prime number that can be used as a ticket number for all attendees. The key concepts involved in this problem include prime numbers and the Sieve of Eratosthenes algorithm.

## Detailed Explanation
The problem can be solved by using the Sieve of Eratosthenes algorithm, which is an efficient way to generate all primes up to a given limit. Here's a step-by-step breakdown of the solution:

1. Initialize a boolean array `prime` of size `n+1`, where `prime[i]` represents whether `i` is a prime number or not.
2. Set all elements in the `prime` array to true, assuming all numbers are prime initially.
3. Iterate from 2 to sqrt(n), and for each number `p` in this range:
    - If `prime[p]` is true, mark as composite (`false`) all the multiples of `p`. This is because if a number is not divisible by any previously found primes, it must be prime.
4. After the loop, iterate through the `prime` array and find the first index where `prime[i]` is still true. This will be the smallest prime number greater than or equal to n.

Time complexity: O(n log log n) due to the Sieve of Eratosthenes algorithm
Space complexity: O(n)

## Optimized Solutions

### Java
```java
public class Main {
    public static void main(String[] args) {
        int n = 10; // Replace with your input value
        boolean[] prime = new boolean[n + 1];
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (prime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    prime[j] = false;
                }
            }
        }
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                System.out.println("The smallest prime number is " + i);
                return;
            }
        }
    }
}
```

### Python
```python
def solve(n):
    prime = [True] * (n + 1)
    for p in range(2, int(n ** 0.5) + 1):
        if prime[p]:
            for i in range(p * p, n + 1, p):
                prime[i] = False
    for p in range(2, n + 1):
        if prime[p]:
            return p

n = 10  # Replace with your input value
print("The smallest prime number is", solve(n))
```

### C++
```cpp
#include <iostream>
#include <cmath>

bool isPrime(int n) {
    if (n <= 1)
        return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0)
            return false;
    }
    return true;
}

int main() {
    int n = 10; // Replace with your input value
    for (int i = 2; i <= n; i++) {
        if (isPrime(i)) {
            std::cout << "The smallest prime number is " << i << std::endl;
            return 0;
        }
    }
}
```

### JavaScript
```javascript
function solve(n) {
    const prime = new Array(n + 1).fill(true);
    for (let p = 2; p * p <= n; p++) {
        if (prime[p]) {
            for (let i = p * p; i <= n; i += p) {
                prime[i] = false;
            }
        }
    }
    for (let p = 2; p <= n; p++) {
        if (prime[p]) {
            return p;
        }
    }
}

const n = 10; // Replace with your input value
console.log(`The smallest prime number is ${solve(n)}`);
```

Note: These optimized solutions use different approaches to solve the problem, and the choice of language may affect performance.