---
id: "713977"
title: "Best Node"
slug: "best-node--170647"
difficulty: "Medium"
companyTags: []
tags: ["Tree", "DFS"]
---

**Best Node**
==================

### Summary
Given a tree, find the node with the maximum value. A tree is defined as an unweighted and undirected graph where each node has at most one parent except for the root node, which has no parent. The problem requires us to traverse the tree in a way that helps us identify the node with the maximum value.

### Detailed Explanation
To solve this problem, we can use Depth-First Search (DFS) as our traversal algorithm. DFS is well-suited for this problem because it allows us to explore the tree depth-first and keep track of the maximum value seen so far.

Here's a step-by-step breakdown of the solution:

1. Start at the root node.
2. Initialize a variable `max_value` to store the maximum value seen so far.
3. Traverse the tree using DFS, visiting each node in order.
4. At each node, compare its value with `max_value`. If the current node's value is greater than `max_value`, update `max_value`.
5. Continue traversing the tree until all nodes have been visited.
6. Return the node with the maximum value.

Here's an ASCII art diagram of a sample tree:
```
      1
     / \
    2   3
   / \   \
  4   5   6
```

In this example, the root node is `1`, and we want to find the node with the maximum value. The DFS traversal would visit nodes in the order: `1`, `2`, `4`, `5`, `3`, `6`. At each node, we compare its value with the current maximum value and update it if necessary.

Time complexity analysis:

* We visit each node once, so the time complexity is O(n), where n is the number of nodes in the tree.
* The space complexity is O(h), where h is the height of the tree. This is because we need to store the recursive call stack during DFS traversal.

### Optimized Solutions

#### Java
```java
class Node {
    int value;
    List<Node> children;

    public Node(int value) {
        this.value = value;
        this.children = new ArrayList<>();
    }
}

public class BestNode {
    public static Node bestNode(Node root) {
        Node maxNode = null;
        int maxValue = Integer.MIN_VALUE;

        traverse(root, maxValue, maxNode);

        return maxNode;
    }

    private static void traverse(Node node, int maxValue, Node maxNode) {
        if (node.value > maxValue) {
            maxValue = node.value;
            maxNode = node;
        }

        for (Node child : node.children) {
            traverse(child, maxValue, maxNode);
        }
    }
}
```

#### Python
```python
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []

def best_node(root):
    max_node = None
    max_value = float('-inf')

    def traverse(node, max_value, max_node):
        nonlocal max_node, max_value

        if node.value > max_value:
            max_value = node.value
            max_node = node

        for child in node.children:
            traverse(child, max_value, max_node)

    traverse(root, max_value, max_node)

    return max_node
```

#### C++
```cpp
class Node {
public:
    int value;
    vector<Node*> children;

    Node(int value) : value(value), children() {}

};

Node* bestNode(Node* root) {
    Node* maxNode = nullptr;
    int maxValue = INT_MIN;

    traverse(root, maxValue, maxNode);

    return maxNode;
}

void traverse(Node* node, int& maxValue, Node*& maxNode) {
    if (node->value > maxValue) {
        maxValue = node->value;
        maxNode = node;
    }

    for (auto child : node->children) {
        traverse(child, maxValue, maxNode);
    }
}
```

#### JavaScript
```javascript
class Node {
  constructor(value) {
    this.value = value;
    this.children = [];
  }
}

function bestNode(root) {
  let maxNode = null;
  let maxValue = -Infinity;

  function traverse(node, maxValue, maxNode) {
    if (node.value > maxValue) {
      maxValue = node.value;
      maxNode = node;
    }

    for (const child of node.children) {
      traverse(child, maxValue, maxNode);
    }
  }

  traverse(root, maxValue, maxNode);

  return maxNode;
}
```

Note that the optimized solutions provided are in the form of a recursive function that traverses the tree using DFS. The base case is when the current node has no children, at which point we can compare its value with the maximum value seen so far and update it if necessary.