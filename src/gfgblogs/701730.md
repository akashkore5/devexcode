---
id: "701730"
title: "Union of Arrays with Duplicates"
slug: "union-of-two-arrays3538"
difficulty: "Easy"
companyTags: ["Zoho", "Rockstand"]
tags: ["Hash", "Data Structures", "Algorithms", "Arrays"]
---

**Union of Arrays with Duplicates**
==================================================================

**Slug:** union-of-two-arrays3538
**Difficulty:** Easy
**Id:** 701730
**Topic Tags:** Hash, Data Structures, Algorithms, Arrays
**Company Tags:** Zoho, Rockstand

## Summary
The problem is about finding the union of two arrays with duplicates. The goal is to combine both arrays and remove any duplicate elements. This problem involves basic array manipulation and hash table concepts.

## Detailed Explanation
To solve this problem, we can use a simple approach by iterating through both arrays and adding unique elements from each array into a new set (or array). We can use a hash table (like HashMap in Java or dictionary in Python) to keep track of the unique elements.

Here's the step-by-step breakdown:

1. Create an empty hash table (HashMap or dictionary).
2. Iterate through the first array and add each element to the hash table if it doesn't already exist.
3. Repeat step 2 for the second array.
4. Return the keys of the hash table as the union of both arrays.

Here's a diagram illustrating this process:
```
Array 1: [a, b, c]
Array 2: [c, d, e]

Union:
Hash Table (keys): [a, b, c, d, e]
```

The time complexity for this solution is O(n), where n is the total number of elements in both arrays. The space complexity is also O(n) because we're storing all unique elements in the hash table.

## Optimized Solutions
### Java
```java
import java.util.HashMap;
import java.util.Map;

public class UnionOfArrays {
    public static int[] union(int[] arr1, int[] arr2) {
        Map<Integer, Boolean> map = new HashMap<>();
        for (int i : arr1) {
            map.put(i, true);
        }
        for (int j : arr2) {
            if (!map.containsKey(j)) {
                map.put(j, true);
            }
        }
        int[] result = new int[map.size()];
        int i = 0;
        for (Map.Entry<Integer, Boolean> entry : map.entrySet()) {
            result[i] = entry.getKey();
            i++;
        }
        return result;
    }
}
```

### Python
```python
def union(arr1, arr2):
    seen = set()
    for num in arr1:
        seen.add(num)
    for num in arr2:
        if num not in seen:
            seen.add(num)
    return list(seen)

```

### C++
```cpp
#include <iostream>
#include <map>
#include <set>
using namespace std;

vector<int> unionArrays(vector<int>& arr1, vector<int>& arr2) {
    set<int> seen;
    for (int i : arr1) {
        seen.insert(i);
    }
    for (int j : arr2) {
        if (!seen.count(j)) {
            seen.insert(j);
        }
    }
    return vector<int>(seen.begin(), seen.end());
}

```

### JavaScript
```javascript
function union(arr1, arr2) {
    let set = new Set();
    for (let num of arr1) {
        set.add(num);
    }
    for (let num of arr2) {
        if (!set.has(num)) {
            set.add(num);
        }
    }
    return Array.from(set.values());
}
```

These solutions all have the same time and space complexity as the original solution: O(n) and O(n), respectively.