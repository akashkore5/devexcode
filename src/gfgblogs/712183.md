---
id: "712183"
title: "Geek's Training"
slug: "geeks-training"
difficulty: "Medium"
companyTags: []
tags: ["Dynamic Programming", "Arrays"]
---

Here is the blog post for the "Geek's Training" problem:

**Geek's Training**
**Slug:** geeks-training
**Difficulty:** Medium
**Id:** 712183
**Topic Tags:** Dynamic Programming, Arrays
**Company Tags:** None

## Summary
The Geek's Training problem involves training a group of geeks for a series of tasks. Each task has a specific difficulty level and requires a certain number of hours to train. The goal is to determine the maximum number of tasks that can be completed within a given time frame, subject to the constraint that each task must be trained for its required number of hours.

## Detailed Explanation
To solve this problem, we will use dynamic programming to keep track of the maximum number of tasks that can be completed at each hour. We start by initializing an array `dp` of size `n`, where `n` is the total number of hours available for training. Each element `dp[i]` represents the maximum number of tasks that can be completed within the first `i` hours.

We then iterate over each task, starting from the easiest one. For each task, we calculate the number of hours required to complete it (`hours`) and the difficulty level (`difficulty`). We update our dynamic programming array as follows:
```markdown
dp[i] = max(dp[i], dp[i-hours] + 1)
```
This means that if we can complete `i-hours` tasks within the first `i` hours, then we can add one more task of difficulty `difficulty` to our training schedule.

Finally, we return the maximum value in the dynamic programming array as the answer. This represents the maximum number of tasks that can be completed within the given time frame.

Time complexity: O(n), where n is the total number of hours available for training.
Space complexity: O(n), since we need to store the dynamic programming array of size `n`.

## Optimized Solutions

### Java
```java
public int maxTasks(int[] difficulties, int hours) {
    int n = difficulties.length;
    int[] dp = new int[hours + 1];
    for (int i = 0; i < n; i++) {
        int difficulty = difficulties[i];
        int hoursRequired = difficulty;
        for (int j = hoursRequired; j >= 1; j--) {
            dp[j] = Math.max(dp[j], dp[j - hoursRequired] + 1);
        }
    }
    return dp[hours];
}
```

### Python
```python
def max_tasks(difficulties, hours):
    n = len(difficulties)
    dp = [0] * (hours + 1)
    for i in range(n):
        difficulty = difficulties[i]
        hours_required = difficulty
        for j in range(hours_required, 0, -1):
            dp[j] = max(dp[j], dp[j - hours_required] + 1)
    return dp[hours]
```

### C++
```cpp
int maxTasks(int* difficulties, int n, int hours) {
    int* dp = new int[hours + 1];
    for (int i = 0; i < n; i++) {
        int difficulty = difficulties[i];
        int hoursRequired = difficulty;
        for (int j = hoursRequired; j >= 1; j--) {
            dp[j] = std::max(dp[j], dp[j - hoursRequired] + 1);
        }
    }
    delete[] dp;
    return dp[hours];
}
```

### JavaScript
```javascript
function maxTasks(difficulties, hours) {
    let n = difficulties.length;
    let dp = new Array(hours + 1).fill(0);
    for (let i = 0; i < n; i++) {
        let difficulty = difficulties[i];
        let hoursRequired = difficulty;
        for (let j = hoursRequired; j >= 1; j--) {
            dp[j] = Math.max(dp[j], dp[j - hoursRequired] + 1);
        }
    }
    return dp[hours];
}
```

Note that the code snippets provided are not exhaustive, but rather illustrate the general approach and key steps in solving the problem.