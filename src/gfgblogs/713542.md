---
id: "713542"
title: "Largest Sum Cycle"
slug: "largest-sum-cycle--170645"
difficulty: "Hard"
companyTags: ["JUSPAY"]
tags: ["Graph", "Backtracking", "Data Structures", "Algorithms"]
---

**Largest Sum Cycle**
=====================

## Summary
Given a directed graph with edges labeled by integers, find the largest sum cycle in the graph. A cycle is an edge sequence that starts and ends at the same vertex. The problem requires a backtracking approach to explore all possible cycles.

## Detailed Explanation
The main idea is to use a backtracking algorithm to generate all possible cycles in the graph and then calculate their sums. We'll keep track of the maximum sum found so far and update it when we find a cycle with a larger sum.

Here's a step-by-step breakdown:

1. Initialize variables:
	* `max_sum`: the maximum sum found so far (initialized to 0)
	* `cycle_sum`: the sum of the current cycle
2. Define a helper function `get_cycle_sum` that calculates the sum of a given cycle.
3. Use a backtracking algorithm to generate all possible cycles in the graph:
	* Start at each vertex and explore all its outgoing edges.
	* For each edge, recursively call the helper function to calculate the sum of the sub-cycle.
	* If the current cycle has a larger sum than `max_sum`, update `max_sum`.
4. Return `max_sum` as the largest sum cycle found.

Time complexity: O(V \* E), where V is the number of vertices and E is the number of edges, since we visit each edge once.
Space complexity: O(V), for storing the graph's adjacency list.

## Optimized Solutions

### Java
```
java
public class LargestSumCycle {
    public static int largestSumCycle(int[][] graph) {
        int max_sum = 0;
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph[i].length; j++) {
                if (graph[i][j] > 0) { // edge exists
                    int cycle_sum = get_cycle_sum(graph, i, j);
                    max_sum = Math.max(max_sum, cycle_sum);
                }
            }
        }
        return max_sum;
    }

    private static int get_cycle_sum(int[][] graph, int start, int end) {
        int sum = 0;
        while (start != end) {
            sum += graph[start][end];
            start = end;
            for (int i = 0; i < graph.length; i++) {
                if (graph[i][start] > 0 && i != start) {
                    start = i;
                    break;
                }
            }
        }
        return sum + graph[start][end];
    }
}
```

### Python
```
python
def largest_sum_cycle(graph):
    max_sum = 0
    for i in range(len(graph)):
        for j in range(len(graph[i])):
            if graph[i][j] > 0:  # edge exists
                cycle_sum = get_cycle_sum(graph, i, j)
                max_sum = max(max_sum, cycle_sum)
    return max_sum

def get_cycle_sum(graph, start, end):
    sum = 0
    while start != end:
        sum += graph[start][end]
        start = end
        for i in range(len(graph)):
            if graph[i][start] > 0 and i != start:
                start = i
                break
    return sum + graph[start][end]
```

### C++
```
cpp
#include <iostream>
using namespace std;

int largestSumCycle(int graph[][6], int V) {
    int max_sum = 0;
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            if (graph[i][j] > 0) { // edge exists
                int cycle_sum = get_cycle_sum(graph, i, j);
                max_sum = max(max_sum, cycle_sum);
            }
        }
    }
    return max_sum;
}

int get_cycle_sum(int graph[][6], int start, int end) {
    int sum = 0;
    while (start != end) {
        sum += graph[start][end];
        start = end;
        for (int i = 0; i < V; i++) {
            if (graph[i][start] > 0 && i != start) {
                start = i;
                break;
            }
        }
    }
    return sum + graph[start][end];
}
```

### JavaScript
```
javascript
function largestSumCycle(graph) {
    let max_sum = 0;
    for (let i = 0; i < graph.length; i++) {
        for (let j = 0; j < graph[i].length; j++) {
            if (graph[i][j] > 0) { // edge exists
                let cycle_sum = get_cycle_sum(graph, i, j);
                max_sum = Math.max(max_sum, cycle_sum);
            }
        }
    }
    return max_sum;
}

function get_cycle_sum(graph, start, end) {
    let sum = 0;
    while (start != end) {
        sum += graph[start][end];
        start = end;
        for (let i = 0; i < graph.length; i++) {
            if (graph[i][start] > 0 && i !== start) {
                start = i;
                break;
            }
        }
    }
    return sum + graph[start][end];
}
```

Note: The optimized solutions are based on the assumption that the input graph is represented as an adjacency matrix or list.