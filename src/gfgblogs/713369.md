---
id: "713369"
title: "Find the longest string"
slug: "find-the-longest-string--170645"
difficulty: "Medium"
companyTags: ["Flipkart"]
tags: ["Strings", "BFS", "Trie", "Data Structures", "Algorithms", "Advanced Data Structure"]
---

**Find the Longest String**
=====================

### Summary
Given a list of strings, find the longest string in the list. The problem requires us to write an efficient algorithm that can handle large inputs and scale well with increasing size.

### Detailed Explanation
To solve this problem, we can use a Trie data structure to efficiently store and search for the strings. Here's a step-by-step breakdown:

1. **Create a Trie**: Start by creating a Trie node with a boolean flag `isEndOfWord` set to false. Each node will have a character array of size 26 (for lowercase English alphabets) initialized with all characters as null.
2. **Insert Strings into Trie**: Iterate through the list of strings and insert each string into the Trie. For each string, start from the root node and recursively traverse down the Trie, creating new nodes if necessary. Set `isEndOfWord` to true for the last node in each string's traversal path.
3. **Find Longest String**: Once all strings are inserted, perform a depth-first search (DFS) or breadth-first search (BFS) on the Trie to find the longest string. Start from the root node and explore each node's children recursively until you reach a leaf node with `isEndOfWord` set to true.
4. **Return Longest String**: The leaf node with the longest path length will correspond to the longest string in the list.

Here's an ASCII art diagram illustrating the Trie construction:
```
       +---------------+
       |  Root Node   |
       +---------------+
              |
              |
              v
       +---------------+
       |  Node 'a'    |
       |  (isEndOfWord = false)|
       +---------------+
              |
              |
              v
       +---------------+
       |  Node 'b'    |
       |  (isEndOfWord = false)|
       +---------------+
              |
              |
              v
       +---------------+
       |  Node 'c'    |
       |  (isEndOfWord = true)|
       +---------------+
```
The time complexity of this algorithm is O(N \* M), where N is the number of strings and M is the maximum length of a string. The space complexity is O(N \* M) as well, since we're storing all strings in the Trie.

### Optimized Solutions

#### Java
```java
class TrieNode {
    boolean isEndOfWord;
    TrieNode[] children = new TrieNode[26];

    public TrieNode() {
        isEndOfWord = false;
        for (int i = 0; i < 26; i++) {
            children[i] = null;
        }
    }
}

class Solution {
    public String longestString(String[] strings) {
        TrieNode root = new TrieNode();
        int maxLength = 0;
        String longestString = "";

        for (String s : strings) {
            TrieNode current = root;
            for (char c : s.toCharArray()) {
                int index = c - 'a';
                if (current.children[index] == null) {
                    current.children[index] = new TrieNode();
                }
                current = current.children[index];
            }
            current.isEndOfWord = true;

            if (s.length() > maxLength) {
                maxLength = s.length();
                longestString = s;
            }
        }

        return longestString;
    }
}
```

#### Python
```python
class TrieNode:
    def __init__(self):
        self.is_end_of_word = False
        self.children = [None] * 26

class Solution:
    def longest_string(self, strings):
        root = TrieNode()
        max_length = 0
        longest_string = ""

        for s in strings:
            current = root
            for c in s:
                index = ord(c) - ord('a')
                if not current.children[index]:
                    current.children[index] = TrieNode()
                current = current.children[index]
            current.is_end_of_word = True

            if len(s) > max_length:
                max_length = len(s)
                longest_string = s

        return longest_string
```

#### C++
```cpp
class TrieNode {
public:
    bool isEndOfWord;
    TrieNode* children[26];

    TrieNode() {
        isEndOfWord = false;
        for (int i = 0; i < 26; i++) {
            children[i] = nullptr;
        }
    }
};

class Solution {
public:
    string longestString(vector<string>& strings) {
        TrieNode* root = new TrieNode();
        int maxLength = 0;
        string longestString = "";

        for (const auto& s : strings) {
            TrieNode* current = root;
            for (char c : s) {
                int index = c - 'a';
                if (!current->children[index]) {
                    current->children[index] = new TrieNode();
                }
                current = current->children[index];
            }
            current->isEndOfWord = true;

            if (s.length() > maxLength) {
                maxLength = s.length();
                longestString = s;
            }
        }

        delete root;
        return longestString;
    }
};
```

#### JavaScript
```javascript
class TrieNode {
  constructor() {
    this.isEndOfWord = false;
    this.children = Array(26).fill(null);
  }
}

class Solution {
  longestString(strings) {
    const root = new TrieNode();
    let maxLength = 0;
    let longestString = "";

    for (const s of strings) {
      let current = root;
      for (const c of s) {
        const index = c.charCodeAt(0) - 'a'.charCodeAt(0);
        if (!current.children[index]) {
          current.children[index] = new TrieNode();
        }
        current = current.children[index];
      }
      current.isEndOfWord = true;

      if (s.length > maxLength) {
        maxLength = s.length;
        longestString = s;
      }
    }

    return longestString;
  }
}
```

Note: The above code assumes that the input strings only contain lowercase English alphabets. If the input strings can contain uppercase letters, digits, or special characters, you'll need to modify the code accordingly.