---
id: "852214"
title: "New Year Resolution"
slug: "good-by-2023"
difficulty: "Medium"
companyTags: []
tags: ["Dynamic Programming", "Recursion"]
---

**New Year Resolution**
=====================

### Slug: good-by-2023
### Difficulty: Medium
### Id: 852214
### Topic Tags: Dynamic Programming, Recursion
### Company Tags: None

## Summary
The "New Year Resolution" problem is about calculating the minimum number of days required to complete a set of tasks given their start and end dates. The approach involves dynamic programming and recursion.

## Detailed Explanation
To solve this problem, we can use dynamic programming with recursion. The idea is to iterate over all tasks and for each task, calculate the minimum number of days required to complete it considering its start and end dates. We can use a recursive function to achieve this.

Here's a step-by-step breakdown of the solution:

1. Initialize an array `dp` to store the minimum number of days required to complete tasks.
2. Iterate over all tasks. For each task, calculate the minimum number of days required to complete it considering its start and end dates.
3. If the current day is less than or equal to the start date of the task, return 0 because we haven't started working on this task yet.
4. If the current day is greater than the end date of the task, return `dp[i-1]` where `i` is the index of the previous task because we have completed this task and we need to consider the minimum number of days required to complete the previous task.
5. Calculate the minimum number of days required to complete the current task by considering its start and end dates.

Here's an example:
```
  Task1: (3, 6)
  Task2: (4, 8)
  Task3: (7, 9)

  dp = [0]
  i = 0
  while i < 10 {
    if current day <= start date of task[i] {
      dp.append(0)
    } else if current day > end date of task[i] {
      dp.append(dp[i-1])
    } else {
      min_days = max(end date of task[i], dp[i-1])
      dp.append(min_days)
    }
    i++
  }

  minimum number of days required to complete all tasks is: dp[9]
```

The time complexity of this solution is O(n), where `n` is the total number of days. The space complexity is also O(n) because we need to store the minimum number of days required to complete each task.

## Optimized Solutions

### Java
```java
public int minDays(int[][] tasks) {
    int n = tasks.length;
    int[] dp = new int[n];
    for (int i = 0; i < n; i++) {
        if (tasks[i][0] > dp[i-1]) {
            dp[i] = tasks[i][0];
        } else {
            dp[i] = Math.max(tasks[i][1], dp[i-1]);
        }
    }
    return dp[n-1];
}
```

### Python
```python
def min_days(tasks):
    n = len(tasks)
    dp = [0]*n
    for i in range(n):
        if tasks[i][0] > dp[i-1]:
            dp[i] = tasks[i][0]
        else:
            dp[i] = max(tasks[i][1], dp[i-1])
    return dp[-1]
```

### C++
```cpp
int minDays(int tasks[][2], int n) {
    int* dp = new int[n];
    for (int i = 0; i < n; i++) {
        if (tasks[i][0] > dp[i-1]) {
            dp[i] = tasks[i][0];
        } else {
            dp[i] = max(tasks[i][1], dp[i-1]);
        }
    }
    int result = dp[n-1];
    delete[] dp;
    return result;
}
```

### JavaScript
```javascript
function minDays(tasks) {
    let n = tasks.length;
    let dp = new Array(n).fill(0);
    for (let i = 0; i < n; i++) {
        if (tasks[i][0] > dp[i-1]) {
            dp[i] = tasks[i][0];
        } else {
            dp[i] = Math.max(tasks[i][1], dp[i-1]);
        }
    }
    return dp[n-1];
}
```

Note that the optimized solutions are not necessarily the most efficient, but they illustrate the dynamic programming and recursion approach to solving this problem.