---
id: "710253"
title: "Cut woods"
slug: "cut-woods"
difficulty: "Hard"
companyTags: []
tags: []
---

**Cut Woods**
================

## Summary
Cut woods is a problem that involves cutting wooden planks of different lengths to create a set of sticks. The goal is to cut the planks in such a way that each stick can be used as a roof tile, with no two adjacent tiles overlapping and all tiles being used up. This problem requires a combination of mathematical and algorithmic thinking.

## Detailed Explanation
The problem involves cutting wooden planks into sticks of different lengths. Each plank has a unique length, and we need to cut them in such a way that each stick can be used as a roof tile. The constraint is that no two adjacent tiles should overlap, and all tiles should be used up.

To solve this problem, we can use a greedy algorithm approach. First, we sort the planks by their lengths in descending order. Then, we start cutting the planks from the longest to the shortest. For each plank, we check if it is possible to cut it into two or more sticks that can be used as roof tiles without overlapping.

If it is possible, we cut the plank and add the sticks to our set of usable sticks. If not, we leave the plank intact and move on to the next one. We repeat this process until all planks have been processed.

Here's a step-by-step breakdown of the solution:

1. Sort the planks by their lengths in descending order.
2. Start cutting the planks from the longest to the shortest.
3. For each plank, check if it is possible to cut it into two or more sticks that can be used as roof tiles without overlapping.
4. If it is possible, cut the plank and add the sticks to our set of usable sticks.
5. If not, leave the plank intact and move on to the next one.
6. Repeat steps 2-5 until all planks have been processed.

The time complexity of this algorithm is O(n log n), where n is the number of planks. This is because we are sorting the planks in step 1, which takes O(n log n) time. The space complexity is O(1), as we only need to keep track of a few variables during the algorithm.

## Optimized Solutions

### Java
```java
import java.util.Arrays;
import java.util.Comparator;

public class CutWoods {
    public static void main(String[] args) {
        int[][] planks = {{3, 5}, {1, 2}, {4, 6}};
        cutWoods(planks);
    }

    public static void cutWoods(int[][] planks) {
        Arrays.sort(planks, new Comparator<int[]>() {
            @Override
            public int compare(int[] p1, int[] p2) {
                return Integer.compare(p2[0] - p2[1], p1[0] - p1[1]);
            }
        });

        for (int i = 0; i < planks.length; i++) {
            int length = planks[i][0];
            int remainder = length - planks[i][1];

            if (remainder > 0) {
                // Cut the plank into two or more sticks
                while (remainder > 2) {
                    int half = remainder / 2;
                    System.out.println("Cutting stick of length " + half);
                    remainder -= half;
                }
                System.out.println("Cutting stick of length " + remainder);
            } else {
                // Leave the plank intact
                System.out.println("Leaving plank intact");
            }
        }
    }
}
```

### Python
```python
def cut_woods(planks):
    planks.sort(key=lambda x: x[1], reverse=True)

    for plank in planks:
        length, remainder = plank[0], plank[1]

        if remainder > 0:
            while remainder > 2:
                half = remainder // 2
                print(f"Cutting stick of length {half}")
                remainder -= half
            print(f"Cutting stick of length {remainder}")
        else:
            print("Leaving plank intact")

planks = [[3, 5], [1, 2], [4, 6]]
cut_woods(planks)
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void cutWoods(const std::vector<std::pair<int, int>>& planks) {
    std::sort(planks.begin(), planks.end(), [](const auto& p1, const auto& p2) {
        return p2.second - p2.first > p1.second - p1.first;
    });

    for (const auto& plank : planks) {
        int length = plank.first;
        int remainder = length - plank.second;

        if (remainder > 0) {
            while (remainder > 2) {
                int half = remainder / 2;
                std::cout << "Cutting stick of length " << half << std::endl;
                remainder -= half;
            }
            std::cout << "Cutting stick of length " << remainder << std::endl;
        } else {
            std::cout << "Leaving plank intact" << std::endl;
        }
    }
}

int main() {
    std::vector<std::pair<int, int>> planks = {{3, 5}, {1, 2}, {4, 6}};
    cutWoods(planks);
    return 0;
}
```

### JavaScript
```javascript
function cutWoods(planks) {
    planks.sort((p1, p2) => p2[1] - p2[0] - (p1[1] - p1[0]));

    for (const plank of planks) {
        const length = plank[0];
        const remainder = length - plank[1];

        if (remainder > 0) {
            while (remainder > 2) {
                const half = Math.floor(remainder / 2);
                console.log(`Cutting stick of length ${half}`);
                remainder -= half;
            }
            console.log(`Cutting stick of length ${remainder}`);
        } else {
            console.log("Leaving plank intact");
        }
    }
}

const planks = [[3, 5], [1, 2], [4, 6]];
cutWoods(planks);
```