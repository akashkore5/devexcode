---
id: "714140"
title: "Anagrams in Linked List"
slug: "find-anagrams-in-linked-list--170647"
difficulty: "Medium"
companyTags: []
tags: ["Linked List", "sliding-window"]
---

# Anagrams in Linked List

## Summary

Given a linked list and a target anagram, find all occurrences of the target anagram within the linked list. This problem involves manipulating a linked list while keeping track of character frequencies to identify anagrams.

## Detailed Explanation

To solve this problem, we can use a sliding window approach. We maintain a frequency map for the target anagram and slide a window over the linked list to find matches. Here's a step-by-step breakdown:

1. Initialize an empty frequency map `freqMap` with character frequencies for the target anagram.
2. Iterate through the linked list, maintaining a sliding window of size equal to the length of the target anagram.
3. For each node in the window:
	* Update the frequency map by incrementing the count for each character in the current node's value.
	* If the frequency map matches the original `freqMap`, we have found a match and add it to our result list.
4. Continue iterating until the end of the linked list is reached.

Time complexity: O(n), where n is the length of the linked list, since we only iterate through the list once.

Space complexity: O(1), as we maintain a fixed-size frequency map.

Here's an ASCII art diagram to illustrate the sliding window approach:
```
          +---------------+
          |  A  |  B  | C  |
          +---------------+
                  ^
                  |  Window of size 3
                  v
+---------------+
|  D  |  E  | F  |
+---------------+
```

## Optimized Solutions

### Java
```java
public class Solution {
    public List<String> findAnagrams(ListNode head, String target) {
        Map<Character, Integer> freqMap = new HashMap<>();
        for (char c : target.toCharArray()) {
            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
        }
        
        List<String> result = new ArrayList<>();
        ListNode current = head;
        while (current != null) {
            Map<Character, Integer> windowFreqMap = new HashMap<>(freqMap);
            for (int i = 0; i < target.length(); i++) {
                char c = current.val.charAt(i);
                windowFreqMap.put(c, windowFreqMap.getOrDefault(c, 0) - 1);
                if (windowFreqMap.equals(freqMap)) {
                    result.add(current.val.substring(0, target.length()));
                }
            }
            current = current.next;
        }
        return result;
    }
}
```

### Python
```python
class Solution:
    def find_anagrams(self, head: ListNode, target: str) -> List[str]:
        freq_map = {c: freq_map.get(c, 0) + 1 for c in target}
        
        result = []
        current = head
        while current:
            window_freq_map = dict(freq_map)
            for i in range(len(target)):
                c = current.val[i]
                window_freq_map[c] -= 1
                if window_freq_map == freq_map:
                    result.append(current.val[:len(target)])
            current = current.next
        return result
```

### C++
```cpp
class Solution {
public:
    vector<string> findAnagrams(ListNode* head, string target) {
        unordered_map<char, int> freqMap;
        for (char c : target) {
            freqMap[c]++;
        }
        
        vector<string> result;
        ListNode* current = head;
        while (current) {
            unordered_map<char, int> windowFreqMap(freqMap);
            for (int i = 0; i < target.length(); i++) {
                char c = current->val[i];
                windowFreqMap[c]--;
                if (windowFreqMap == freqMap) {
                    result.push_back(current->val.substr(0, target.length()));
                }
            }
            current = current->next;
        }
        return result;
    }
};
```

### JavaScript
```javascript
class Solution {
  findAnagrams(head, target) {
    const freqMap = {};
    for (let c of target) {
      freqMap[c] = (freqMap[c] || 0) + 1;
    }
    
    const result = [];
    let current = head;
    while (current) {
      const windowFreqMap = { ...freqMap };
      for (let i = 0; i < target.length; i++) {
        const c = current.val[i];
        windowFreqMap[c]--;
        if (JSON.stringify(windowFreqMap) === JSON.stringify(freqMap)) {
          result.push(current.val.slice(0, target.length));
        }
      }
      current = current.next;
    }
    return result;
  }
}
```

Note that the above solutions assume a `ListNode` class with a `val` property representing the node's value and a `next` property pointing to the next node in the linked list.