---
id: "711400"
title: "Number of Ways to Arrive at Destination"
slug: "number-of-ways-to-arrive-at-destination"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "Shortest Path", "Data Structures", "Algorithms"]
---

**Number of Ways to Arrive at Destination**
================================================

## Summary
The problem is about finding the number of ways a person can arrive at their destination given a set of paths with varying costs. The key concept involved is shortest path, which is typically solved using algorithms such as Dijkstra's or Bellman-Ford.

## Detailed Explanation
To solve this problem, we will use a graph-based approach. We'll create a weighted graph where each node represents a location and the edges represent the paths between locations. Each edge will have a weight (cost) associated with it.

We can use Dijkstra's algorithm to find the shortest path from the starting point to all other points in the graph, which represents the minimum cost required to arrive at each destination. The number of ways to arrive at a destination is then equal to the total number of paths that have the same minimum cost as the shortest path.

Here's a step-by-step breakdown of the solution:

1. Create a weighted graph with nodes representing locations and edges representing paths between locations.
2. Use Dijkstra's algorithm to find the shortest path from the starting point to all other points in the graph.
3. For each destination, count the number of paths that have the same minimum cost as the shortest path.

Time complexity: O(E + V log V), where E is the number of edges and V is the number of vertices. This is because Dijkstra's algorithm has a time complexity of O(E + V log V).

Space complexity: O(V), where V is the number of vertices. This is because we need to store the shortest distances and previous nodes for each vertex.

## Optimized Solutions
### Java
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Create a graph with weighted edges
        Map<String, Map<String, Integer>> graph = new HashMap<>();
        graph.put("A", new HashMap<>());
        graph.get("A").put("B", 2);
        graph.get("A").put("C", 3);
        graph.put("B", new HashMap<>());
        graph.get("B").put("D", 1);
        graph.put("C", new HashMap<>());
        graph.get("C").put("D", 2);

        // Find the shortest paths using Dijkstra's algorithm
        Map<String, Integer> distances = new HashMap<>();
        Map<String, String> previousNodes = new HashMap<>();
        dijkstra(graph, "A", distances, previousNodes);

        // Count the number of ways to arrive at each destination
        int totalWays = 0;
        for (Map.Entry<String, Integer> entry : distances.entrySet()) {
            if (entry.getValue() == getMinimumCost(graph, "A")) {
                totalWays++;
            }
        }

        System.out.println("Total number of ways: " + totalWays);
    }

    public static void dijkstra(Map<String, Map<String, Integer>> graph, String startNode, Map<String, Integer> distances, Map<String, String> previousNodes) {
        Set<String> visited = new HashSet<>();
        PriorityQueue<Map.Entry<String, Integer>> queue = new PriorityQueue<>();

        // Initialize the distances and previous nodes
        for (Map.Entry<String, Map<String, Integer>> entry : graph.entrySet()) {
            distances.put(entry.getKey(), Integer.MAX_VALUE);
            previousNodes.put(entry.getKey(), null);
        }
        distances.put(startNode, 0);

        // Run Dijkstra's algorithm
        queue.add(new AbstractMap.SimpleEntry<>(startNode, 0));
        while (!queue.isEmpty()) {
            Map.Entry<String, Integer> current = queue.poll();
            if (visited.contains(current.getKey())) continue;
            visited.add(current.getKey());

            for (Map.Entry<String, Integer> edge : graph.get(current.getKey()).entrySet()) {
                int newDistance = distances.get(current.getKey()) + edge.getValue();
                if (newDistance < distances.getOrDefault(edge.getKey(), Integer.MAX_VALUE)) {
                    distances.put(edge.getKey(), newDistance);
                    previousNodes.put(edge.getKey(), current.getKey());
                    queue.add(new AbstractMap.SimpleEntry<>(edge.getKey(), newDistance));
                }
            }
        }
    }

    public static int getMinimumCost(Map<String, Map<String, Integer>> graph, String startNode) {
        return distances.getOrDefault(startNode, Integer.MAX_VALUE);
    }
}
```

### Python
```python
import heapq

def dijkstra(graph, start_node):
    distances = {node: float('inf') for node in graph}
    previous_nodes = {node: None for node in graph}

    visited = set()
    queue = [(0, start_node)]

    while queue:
        current_distance, current_node = heapq.heappop(queue)

        if current_node in visited: continue
        visited.add(current_node)

        for neighbor, weight in graph[current_node].items():
            new_distance = current_distance + weight

            if new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
                previous_nodes[neighbor] = current_node
                heapq.heappush(queue, (new_distance, neighbor))

    return distances

def get_minimum_cost(graph, start_node):
    return graph[start_node]

graph = {
    "A": {"B": 2, "C": 3},
    "B": {"D": 1},
    "C": {"D": 2}
}

start_node = "A"

distances = dijkstra(graph, start_node)

total_ways = 0
minimum_cost = get_minimum_cost(graph, start_node)
for node, distance in distances.items():
    if distance == minimum_cost:
        total_ways += 1

print("Total number of ways: ", total_ways)
```

### C++
```cpp
#include <iostream>
#include <queue>
#include <map>

using namespace std;

int dijkstra(map<string, map<string, int>> graph, string startNode) {
    map<string, int> distances;
    map<string, string> previousNodes;

    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> queue;

    for (auto& entry : graph) {
        distances[entry.first] = INT_MAX;
        previousNodes[entry.first] = "";
    }
    distances[startNode] = 0;

    while (!queue.empty()) {
        pair<int, string> current = queue.top();
        queue.pop();

        if (visited.count(current.second)) continue;

        visited.insert(current.second);

        for (auto& edge : graph[current.second]) {
            int newDistance = distances[current.second] + edge.second;
            if (newDistance < distances[edge.first]) {
                distances[edge.first] = newDistance;
                previousNodes[edge.first] = current.second;
                queue.push({newDistance, edge.first});
            }
        }
    }

    return distances[startNode];
}

int main() {
    map<string, map<string, int>> graph = {
        {"A", {{"B", 2}, {"C", 3}}},
        {"B", {{"D", 1}}},
        {"C", {{"D", 2}}}
    };

    string startNode = "A";

    int minimumCost = dijkstra(graph, startNode);

    int totalWays = 0;
    for (auto& entry : distances) {
        if (entry.second == minimumCost) {
            totalWays++;
        }
    }

    cout << "Total number of ways: " << totalWays << endl;

    return 0;
}
```

### JavaScript
```javascript
class Graph {
    constructor(edges) {
        this.edges = edges;
    }

    dijkstra(startNode) {
        const distances = {};
        const previousNodes = {};

        const queue = [];

        for (const edge in this.edges) {
            distances[edge] = Infinity;
            previousNodes[edge] = null;
        }
        distances[startNode] = 0;

        while (queue.length > 0) {
            const current = queue.shift();
            if (visited.has(current)) continue;
            visited.add(current);

            for (const neighbor in this.edges[current]) {
                const newDistance = distances[current] + neighbor;
                if (newDistance < distances[neighbor]) {
                    distances[neighbor] = newDistance;
                    previousNodes[neighbor] = current;
                    queue.push(neighbor);
                }
            }
        }

        return distances[startNode];
    }
}

const graph = new Graph({
  "A": {"B": 2, "C": 3},
  "B": {"D": 1},
  "C": {"D": 2}
});

const startNode = "A";

const minimumCost = graph.dijkstra(startNode);

let totalWays = 0;
for (const entry in distances) {
  if (entry.second === minimumCost) {
    totalWays++;
  }
}

console.log("Total number of ways: ", totalWays);
```

Note that these code snippets are just examples and may not be perfect implementations.