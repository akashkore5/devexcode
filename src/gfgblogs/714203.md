---
id: "714203"
title: "Job Sequencing Problem"
slug: "job-sequencing-problem--170647"
difficulty: "Medium"
companyTags: ["Accolite", "Microsoft"]
tags: ["Dynamic Programming", "Greedy", "Algorithms"]
---

**Job Sequencing Problem**
==================================

### Summary
The Job Sequencing problem is a dynamic programming problem that involves scheduling jobs with different deadlines and processing times. The goal is to schedule the jobs in such a way that all deadlines are met, while also maximizing the total processing time.

### Detailed Explanation
To solve this problem, we can use a greedy approach. We first sort the jobs based on their deadlines and then iterate over the sorted jobs. For each job, we check if it can be scheduled without violating any deadline. If it can, we schedule it and update our current time accordingly. If not, we skip that job.

Here's a step-by-step breakdown of the solution:

1. Sort the jobs based on their deadlines.
2. Initialize a variable `time` to 0, which represents the current time.
3. Iterate over the sorted jobs:
   - For each job, check if it can be scheduled without violating any deadline. To do this, compare the job's deadline with the current time. If the job's deadline is greater than or equal to the current time, schedule the job and update the `time` variable to the job's deadline.
   - If the job cannot be scheduled (i.e., its deadline is less than the current time), skip that job and move on to the next one.
4. Return the total processing time of all scheduled jobs.

Here's an ASCII art diagram illustrating the process:
```
          +---------------+
          |  Job A  |
          +---------------+
                  |
                  v
          +---------------+
          |  Time = 0   |
          +---------------+
                  |
                  v
          +---------------+
          |  Job B (deadline 3)|
          |  (processing time 2)|
          +---------------+
                  |
                  v
          +---------------+
          |  Time = 3   |
          +---------------+
                  |
                  v
          +---------------+
          |  Job C (deadline 5)|
          |  (processing time 4)|
          +---------------+
                  |
                  v
          +---------------+
          |  Time = 7   |
          +---------------+
```
The time complexity of this solution is O(n log n), where n is the number of jobs, due to the sorting step. The space complexity is O(1), as we only use a few variables to store our current time and job information.

### Optimized Solutions

#### Java
```java
import java.util.Arrays;
import java.util.Comparator;

public class JobSequencing {
    public static int jobScheduling(int[] deadLine, int[] procTime) {
        int n = deadLine.length;
        Integer[][] jobs = new Integer[n][2];
        for (int i = 0; i < n; i++) {
            jobs[i] = new Integer[]{deadLine[i], procTime[i]};
        }
        Arrays.sort(jobs, Comparator.comparingInt(a -> a[0]));
        int time = 0;
        int totalProc = 0;
        for (int[] job : jobs) {
            if (time + job[1] <= job[0]) {
                time += job[1];
                totalProc += job[1];
            }
        }
        return totalProc;
    }
}
```

#### Python
```python
def job_sequencing(deadlines, processing_times):
    n = len(deadlines)
    jobs = [(deadline, proc_time) for deadline, proc_time in zip(deadlines, processing_times)]
    jobs.sort(key=lambda x: x[0])
    time = 0
    total_processing_time = 0
    for job in jobs:
        if time + job[1] <= job[0]:
            time += job[1]
            total_processing_time += job[1]
    return total_processing_time
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int jobScheduling(std::vector<int>& deadlines, std::vector<int>& processingTimes) {
    int n = deadlines.size();
    std::vector<std::pair<int, int>> jobs;
    for (int i = 0; i < n; i++) {
        jobs.push_back({deadlines[i], processingTimes[i]});
    }
    std::sort(jobs.begin(), jobs.end());
    int time = 0;
    int totalProcessingTime = 0;
    for (const auto& job : jobs) {
        if (time + job.second <= job.first) {
            time += job.second;
            totalProcessingTime += job.second;
        }
    }
    return totalProcessingTime;
}
```

#### JavaScript
```javascript
function jobScheduling(deadlines, processingTimes) {
    let n = deadlines.length;
    let jobs = [];
    for (let i = 0; i < n; i++) {
        jobs.push([deadlines[i], processingTimes[i]]);
    }
    jobs.sort((a, b) => a[0] - b[0]);
    let time = 0;
    let totalProcessingTime = 0;
    for (let job of jobs) {
        if (time + job[1] <= job[0]) {
            time += job[1];
            totalProcessingTime += job[1];
        }
    }
    return totalProcessingTime;
}
```