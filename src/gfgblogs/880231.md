---
id: "880231"
title: "Array Transformation with Repeated Steps and Modulo Operation"
slug: "array-transformation-with-repeated-steps-and-modulo-operation"
difficulty: "Easy"
companyTags: []
tags: []
---

Here is a detailed Markdown blog post for the problem "Array Transformation with Repeated Steps and Modulo Operation":

# Array Transformation with Repeated Steps and Modulo Operation
## Summary
Given an array, we need to transform it by repeating certain steps until no more changes can be made. Each step involves applying a modulo operation on all elements of the array. The goal is to find the final transformed array.

## Detailed Explanation
To solve this problem, we'll start with an understanding of the given constraints and requirements. We are provided with an integer array `arr` and an integer `k`. Our task is to repeatedly apply a transformation step until no further changes can be made.

The transformation step involves taking each element in the array, adding `k`, and then taking the remainder when divided by `n`, where `n` is the length of the array. We'll repeat this process until the array remains unchanged after one iteration.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty array `result`.
2. Repeat the following steps until no further changes can be made:
   - For each element `x` in the array, add `k` and take the remainder when divided by `n`. This gives us the new value for `x`.
   - Update the original array with the new values.
3. Return the final transformed array.

Let's analyze the time complexity of this solution:

* We're performing a constant-time operation (adding `k` and taking the remainder) for each element in the array, which takes O(n) time.
* Since we're doing this repeatedly until no further changes can be made, the total time complexity is O(n * k).
* The space complexity is O(n), as we need to store the original array and the transformed array.

## Optimized Solutions

### Java
```java
public int[] arrayTransformation(int[] arr, int k) {
    int n = arr.length;
    while (true) {
        boolean changed = false;
        for (int i = 0; i < n; i++) {
            int newX = (arr[i] + k) % n;
            if (newX != arr[i]) {
                arr[i] = newX;
                changed = true;
            }
        }
        if (!changed) break;
    }
    return arr;
}
```

### Python
```python
def array_transformation(arr, k):
    n = len(arr)
    while True:
        changed = False
        for i in range(n):
            new_val = (arr[i] + k) % n
            if new_val != arr[i]:
                arr[i] = new_val
                changed = True
        if not changed:
            break
    return arr
```

### C++
```cpp
#include <vector>

std::vector<int> arrayTransformation(std::vector<int> arr, int k) {
    int n = arr.size();
    while (true) {
        bool changed = false;
        for (int i = 0; i < n; i++) {
            int newX = (arr[i] + k) % n;
            if (newX != arr[i]) {
                arr[i] = newX;
                changed = true;
            }
        }
        if (!changed) break;
    }
    return arr;
}
```

### JavaScript
```javascript
function arrayTransformation(arr, k) {
  let n = arr.length;
  while (true) {
    let changed = false;
    for (let i = 0; i < n; i++) {
      let newX = (arr[i] + k) % n;
      if (newX !== arr[i]) {
        arr[i] = newX;
        changed = true;
      }
    }
    if (!changed) break;
  }
  return arr;
}
```