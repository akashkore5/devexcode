---
id: "879264"
title: "Multiple inheritence in Python"
slug: "multiple-inheritence-in-python"
difficulty: "Easy"
companyTags: []
tags: []
---

Here is a detailed Markdown blog post for the problem "Multiple Inheritence in Python":

# Multiple Inheritence in Python
## Summary
In this problem, we will explore how to achieve multiple inheritence in Python. We know that multiple inheritance means having more than one parent class. This concept can be achieved using classes and objects in Python.

## Detailed Explanation
Python allows for single inheritance where a child class inherits from only one parent class. However, what if you want your child class to inherit properties and methods from two or more parent classes? This is where multiple inheritance comes into play. To achieve this, you can use the concept of composition, where you create objects of other classes in your class.

Here's a step-by-step breakdown of the solution:

* Create a base class for each feature you want to inherit.
* Inherit from all these base classes in your child class using parentheses.
* Override any methods that are common to multiple parent classes to avoid ambiguity.
* Use composition to create objects of other classes if needed.

Here's an example:
```python
class A:
    def method_a(self):
        print("Method a from A")

class B:
    def method_b(self):
        print("Method b from B")

class C(A, B):
    pass

c = C()
c.method_a()  # prints "Method a from A"
c.method_b()  # prints "Method b from B"
```
Time and space complexity analysis:

* Time complexity: O(1) for method calls
* Space complexity: O(1) for object creation

## Optimized Solutions

### Python
```python
class A:
    def method_a(self):
        print("Method a from A")

class B:
    def method_b(self):
        print("Method b from B")

class C(A, B):
    pass

c = C()
c.method_a()  # prints "Method a from A"
c.method_b()  # prints "Method b from B"
```
### Java
```java
class A {
    public void methodA() {
        System.out.println("Method a from A");
    }
}

class B {
    public void methodB() {
        System.out.println("Method b from B");
    }
}

class C extends A implements B {
    // no need to override methods if they are not common
}

public class Main {
    public static void main(String[] args) {
        C c = new C();
        c.methodA();  // prints "Method a from A"
        c.methodB();  // prints "Method b from B"
    }
}
```
### C++
```cpp
class A {
public:
    void methodA() {
        std::cout << "Method a from A" << std::endl;
    }
};

class B {
public:
    void methodB() {
        std::cout << "Method b from B" << std::endl;
    }
};

class C : public A, public B {
public:
    // no need to override methods if they are not common
};

int main() {
    C c;
    c.methodA();  // prints "Method a from A"
    c.methodB();  // prints "Method b from B"
    return 0;
}
```
### JavaScript
```javascript
class A {
  methodA() {
    console.log("Method a from A");
  }
}

class B {
  methodB() {
    console.log("Method b from B");
  }
}

class C extends A implements B {
  // no need to override methods if they are not common
}

let c = new C();
c.methodA();  // prints "Method a from A"
c.methodB();  // prints "Method b from B"
```
Note that the optimized solutions are just examples and may not be the most efficient or optimal way to solve the problem.