---
id: "713138"
title: "Maximum Value"
slug: "maximum-value--170645"
difficulty: "Medium"
companyTags: ["Amazon"]
tags: ["DFS", "Tree", "implementation", "Data Structures", "Algorithms"]
---

**Maximum Value**
================

**Slug:** maximum-value--170645
**Difficulty:** Medium
**Id:** 713138
**Topic Tags:** DFS, Tree, implementation, Data Structures, Algorithms
**Company Tags:** Amazon

## Summary
The problem is about finding the maximum value in a tree data structure. The given tree is represented as an adjacency list, where each node has a unique value. The goal is to find the maximum value in the tree.

## Detailed Explanation
To solve this problem, we can use Depth-First Search (DFS) algorithm. We will start from the root of the tree and recursively explore all its child nodes until we reach a leaf node or the end of the traversal. At each step, we keep track of the maximum value seen so far.

Here is a step-by-step breakdown of the solution:

1. Start from the root node of the tree.
2. Initialize a variable `max_value` to store the maximum value seen so far.
3. Traverse the tree using DFS:
	* For each node, check if it's a leaf node or not.
	* If it's a leaf node, compare its value with `max_value`. Update `max_value` if the current node's value is greater.
	* If it's not a leaf node, recursively traverse its child nodes and update `max_value` accordingly.
4. Return the maximum value found in the tree.

Time complexity: O(N), where N is the number of nodes in the tree. This is because we visit each node exactly once.

Space complexity: O(H), where H is the height of the tree. This is because we need to store the recursive call stack, which can go up to the height of the tree.

## Optimized Solutions

### Java
```java
public class MaximumValue {
    public static int findMaxValue(int[][] tree) {
        int max_value = Integer.MIN_VALUE;
        dfs(tree, 0, max_value);
        return max_value;
    }

    private static void dfs(int[][] tree, int node, int max_value) {
        if (tree[node] == null) {
            // Leaf node
            max_value = Math.max(max_value, tree[node - 1]);
        } else {
            for (int child : tree[node]) {
                dfs(tree, child, max_value);
            }
        }
    }
}
```

### Python
```python
class MaximumValue:
    def find_max_value(self, tree):
        max_value = float('-inf')
        self.dfs(tree, 0, max_value)
        return max_value

    def dfs(self, tree, node, max_value):
        if not tree[node]:
            # Leaf node
            max_value = max(max_value, tree[node - 1])
        else:
            for child in tree[node]:
                self.dfs(tree, child, max_value)
```

### C++
```cpp
class MaximumValue {
public:
    int findMaxValue(int** tree, int N) {
        int max_value = INT_MIN;
        dfs(tree, 0, max_value);
        return max_value;
    }

private:
    void dfs(int** tree, int node, int& max_value) {
        if (!tree[node]) {
            // Leaf node
            max_value = std::max(max_value, tree[node - 1]);
        } else {
            for (int child : tree[node]) {
                dfs(tree, child, max_value);
            }
        }
    }
};
```

### JavaScript
```javascript
class MaximumValue {
    findMaxValue(tree) {
        let max_value = -Infinity;
        this.dfs(tree, 0, max_value);
        return max_value;
    }

    dfs(tree, node, max_value) {
        if (!tree[node]) {
            // Leaf node
            max_value = Math.max(max_value, tree[node - 1]);
        } else {
            for (let child of tree[node]) {
                this.dfs(tree, child, max_value);
            }
        }
    }
}
```