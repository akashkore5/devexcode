---
id: "702879"
title: "Swap and Maximize"
slug: "swap-and-maximize5859"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Greedy", "Sorting", "Data Structures", "Algorithms"]
---

Here is a detailed Markdown blog post for the "Swap and Maximize" problem:

# Swap and Maximize
## Summary
The "Swap and Maximize" problem involves given an array of integers, swapping adjacent elements to maximize the sum of the array. The goal is to find the maximum possible sum by swapping elements in the array.

This problem involves algorithms related to arrays, greedy, sorting, and data structures.

## Detailed Explanation

To solve this problem, we can use a simple algorithm that iterates through the array, keeping track of the maximum sum found so far. When an adjacent pair of elements is found that would increase the total sum if swapped, the swap is performed.

Here's a step-by-step breakdown of the solution:

1. Initialize a variable `max_sum` to store the maximum sum found so far.
2. Iterate through the array, keeping track of the current sum.
3. For each pair of adjacent elements, calculate the sum if they are swapped.
4. If the swapped sum is greater than the current `max_sum`, update `max_sum` and perform the swap.
5. Repeat steps 2-4 until the end of the array is reached.

The time complexity for this algorithm is O(n), where n is the length of the array, since we need to iterate through each element once. The space complexity is O(1) because we only use a constant amount of space to store `max_sum` and other variables.

Here's an ASCII art diagram showing the swapping process:

```
[5, 3, 2, 7]
swap 3 and 2: [5, 2, 3, 7]
swap 2 and 7: [5, 7, 3, 2]
max_sum = 17
```

## Optimized Solutions

### Java
```java
public int maxSum(int[] arr) {
    int max_sum = 0;
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > arr[i-1]) {
            int temp = arr[i];
            arr[i] = arr[i-1];
            arr[i-1] = temp;
            max_sum += arr[i] - arr[i-1];
        }
    }
    return max_sum;
}
```

### Python
```python
def max_sum(arr):
    max_sum = 0
    for i in range(1, len(arr)):
        if arr[i] > arr[i-1]:
            arr[i], arr[i-1] = arr[i-1], arr[i]
            max_sum += arr[i] - arr[i-1]
    return max_sum
```

### C++
```cpp
int maxSum(int* arr, int n) {
    int max_sum = 0;
    for (int i = 1; i < n; i++) {
        if (arr[i] > arr[i-1]) {
            int temp = arr[i];
            arr[i] = arr[i-1];
            arr[i-1] = temp;
            max_sum += arr[i] - arr[i-1];
        }
    }
    return max_sum;
}
```

### JavaScript
```javascript
function maxSum(arr) {
    let max_sum = 0;
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > arr[i-1]) {
            [arr[i], arr[i-1]] = [arr[i-1], arr[i]];
            max_sum += arr[i] - arr[i-1];
        }
    }
    return max_sum;
}
```

These optimized solutions all have the same time and space complexity as the original algorithm: O(n) and O(1), respectively.