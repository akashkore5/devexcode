---
id: "702876"
title: "King's War"
slug: "kings-war2448"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

Here is the blog post for the King's War problem:

**Kings-War2448**
==================

## Summary
The King's War problem involves a scenario where you are given an array of integers representing the strength of different kingdoms. The goal is to find the maximum number of kingdoms that can be conquered by one kingdom, considering the following rules: (1) a stronger kingdom can conquer a weaker one, and (2) a kingdom cannot conquer itself.

## Detailed Explanation
To solve this problem, we need to iterate through the array and keep track of the maximum strength of the conquered kingdoms. We will use an array `maxConquer` to store the maximum number of kingdoms that can be conquered by each kingdom.

Here's the step-by-step breakdown:

1. Initialize `maxConquer[0] = 1`, as a kingdom with no neighbors can conquer only itself.
2. Iterate through the array from index 1 to N-1 (where N is the length of the array).
3. For each kingdom at index i, find the maximum number of kingdoms that can be conquered by this kingdom, considering its strength and the strengths of the previous kingdoms.
4. Update `maxConquer[i]` with the maximum value found in step 3.
5. The final answer is the maximum value in the `maxConquer` array.

Time complexity: O(N), where N is the length of the input array.
Space complexity: O(1), as we only use a constant amount of space to store the `maxConquer` array.

## Optimized Solutions
### Java
```java
public int maxConquer(int[] strength) {
    int[] maxConquer = new int[strength.length];
    maxConquer[0] = 1;
    int max = 1;
    for (int i = 1; i < strength.length; i++) {
        if (strength[i] > strength[i-1]) {
            maxConquer[i] = max + 1;
            max++;
        } else {
            maxConquer[i] = 1;
        }
    }
    return Arrays.stream(maxConquer).max().getAsInt();
}
```
### Python
```python
def max_conquer(strength):
    max_conquer = [1]
    for i in range(1, len(strength)):
        if strength[i] > strength[i-1]:
            max_conquer.append(max_conquer[-1] + 1)
            max_conquer[-1] += 1
        else:
            max_conquer.append(1)
    return max(max_conquer)
```
### C++
```cpp
int maxConquer(int* strength, int N) {
    int* maxConquer = new int[N];
    maxConquer[0] = 1;
    int max = 1;
    for (int i = 1; i < N; i++) {
        if (strength[i] > strength[i-1]) {
            maxConquer[i] = max + 1;
            max++;
        } else {
            maxConquer[i] = 1;
        }
    }
    delete[] maxConquer;
    return *std::max_element(maxConquer, maxConquer + N);
}
```
### JavaScript
```javascript
function maxConquer(strength) {
    let maxConquer = [1];
    for (let i = 1; i < strength.length; i++) {
        if (strength[i] > strength[i-1]) {
            maxConquer.push(maxConquer[maxConquer.length - 1] + 1);
            maxConquer[maxConquer.length - 1]++;
        } else {
            maxConquer.push(1);
        }
    }
    return Math.max(...maxConquer);
}
```
Note: The JavaScript solution uses the `Math.max` function and the spread operator (`...`) to find the maximum value in the `maxConquer` array.