---
id: "714333"
title: "Dominant Pairs"
slug: "dominant-pairs"
difficulty: "Easy"
companyTags: []
tags: ["two-pointer-algorithm", "Sorting", "Algorithms"]
---

**Dominant Pairs**
==================

### Summary
Given an array of integers, find all dominant pairs. A pair `(i, j)` is considered dominant if `arr[i]` and `arr[j]` are the same and `i < j`. The function should return a list of these dominant pairs.

This problem involves sorting and using two-pointer technique to solve this issue efficiently.

### Detailed Explanation
To solve this problem, we can sort the array first. Then, we use two pointers, one at the start of the array and another at the end. As long as the elements at these positions are equal, we move the pointers towards each other until they're not equal anymore. At this point, all dominant pairs have been identified.

Here's a step-by-step breakdown:

1. Sort the input array.
2. Initialize two pointers `i` and `j`, where `i` is at the start of the array and `j` is at the end.
3. As long as `arr[i]` and `arr[j]` are equal, move both pointers towards each other (`i++` and `j--`).
4. Once `arr[i]` and `arr[j]` become unequal, all dominant pairs have been identified.

Time complexity: O(n log n) due to sorting.
Space complexity: O(1), as we only use a constant amount of space.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class DominantPairs {
    public static List<List<Integer>> findDominantPairs(int[] arr) {
        Arrays.sort(arr);
        List<List<Integer>> dominantPairs = new ArrayList<>();
        
        int i = 0, j = arr.length - 1;
        while (i < j) {
            if (arr[i] == arr[j]) {
                dominantPairs.add(Arrays.asList(arr[i], i, j));
                i++;
                j--;
            } else if (arr[i] < arr[j]) {
                i++;
            } else {
                j--;
            }
        }
        
        return dominantPairs;
    }
}
```

#### Python
```python
def find_dominant_pairs(arr):
    arr.sort()
    dominant_pairs = []
    
    i, j = 0, len(arr) - 1
    while i < j:
        if arr[i] == arr[j]:
            dominant_pairs.append([arr[i], i, j])
            i += 1
            j -= 1
        elif arr[i] < arr[j]:
            i += 1
        else:
            j -= 1
    
    return dominant_pairs
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<std::vector<int>> findDominantPairs(int* arr, int n) {
    std::sort(arr, arr + n);
    std::vector<std::vector<int>> dominantPairs;
    
    int i = 0, j = n - 1;
    while (i < j) {
        if (arr[i] == arr[j]) {
            dominantPairs.push_back({arr[i], i, j});
            i++;
            j--;
        } else if (arr[i] < arr[j]) {
            i++;
        } else {
            j--;
        }
    }
    
    return dominantPairs;
}
```

#### JavaScript
```javascript
function findDominantPairs(arr) {
    arr.sort((a, b) => a - b);
    const dominantPairs = [];
    
    let i = 0, j = arr.length - 1;
    while (i < j) {
        if (arr[i] === arr[j]) {
            dominantPairs.push([arr[i], i, j]);
            i++;
            j--;
        } else if (arr[i] < arr[j]) {
            i++;
        } else {
            j--;
        }
    }
    
    return dominantPairs;
}
```