---
id: "700234"
title: "Absolute List Sorting"
slug: "absolute-list-sorting"
difficulty: "Medium"
companyTags: ["Amazon", "OYO Rooms"]
tags: ["Linked List", "Data Structures"]
---

# Absolute List Sorting
## Slug: absolute-list-sorting
## Difficulty: Medium
## Topic Tags: Linked List, Data Structures
## Company Tags: Amazon, OYO Rooms

### Summary
Given a singly linked list where each node contains an integer value and its corresponding absolute value, the task is to sort the list based on these absolute values. This problem requires understanding of linked lists and basic sorting algorithms.

### Detailed Explanation
To solve this problem, we'll start by iterating over the linked list and storing each node's absolute value in a separate array or data structure. Then, we'll sort this array using any standard sorting algorithm (e.g., quicksort, mergesort). Once the array is sorted, we can iterate over it again to reconstruct the original linked list in the correct order.

Here's a step-by-step breakdown of the solution:

1.  Initialize an empty array or data structure `sortedAbs` to store the absolute values.
2.  Iterate over the linked list and extract each node's absolute value. Store these values in `sortedAbs`.
3.  Sort `sortedAbs` using any standard sorting algorithm (e.g., quicksort, mergesort).
4.  Initialize an empty linked list `result` to store the sorted nodes.
5.  Iterate over `sortedAbs` and reconstruct the original linked list by creating new nodes with their corresponding absolute values.
6.  Return the sorted linked list.

Time complexity: O(n log n) due to sorting, where n is the number of nodes in the linked list.
Space complexity: O(n) for storing the absolute values in `sortedAbs`.

### Optimized Solutions

#### Java
```java
public ListNode absoluteListSorting(ListNode head) {
    if (head == null) return null;

    // Step 1: Extract and store absolute values
    List<Integer> sortedAbs = new ArrayList<>();
    while (head != null) {
        int absVal = Math.abs(head.val);
        sortedAbs.add(absVal);
        head = head.next;
    }

    // Step 2: Sort the array of absolute values
    Collections.sort(sortedAbs);

    // Step 3: Reconstruct the linked list in the correct order
    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;
    for (int absVal : sortedAbs) {
        int sign = Math.signum(head.val); // Determine the original sign
        ListNode newNode = new ListNode(absVal * sign);
        curr.next = newNode;
        curr = curr.next;
    }

    return dummy.next;
}
```

#### Python
```python
def absolute_list_sorting(head):
    if head is None:
        return None

    # Step 1: Extract and store absolute values
    sorted_abs = []
    while head:
        abs_val = abs(head.val)
        sorted_abs.append(abs_val)
        head = head.next

    # Step 2: Sort the array of absolute values
    sorted_abs.sort()

    # Step 3: Reconstruct the linked list in the correct order
    dummy = ListNode(0)
    curr = dummy
    for abs_val in sorted_abs:
        sign = math.copysign(1, head.val)  # Determine the original sign
        new_node = ListNode(abs_val * sign)
        curr.next = new_node
        curr = curr.next

    return dummy.next
```

#### C++
```cpp
ListNode* absoluteListSorting(ListNode* head) {
    if (head == nullptr) return nullptr;

    // Step 1: Extract and store absolute values
    vector<int> sortedAbs;
    while (head != nullptr) {
        int absVal = labs(head->val);
        sortedAbs.push_back(absVal);
        head = head->next;
    }

    // Step 2: Sort the array of absolute values
    sort(sortedAbs.begin(), sortedAbs.end());

    // Step 3: Reconstruct the linked list in the correct order
    ListNode* dummy = new ListNode(0);
    ListNode* curr = dummy;
    for (int absVal : sortedAbs) {
        int sign = (head->val > 0) ? 1 : ((head->val < 0) ? -1 : 0); // Determine the original sign
        ListNode* newNode = new ListNode(absVal * sign);
        curr->next = newNode;
        curr = curr->next;
    }

    return dummy->next;
}
```

#### JavaScript
```javascript
function absoluteListSorting(head) {
    if (head === null) return null;

    // Step 1: Extract and store absolute values
    const sortedAbs = [];
    let current = head;
    while (current !== null) {
        const absVal = Math.abs(current.val);
        sortedAbs.push(absVal);
        current = current.next;
    }

    // Step 2: Sort the array of absolute values
    sortedAbs.sort((a, b) => a - b);

    // Step 3: Reconstruct the linked list in the correct order
    const dummy = { val: 0, next: null };
    let curr = dummy;
    for (const absVal of sortedAbs) {
        const sign = Math.sign(head.val); // Determine the original sign
        const newNode = { val: absVal * sign, next: null };
        curr.next = newNode;
        curr = curr.next;
    }

    return dummy.next;
}
```

Note that these optimized solutions have a time complexity of O(n log n) due to sorting and a space complexity of O(n) for storing the absolute values.