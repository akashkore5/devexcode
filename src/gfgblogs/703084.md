---
id: "703084"
title: "Quick Left Rotation"
slug: "quick-left-rotation3806"
difficulty: "Basic"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

**Quick Left Rotation**
=====================

**Slug:** quick-left-rotation3806
**Difficulty:** Basic
**Id:** 703084
**Topic Tags:** Arrays, Data Structures
**Company Tags:** None

## Summary
Given an array of integers and a rotation value `k`, perform a left rotation on the array by `k` positions. This means that elements at indices `0` to `k-1` should be shifted to the end of the array.

## Detailed Explanation
The problem can be solved using a straightforward algorithmic approach. We will create a new array with the same length as the input array and then populate it with the rotated elements.

Here's the step-by-step breakdown:

1. Create an empty array `result` with the same length as the input array.
2. Iterate from index `k` to the end of the input array, inclusive. For each element at index `i`, place it at the beginning of the `result` array (at index `(i-k)%n`, where `n` is the length of the input array).
3. Copy the remaining elements from the input array (from index 0 to `k-1`) to the end of the `result` array.

Here's an ASCII art diagram illustrating the rotation:
```
Input: [1, 2, 3, 4, 5]
Rotation: 2
Result: [3, 4, 5, 1, 2]
```

Time complexity analysis:

* The algorithm iterates through the input array once, so the time complexity is O(n), where `n` is the length of the input array.

Space complexity analysis:

* We create a new array to store the rotated elements, which has the same length as the input array. Therefore, the space complexity is O(n).

## Optimized Solutions

### Java
```java
public int[] quickLeftRotation(int[] arr, int k) {
    int n = arr.length;
    int[] result = new int[n];
    for (int i = k; i < n; i++) {
        result[(i-k)%n] = arr[i];
    }
    for (int i = 0; i < k; i++) {
        result[i] = arr[n-i-1];
    }
    return result;
}
```

### Python
```python
def quick_left_rotation(arr, k):
    n = len(arr)
    result = [0]*n
    for i in range(k, n):
        result[(i-k)%n] = arr[i]
    for i in range(n-k):
        result[i] = arr[n-i-1]
    return result
```

### C++
```cpp
int* quickLeftRotation(int* arr, int k, int n) {
    int* result = new int[n];
    for (int i = k; i < n; i++) {
        result[(i-k)%n] = arr[i];
    }
    for (int i = 0; i < k; i++) {
        result[i] = arr[n-i-1];
    }
    return result;
}
```

### JavaScript
```javascript
function quickLeftRotation(arr, k) {
    let n = arr.length;
    let result = new Array(n);
    for (let i = k; i < n; i++) {
        result[(i-k)%n] = arr[i];
    }
    for (let i = 0; i < k; i++) {
        result[i] = arr[n-i-1];
    }
    return result;
}
```

Note: In the optimized solutions, we use a single loop to iterate through the input array and another loop to copy the remaining elements. This reduces the number of iterations and improves the performance.