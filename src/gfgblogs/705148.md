---
id: "705148"
title: "Pairs of Adjacent elements"
slug: "pairs-of-adjacent-elements4814"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

Pairs of Adjacent Elements
=====================

Slug: pairs-of-adjacent-elements4814
Difficulty: Easy
Id: 705148
Topic Tags: Arrays, Data Structures
Company Tags: None

## Summary
Given an array of integers, find all pairs of adjacent elements that have a difference of less than or equal to 1. The problem is related to arrays and data structures.

## Detailed Explanation
To solve this problem, we can iterate through the array once and keep track of the previous element's value. For each element in the array, check if its difference with the previous element is less than or equal to 1. If it is, add the pair to our result list. Since we're iterating only once and checking adjacent elements, this approach has a linear time complexity.

Here's the step-by-step breakdown of the solution:

1. Initialize an empty list `result` to store the pairs of adjacent elements.
2. Iterate through the array from left to right.
3. For each element at index `i`, calculate its difference with the previous element at index `i-1`.
4. If the difference is less than or equal to 1, add the pair `(arr[i], arr[i-1])` to the `result` list.
5. Continue this process until the end of the array.

Time complexity: O(n), where n is the length of the input array.

Space complexity: O(n), as we're storing all pairs in the result list.

## Optimized Solutions

### Java
```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static List<int[]> findPairs(int[] arr) {
        List<int[]> result = new ArrayList<>();
        for (int i = 1; i < arr.length; i++) {
            if (Math.abs(arr[i] - arr[i-1]) <= 1) {
                result.add(new int[]{arr[i], arr[i-1]});
            }
        }
        return result;
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4};
        List<int[]> pairs = findPairs(arr);
        for (int[] pair : pairs) {
            System.out.println("[" + pair[0] + ", " + pair[1] + "]");
        }
    }
}
```

### Python
```python
def find_pairs(arr):
    result = []
    for i in range(1, len(arr)):
        if abs(arr[i] - arr[i-1]) <= 1:
            result.append([arr[i], arr[i-1]])
    return result

arr = [1, 2, 3, 4]
pairs = find_pairs(arr)
for pair in pairs:
    print("[" + str(pair[0]) + ", " + str(pair[1]) + "]")
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<std::pair<int, int>> findPairs(int arr[], int n) {
    std::vector<std::pair<int, int>> result;
    for (int i = 1; i < n; i++) {
        if (abs(arr[i] - arr[i-1]) <= 1) {
            result.push_back({arr[i], arr[i-1]});
        }
    }
    return result;
}

int main() {
    int arr[] = {1, 2, 3, 4};
    int n = sizeof(arr)/sizeof(arr[0]);
    std::vector<std::pair<int, int>> pairs = findPairs(arr, n);
    for (const auto& pair : pairs) {
        std::cout << "[" << pair.first << ", " << pair.second << "]" << std::endl;
    }
    return 0;
}
```

### JavaScript
```javascript
function findPairs(arr) {
    let result = [];
    for (let i = 1; i < arr.length; i++) {
        if (Math.abs(arr[i] - arr[i-1]) <= 1) {
            result.push([arr[i], arr[i-1]]);
        }
    }
    return result;
}

let arr = [1, 2, 3, 4];
let pairs = findPairs(arr);
for (const pair of pairs) {
    console.log(`[${pair[0]}, ${pair[1]}]`);
}
```

Each optimized solution is a simple modification of the basic algorithm, using language-specific constructs to implement the same logic.