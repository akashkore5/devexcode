---
id: "709857"
title: "Maximum number of events that can be attended"
slug: "maximum-number-of-events-that-can-be-attended--170636"
difficulty: "Medium"
companyTags: ["Adobe"]
tags: ["Greedy", "Sorting", "Heap", "Data Structures", "Algorithms"]
---

**Maximum Number of Events that can be Attended**
=====================================================

## Summary
The problem is about finding the maximum number of events that can be attended given a set of event times and a list of availability intervals. The key concepts involved are greedy algorithms, sorting, and heap data structures.

## Detailed Explanation
The problem statement is as follows: We have a list of event times and a list of availability intervals. For each availability interval, we know the start time and end time. Our goal is to find the maximum number of events that can be attended such that no two overlapping events are attended simultaneously.

To solve this problem, we can use a greedy algorithm. First, sort all the events by their start times. Then, iterate over the sorted list of events. For each event, check if it overlaps with any previously selected event. If it does not overlap, select it and update the maximum number of events that can be attended.

Here's a step-by-step breakdown of the solution:

1. Sort all the events by their start times.
2. Initialize a variable `max_events` to 0, which will store the maximum number of events that can be attended.
3. Iterate over the sorted list of events.
4. For each event, check if it overlaps with any previously selected event. If it does not overlap, select it and increment `max_events`.
5. Return `max_events`.

Time complexity: O(n log n) due to sorting
Space complexity: O(1)

## Optimized Solutions

### Java
```java
import java.util.Arrays;
import java.util.Comparator;

public class MaximumEvents {
    public static int maxEvents(int[][] events) {
        Arrays.sort(events, Comparator.comparingInt(a -> a[0]));
        int max_events = 0;
        for (int[] event : events) {
            if (!overlaps(event, previousEvent)) {
                max_events++;
                previousEvent = event;
            }
        }
        return max_events;
    }

    private static int[] previousEvent = null;

    private static boolean overlaps(int[] event, int[] previousEvent) {
        return event[0] < previousEvent[1];
    }
}
```

### Python
```python
def max_events(events):
    events.sort(key=lambda x: x[0])
    max_events = 0
    for event in events:
        if not overlaps(event, previous_event):
            max_events += 1
            previous_event = event
    return max_events

def overlaps(event, previous_event):
    return event[0] < previous_event[1]

previous_event = None
```

### C++
```cpp
#include <algorithm>
#include <vector>

int maxEvents(std::vector<std::pair<int, int>>& events) {
    std::sort(events.begin(), events.end());
    int max_events = 0;
    for (auto& event : events) {
        if (!overlaps(event, previousEvent)) {
            max_events++;
            previousEvent = event;
        }
    }
    return max_events;

bool overlaps(const std::pair<int, int>& event, const std::pair<int, int>& previousEvent) {
    return event.first < previousEvent.second;
}

int main() {
    // Example usage
    std::vector<std::pair<int, int>> events = {{1, 3}, {2, 4}, {5, 6}};
    std::cout << maxEvents(events) << std::endl;
    return 0;
}
```

### JavaScript
```javascript
function maxEvents(events) {
    events.sort((a, b) => a[0] - b[0]);
    let max_events = 0;
    for (const event of events) {
        if (!overlaps(event, previousEvent)) {
            max_events++;
            previousEvent = event;
        }
    }
    return max_events;

function overlaps(event, previousEvent) {
    return event[0] < previousEvent[1];
}

let previousEvent = null;
```

Note that the above solutions are optimized for the given problem statement. The actual implementation may vary based on the specific requirements and constraints of the problem.