---
id: "880379"
title: "Group Shifted String"
slug: "group-shifted-string"
difficulty: "Medium"
companyTags: ["Google"]
tags: ["Strings", "Hash", "Algorithms"]
---

**Group Shifted String**
=====================

**Slug:** group-shifted-string
**Difficulty:** Medium
**Id:** 880379
**Topic Tags:** Strings, Hash, Algorithms
**Company Tags:** Google

## Summary
Given a string `s` and an integer `k`, the problem is to divide the string into groups of size `k+1`, such that each group contains all shifted versions of the same substring. For example, if `s = "awdabnamowl"` and `k = 4`, the output should be `[["a", "w", "d", "ab"], ["n", "am", "ow", "l"]]`. The key concepts involved are strings, hashing, and algorithms.

## Detailed Explanation
The problem can be solved by using a hashmap to store the frequency of each substring. We first generate all substrings of length `k+1` from the input string `s`. Then, for each substring, we calculate its shifted versions (by shifting each character by 1 position) and increment their frequencies in the hashmap. Finally, we iterate over the hashmap and group the substrings based on their frequencies.

Here is a step-by-step breakdown of the solution:

1. Generate all substrings of length `k+1` from the input string `s`.
2. For each substring, calculate its shifted versions (by shifting each character by 1 position).
3. Increment the frequency of each shifted version in a hashmap.
4. Iterate over the hashmap and group the substrings based on their frequencies.

The time complexity of this solution is O(n), where n is the length of the input string `s`. This is because we need to generate all substrings, which takes O(n) time. The space complexity is also O(n), as we need to store the frequency of each substring in the hashmap.

```
                +---------------+
                |  Input String  |
                +---------------+
                        |
                        v
                +---------------+
                |  Generate Substrings  |
                +---------------+
                        |
                        v
                +---------------+
                |  Calculate Shifted Versions  |
                +---------------+
                        |
                        v
                +---------------+
                |  Increment Frequency in Hashmap  |
                +---------------+
                        |
                        v
                +---------------+
                |  Group Substrings based on Frequencies  |
                +---------------+
```

## Optimized Solutions

### Java
```java
import java.util.HashMap;
import java.util.Map;

public class GroupShiftedString {
    public static String[] groupStrings(String s, int k) {
        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i <= s.length() - k - 1; i++) {
            String substring = s.substring(i, i + k + 1);
            for (int j = 0; j < k + 1; j++) {
                String shiftedSubstring = substring.substring(1) + substring.charAt(0);
                map.put(shiftedSubstring, map.getOrDefault(shiftedSubstring, 0) + 1);
            }
        }
        String[] result = new String[map.size()];
        int index = 0;
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            while (entry.getValue() > 0) {
                for (int j = 0; j < k + 1; j++) {
                    result[index++] = substring.substring(0, j + 1);
                    substring = substring.substring(1);
                }
                entry.setValue(entry.getValue() - 1);
            }
        }
        return result;
    }
}
```

### Python
```python
def group_strings(s, k):
    map = {}
    for i in range(len(s) - k - 1):
        substring = s[i:i+k+1]
        for j in range(k+1):
            shifted_substring = substring[1:] + substring[0]
            map[shifted_substring] = map.get(shifted_substring, 0) + 1
    result = [None] * len(map)
    index = 0
    for entry in map.items():
        while entry[1] > 0:
            for j in range(k+1):
                result[index] = substring[:j+1]
                substring = substring[1:]
            entry[1] -= 1
        index += 1
    return result
```

### C++
```cpp
#include <unordered_map>
#include <string>

std::vector<std::string> groupStrings(const std::string& s, int k) {
    std::unordered_map<std::string, int> map;
    for (int i = 0; i <= s.length() - k - 1; i++) {
        std::string substring = s.substr(i, k + 1);
        for (int j = 0; j < k + 1; j++) {
            std::string shiftedSubstring = substring.substr(1) + substring[0];
            map[shiftedSubstring]++;
        }
    }
    std::vector<std::string> result(map.size());
    int index = 0;
    for (const auto& entry : map) {
        while (entry.second > 0) {
            for (int j = 0; j < k + 1; j++) {
                result[index++] = substring.substr(0, j + 1);
                substring = substring.substr(1);
            }
            entry.second--;
        }
    }
    return result;
}
```

### JavaScript
```javascript
function groupStrings(s, k) {
    const map = new Map();
    for (let i = 0; i <= s.length - k - 1; i++) {
        let substring = s.slice(i, i + k + 1);
        for (let j = 0; j < k + 1; j++) {
            let shiftedSubstring = substring.substring(1) + substring[0];
            map.set(shiftedSubstring, (map.get(shiftedSubstring) || 0) + 1);
        }
    }
    const result = Array.from(map.entries()).map(([key, value]) => {
        let str = '';
        for (let j = 0; j < k + 1; j++) {
            str += key.substring(0, j + 1);
            key = key.substring(1);
        }
        return str;
    });
    return result;
}
```

Note that the optimized solutions are in different programming languages.