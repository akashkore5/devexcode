---
id: "885632"
title: "Meeting Rooms III"
slug: "meeting-rooms-iii"
difficulty: "Hard"
companyTags: []
tags: ["Heap", "Data Structures", "priority-queue"]
---

Here is a detailed Markdown blog post for the "Meeting Rooms III" problem:

# Meeting Rooms III
## Summary
Given a list of meeting start and end times, find all possible intervals that represent available time slots. The meeting rooms are initially empty, and each room can be used by only one person at a time. The goal is to maximize the usage of each room.

This problem involves using priority queues (heap) to efficiently manage the meetings and free time slots in each room.

## Detailed Explanation
To solve this problem, we will use a priority queue (min-heap) to keep track of the end times of meetings in each room. We initialize an empty list `rooms` to store the available time slots for each room.

We iterate through the given meeting start and end times. For each meeting, we find the first available room that can accommodate this meeting by popping the earliest end time from the priority queue (heap). If no rooms are available, we add a new room with an empty schedule.

Once a meeting is assigned to a room, we update the end time of that room in the priority queue. This ensures that all subsequent meetings will be scheduled in the order of their start times.

Finally, we iterate through the priority queue and add each room's schedule (available time slots) to our result list `rooms`.

Here is a step-by-step breakdown of the solution:

1. Initialize an empty list `rooms` to store the available time slots for each room.
2. Iterate through the given meeting start and end times.
3. For each meeting, find the first available room that can accommodate this meeting by popping the earliest end time from the priority queue (heap).
4. If no rooms are available, add a new room with an empty schedule.
5. Once a meeting is assigned to a room, update the end time of that room in the priority queue.
6. Iterate through the priority queue and add each room's schedule (available time slots) to our result list `rooms`.

Time complexity: O(n log n), where n is the number of meetings.

Space complexity: O(m), where m is the maximum number of rooms that can be used simultaneously.

## Optimized Solutions

### Java
```java
import java.util.*;
public class MeetingRoomsIII {
    public List<List<Integer>> available_time_slots(int[][] intervals) {
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        List<List<Integer>> rooms = new ArrayList<>();
        for (int[] interval : intervals) {
            while (!pq.isEmpty() && pq.peek()[1] <= interval[0]) {
                pq.poll();
            }
            if (pq.isEmpty()) {
                rooms.add(Arrays.asList(interval));
            } else {
                rooms.add(pq.poll());
                rooms.set(rooms.size() - 1, Arrays.asList(interval));
            }
        }
        return rooms;
    }
}
```

### Python
```python
import heapq

def available_time_slots(intervals):
    pq = []
    rooms = []
    for start, end in intervals:
        while pq and pq[0][1] <= start:
            heapq.heappop(pq)
        if not pq:
            rooms.append([start, end])
        else:
            rooms.append(heapq.heappop(pq))
            rooms[-1] = [start, end]
    return rooms
```

### C++
```cpp
#include <queue>
#include <vector>

std::vector<std::vector<int>> availableTimeSlots(std::vector<std::vector<int>>& intervals) {
    std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<>> pq;
    std::vector<std::vector<int>> rooms;
    for (const auto& interval : intervals) {
        while (!pq.empty() && pq.top()[1] <= interval[0]) {
            pq.pop();
        }
        if (pq.empty()) {
            rooms.push_back(interval);
        } else {
            rooms.push_back(pq.top());
            pq.pop();
            rooms.back() = interval;
        }
    }
    return rooms;
}
```

### JavaScript
```javascript
function availableTimeSlots(intervals) {
  const pq = [];
  const rooms = [];
  for (const [start, end] of intervals) {
    while (pq.length && pq[0][1] <= start) {
      pq.shift();
    }
    if (!pq.length) {
      rooms.push([start, end]);
    } else {
      rooms.push(pq.shift());
      rooms[rooms.length - 1] = [start, end];
    }
  }
  return rooms;
}
```

Note: The code blocks are surrounded by `backticks ( )` to indicate that they contain Markdown code.