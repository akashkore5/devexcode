---
id: "711146"
title: "City With the Smallest Number of Neighbors at a Threshold Distance"
slug: "city-with-the-smallest-number-of-neighbors-at-a-threshold-distance"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "Shortest Path", "BFS", "Disjoint Set", "Data Structures", "Algorithms"]
---

# City With the Smallest Number of Neighbors at a Threshold Distance

## Summary
This problem involves finding the city with the smallest number of neighbors within a certain threshold distance. The problem can be approached using graph algorithms, specifically BFS and disjoint sets.

## Detailed Explanation
The given problem description is not available, but based on the tags, we can assume it's a graph-based problem. To solve this problem, we will use Breadth-First Search (BFS) to traverse the graph and keep track of the number of neighbors for each city at a certain threshold distance.

Here's the step-by-step approach:

1. Create an adjacency list representation of the graph, where each node represents a city and its edges represent the distances between cities.
2. Initialize a set to store the visited cities and another set to store the disjoint sets (for union-find operations).
3. Start BFS from each unvisited city. For each city, calculate the number of neighbors within the threshold distance using DFS or BFS.
4. Keep track of the city with the smallest number of neighbors at the threshold distance.
5. Perform union operations on the disjoint sets to find the connected components in the graph.

Here's a step-by-step breakdown:

```
          A
         / \
        B   C
       / \   \
      D   E   F

Threshold Distance: 2
```

In this example, we start BFS from city A. We visit cities B and C and calculate their neighbors within the threshold distance (2). For city B, its neighbors are D and E, while for city C, it's only F.

We continue BFS and union-find operations to find connected components in the graph. Finally, we return the city with the smallest number of neighbors at the threshold distance.

Time complexity: O(E + V), where E is the number of edges and V is the number of vertices.
Space complexity: O(V), for storing the visited set, disjoint sets, and adjacency list representation.

## Optimized Solutions

### Java
```java
import java.util.*;

public class CityWithSmallestNeighbors {
    public static String findCity(int[][] distances) {
        int minNeighbors = Integer.MAX_VALUE;
        String city = null;

        for (int i = 0; i < distances.length; i++) {
            int neighbors = 0;
            boolean[] visited = new boolean[distances.length];

            Queue<Integer> queue = new LinkedList<>();
            queue.add(i);

            while (!queue.isEmpty()) {
                int currentCity = queue.poll();
                if (visited[currentCity]) continue;

                visited[currentCity] = true;

                for (int j = 0; j < distances.length; j++) {
                    if (distances[currentCity][j] <= 2 && !visited[j]) {
                        neighbors++;
                        queue.add(j);
                    }
                }
            }

            if (neighbors < minNeighbors) {
                minNeighbors = neighbors;
                city = String.valueOf(i);
            }
        }

        return city;
    }
}
```

### Python
```python
def find_city(distances):
    min_neighbors = float('inf')
    city = None

    for i in range(len(distances)):
        neighbors = 0
        visited = [False] * len(distances)
        queue = collections.deque()

        queue.append(i)

        while queue:
            current_city = queue.popleft()
            if visited[current_city]: continue

            visited[current_city] = True

            for j in range(len(distances)):
                if distances[current_city][j] <= 2 and not visited[j]:
                    neighbors += 1
                    queue.append(j)
        if neighbors < min_neighbors:
            min_neighbors = neighbors
            city = str(i)

    return city
```

### C++
```cpp
#include <iostream>
#include <queue>
#include <vector>

std::string findCity(int** distances, int size) {
    int minNeighbors = INT_MAX;
    std::string city;

    for (int i = 0; i < size; i++) {
        int neighbors = 0;
        bool visited[size] = {false};

        std::queue<int> queue;
        queue.push(i);

        while (!queue.empty()) {
            int currentCity = queue.front();
            queue.pop();

            if (visited[currentCity]) continue;

            visited[currentCity] = true;

            for (int j = 0; j < size; j++) {
                if (distances[currentCity][j] <= 2 && !visited[j]) {
                    neighbors++;
                    queue.push(j);
                }
            }
        }

        if (neighbors < minNeighbors) {
            minNeighbors = neighbors;
            city = std::to_string(i);
        }
    }

    return city;
}
```

### JavaScript
```javascript
function findCity(distances) {
    let minNeighbors = Infinity;
    let city;

    for (let i = 0; i < distances.length; i++) {
        let neighbors = 0;
        const visited = new Array(distances.length).fill(false);
        const queue = [];

        queue.push(i);

        while (queue.length) {
            const currentCity = queue.shift();
            if (visited[currentCity]) continue;

            visited[currentCity] = true;

            for (let j = 0; j < distances.length; j++) {
                if (distances[currentCity][j] <= 2 && !visited[j]) {
                    neighbors++;
                    queue.push(j);
                }
            }
        }

        if (neighbors < minNeighbors) {
            minNeighbors = neighbors;
            city = i.toString();
        }
    }

    return city;
}
```

Note: The above solutions assume that the input graph is represented as an adjacency list, where each node represents a city and its edges represent the distances between cities.