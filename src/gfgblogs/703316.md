---
id: "703316"
title: "Number of pairs"
slug: "number-of-pairs3422"
difficulty: "Medium"
companyTags: ["FactSet"]
tags: ["Arrays", "Sorting", "Data Structures", "Algorithms"]
---

Here is a detailed Markdown blog post for the problem:

# Number of Pairs3422

## Summary

This problem involves counting the number of pairs in an array where each pair consists of two distinct elements that sum up to a given target value. The tags include "Arrays", "Sorting", and "Data Structures" which suggests that we need to find all possible pairs in an array that satisfy certain conditions.

## Detailed Explanation

The problem is asking us to count the number of pairs in an array where each pair consists of two distinct elements that sum up to a given target value. For example, if the array is `[1, 2, 3, 4, 5]` and the target value is `7`, then the pairs are `(2, 5)` and `(3, 4)`. We need to find all such pairs in the array.

One approach to solve this problem is by sorting the array first. This is because we can use two pointers technique to find all possible pairs that sum up to the target value. Here's how it works:

1. Sort the array in ascending order.
2. Initialize two pointers, `left` and `right`, to the start and end of the array respectively.
3. Calculate the sum of the elements at the `left` and `right` indices.
4. If the sum is equal to the target value, then we found a pair `(arr[left], arr[right])`. Increment both pointers and continue until the sum is no longer equal to the target value.
5. Repeat steps 3-4 until the `left` pointer meets the `right` pointer.

This algorithm has a time complexity of O(n log n) due to the sorting step, where n is the size of the array. The space complexity is O(1) as we only need a constant amount of space to store the pointers and the sum.

Here's an ASCII art diagram to illustrate the two-pointer technique:
```
  +--------+       +--------+
  |  arr[0]  |       |  arr[n-1]  |
  +--------+       +--------+
           |               |
           |  left          |
           v               |
  +--------+       +--------+
  |  arr[i]   |       |  arr[j]    |
  +--------+       +--------+
           |               |
           |  right         |
           v               |
```
## Optimized Solutions

### Java
```java
public int countPairs(int[] arr, int target) {
    Arrays.sort(arr);
    int count = 0;
    int left = 0;
    int right = arr.length - 1;
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum == target) {
            count++;
            left++;
            right--;
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    return count;
}
```

### Python
```python
def count_pairs(arr, target):
    arr.sort()
    count = 0
    left = 0
    right = len(arr) - 1
    while left < right:
        sum = arr[left] + arr[right]
        if sum == target:
            count += 1
            left += 1
            right -= 1
        elif sum < target:
            left += 1
        else:
            right -= 1
    return count
```

### C++
```cpp
int countPairs(int* arr, int n, int target) {
    sort(arr, arr+n);
    int count = 0;
    int left = 0;
    int right = n-1;
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum == target) {
            count++;
            left++;
            right--;
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    return count;
}
```

### JavaScript
```javascript
function countPairs(arr, target) {
    arr.sort((a, b) => a - b);
    let count = 0;
    let left = 0;
    let right = arr.length - 1;
    while (left < right) {
        let sum = arr[left] + arr[right];
        if (sum === target) {
            count++;
            left++;
            right--;
        } else if (sum < target) {
            left++;
        } else {
            right--;
        }
    }
    return count;
}
```

Note that the optimized solutions are just examples and may not be the most efficient or practical solution for a real-world problem.