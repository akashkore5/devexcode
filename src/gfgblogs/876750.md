---
id: "876750"
title: "Find pair with sum target in an absolute sorted array"
slug: "find-pair-with-sum-k-in-an-absolute-sorted-array"
difficulty: "Medium"
companyTags: []
tags: ["Sorting", "two-pointer-algorithm", "Arrays", "Hash"]
---

# Find pair with sum target in an absolute sorted array

## Summary
Given a sorted array and a target sum, find all pairs of elements that add up to the target sum. The array is sorted by absolute value, meaning that both positive and negative numbers are present and sorted based on their absolute values.

This problem involves using the two-pointer algorithm, which is commonly used in problems involving arrays or linked lists. We will use this approach to efficiently find all pairs of elements that add up to the target sum.

## Detailed Explanation
To solve this problem, we can start by initializing two pointers, one at the beginning and one at the end of the array. Then, we check if the sum of the values at these two positions is equal to the target sum. If it is, we have found a pair that adds up to the target sum.

If the sum is less than the target sum, we move the left pointer to the right, as increasing the value at this position will increase the sum. If the sum is greater than the target sum, we move the right pointer to the left, as decreasing the value at this position will decrease the sum.

We continue moving the pointers until they meet or cross each other. When they do, it means that all possible pairs have been checked and no more pairs can be found that add up to the target sum.

Here is a step-by-step breakdown of the solution:

1. Initialize two pointers, `left` and `right`, to the beginning and end of the array respectively.
2. Calculate the sum of the values at the positions pointed by `left` and `right`.
3. If the sum is equal to the target sum, add this pair to our result set.
4. If the sum is less than the target sum, move the `left` pointer to the right.
5. If the sum is greater than the target sum, move the `right` pointer to the left.
6. Repeat steps 2-5 until `left` and `right` meet or cross each other.

The time complexity of this algorithm is O(n), where n is the size of the array. This is because we are moving two pointers from both ends towards each other, effectively dividing the array into two halves in each iteration. The space complexity is O(1), as we only need a constant amount of space to store our result set.

## Optimized Solutions

### Java
```java
public class Solution {
    public List<List<Integer>> findPairs(int[] nums, int k) {
        List<List<Integer>> result = new ArrayList<>();
        int left = 0;
        int right = nums.length - 1;
        
        while (left < right) {
            int sum = Math.abs(nums[left]) + Math.abs(nums[right]);
            
            if (sum == k) {
                result.add(Arrays.asList(Math.min(nums[left], nums[right]), Math.max(nums[left], nums[right])));
                left++;
                right--;
            } else if (sum < k) {
                left++;
            } else {
                right--;
            }
        }
        
        return result;
    }
}
```

### Python
```python
class Solution:
    def findPairs(self, nums: List[int], k: int) -> List[List[int]]:
        result = []
        left, right = 0, len(nums) - 1
        
        while left < right:
            sum = abs(nums[left]) + abs(nums[right])
            
            if sum == k:
                result.append([min(nums[left], nums[right]), max(nums[left], nums[right])])
                left += 1
                right -= 1
            elif sum < k:
                left += 1
            else:
                right -= 1
        
        return result
```

### C++
```cpp
class Solution {
public:
    vector<vector<int>> findPairs(vector<int>& nums, int k) {
        vector<vector<int>> result;
        int left = 0;
        int right = nums.size() - 1;
        
        while (left < right) {
            int sum = abs(nums[left]) + abs(nums[right]);
            
            if (sum == k) {
                result.push_back({min(nums[left], nums[right]), max(nums[left], nums[right])});
                left++;
                right--;
            } else if (sum < k) {
                left++;
            } else {
                right--;
            }
        }
        
        return result;
    }
};
```

### JavaScript
```javascript
class Solution {
  findPairs(nums, k) {
    const result = [];
    let left = 0;
    let right = nums.length - 1;
    
    while (left < right) {
      const sum = Math.abs(nums[left]) + Math.abs(nums[right]);
      
      if (sum === k) {
        result.push([Math.min(nums[left], nums[right]), Math.max(nums[left], nums[right])]);
        left++;
        right--;
      } else if (sum < k) {
        left++;
      } else {
        right--;
      }
    }
    
    return result;
  }
}
```

I hope this helps! Let me know if you have any questions or need further clarification.