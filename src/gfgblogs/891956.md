---
id: "891956"
title: "Largest palindrome by changing at most K-digits"
slug: "largest-palindrome-by-changing-at-most-k-digits"
difficulty: "Easy"
companyTags: []
tags: []
---

# Largest palindrome by changing at most K-digits
## Summary
Given a non-negative integer `num` and an integer `k`, find the largest palindromic number that can be obtained by changing at most `k` digits in the given number. A palindromic number is a number that remains the same when its digits are reversed.

## Detailed Explanation
To solve this problem, we will iterate through all possible combinations of changing up to `k` digits in the given number and check if each combination results in a palindrome. We can use a recursive approach for this. 

Here's a step-by-step breakdown of the solution:

1. Initialize the maximum palindromic number as the given number.
2. For each digit position from right to left (i.e., from least significant to most significant):
   - If `k` is greater than 0, change the current digit to all possible values (0-9) and recursively check if any of these combinations result in a palindrome.
     - If a larger palindromic number is found, update the maximum palindromic number.
3. Return the maximum palindromic number.

Time complexity: O(10^k * n), where `n` is the number of digits in the given number and `k` is the number of allowed changes. This is because we are iterating through all possible combinations of changing up to `k` digits.

Space complexity: O(n), as we need to store the current number and the maximum palindromic number at each recursive step.

## Optimized Solutions
### Java
```java
public class Solution {
    public int largestPalindrome(int n) {
        long num = (long) Math.pow(10, n) - 1;
        for (int i = n - 1; i >= 0; i--) {
            if (k > 0 && i < n - 1) {
                for (int j = 0; j <= 9; j++) {
                    num = num / 10 + j;
                    if (isPalindrome(num)) return (int) (num);
                    num = (long) Math.pow(10, n) - 1;
                }
            } else {
                if (isPalindrome(num)) return (int) (num);
            }
        }
        return -1;
    }

    public boolean isPalindrome(long num) {
        long rev = 0, temp = num;
        while (temp > 0) {
            rev = rev * 10 + temp % 10;
            temp /= 10;
        }
        return num == rev;
    }
}
```

### Python
```python
class Solution:
    def largestPalindrome(self, n: int) -> int:
        max_palindrome = (10 ** n - 1).astype(int)
        for i in range(n - 1, -1, -1):
            if k > 0 and i < n - 1:
                for j in range(10):
                    max_palindrome //= 10 + j
                    if self.is_palindrome(max_palindrome): return int(max_palindrome)
                    max_palindrome = (10 ** n - 1).astype(int)
            else:
                if self.is_palindrome(max_palindrome): return int(max_palindrome)

    def is_palindrome(self, num: int) -> bool:
        rev = 0
        temp = num
        while temp > 0:
            rev = (rev * 10 + temp % 10)
            temp //= 10
        return num == rev
```

### C++
```cpp
class Solution {
public:
    int largestPalindrome(int n) {
        long long max_palindrome = (long long)pow(10, n) - 1;
        for (int i = n - 1; i >= 0; i--) {
            if (k > 0 && i < n - 1) {
                for (int j = 0; j <= 9; j++) {
                    max_palindrome = max_palindrome / 10 + j;
                    if (isPalindrome(max_palindrome)) return (int)(max_palindrome);
                    max_palindrome = (long long)pow(10, n) - 1;
                }
            } else {
                if (isPalindrome(max_palindrome)) return (int)(max_palindrome);
            }
        }
        return -1;
    }

    bool isPalindrome(long long num) {
        long long rev = 0, temp = num;
        while (temp > 0) {
            rev = rev * 10 + temp % 10;
            temp /= 10;
        }
        return num == rev;
    }
};
```

### JavaScript
```javascript
class Solution {
    largestPalindrome(n, k) {
        let max_palindrome = Math.pow(10, n) - 1;
        for (let i = n - 1; i >= 0; i--) {
            if (k > 0 && i < n - 1) {
                for (let j = 0; j <= 9; j++) {
                    max_palindrome = Math.floor(max_palindrome / 10) + j;
                    if (this.isPalindrome(max_palindrome)) return parseInt(max_palindrome);
                    max_palindrome = Math.pow(10, n) - 1;
                }
            } else {
                if (this.isPalindrome(max_palindrome)) return parseInt(max_palindrome);
            }
        }
        return -1;
    }

    isPalindrome(num) {
        let rev = 0, temp = num;
        while (temp > 0) {
            rev = Math.floor(rev * 10 + temp % 10);
            temp /= 10;
        }
        return num === rev;
    }
};
```