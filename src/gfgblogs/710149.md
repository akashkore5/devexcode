---
id: "710149"
title: "Special Keyboard 2"
slug: "special-keyboard-2"
difficulty: "Medium"
companyTags: []
tags: ["Strings", "Data Structures"]
---

**Special Keyboard 2**
=====================

**Slug:** special-keyboard-2
**Difficulty:** Medium
**Id:** 710149
**Topic Tags:** Strings, Data Structures
**Company Tags:** None

## Summary
The Special Keyboard 2 problem involves a keyboard with a unique character set. The goal is to find the minimum number of presses required to type out all possible strings using this special keyboard.

Given a string `str` representing the special keyboard's character set and another string `target` representing the target string, return the minimum number of presses needed to type out the target string using the special keyboard. Each character in the target string can be replaced by any character in the special keyboard that is lexicographically smaller (i.e., alphabetically before).

## Detailed Explanation
To solve this problem, we can use a dynamic programming approach. We will create a 2D array `dp` where `dp[i][j]` represents the minimum number of presses required to type out the first `i` characters of the target string using the special keyboard.

Here's a step-by-step breakdown of the solution:

1. Initialize the `dp` array with a size of `(target.length + 1) x (str.length + 1)` and set all elements to infinity.
2. Set `dp[0][j] = j` for all `j`, because we need one press for each character in the special keyboard to type out an empty target string.
3. Iterate through the target string from left to right:
	* For each character `t` in the target string, iterate through the special keyboard from left to right:
		+ For each character `s` in the special keyboard, calculate the minimum number of presses required to type out the first `i` characters of the target string using the special keyboard that replaces the current character `t` with `s`.
		+ Update `dp[i][j] = min(dp[i][j], dp[i-1][k] + 1)` where `k` is the index of the smallest character in the special keyboard that is lexicographically smaller than `t`.
4. Return `dp[target.length][0]`, which represents the minimum number of presses required to type out the entire target string using the special keyboard.

Time complexity: O(target.length * str.length)
Space complexity: O(target.length * str.length)

## Optimized Solutions

### Java
```java
int minPresses(String str, String target) {
    int[][] dp = new int[target.length + 1][str.length + 1];
    for (int i = 0; i <= target.length; i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= str.length; j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= target.length; i++) {
        char t = target.charAt(i - 1);
        for (int j = 1; j <= str.length; j++) {
            char s = str.charAt(j - 1);
            if (t >= s) {
                dp[i][j] = dp[i - 1][j] + 1;
            } else {
                int minPresses = Integer.MAX_VALUE;
                for (int k = 0; k < j; k++) {
                    if (s <= str.charAt(k)) {
                        minPresses = Math.min(minPresses, dp[i - 1][k] + 1);
                    }
                }
                dp[i][j] = minPresses;
            }
        }
    }
    return dp[target.length][0];
}
```

### Python
```python
def min_presses(str, target):
    dp = [[float('inf')] * (len(str) + 1) for _ in range(len(target) + 1)]
    for i in range(len(target) + 1):
        dp[i][0] = i
    for j in range(len(str) + 1):
        dp[0][j] = j
    for i in range(1, len(target) + 1):
        t = target[i - 1]
        for j in range(1, len(str) + 1):
            s = str[j - 1]
            if t >= s:
                dp[i][j] = dp[i - 1][j] + 1
            else:
                min_presses = float('inf')
                for k in range(j):
                    if s <= str[k]:
                        min_presses = min(min_presses, dp[i - 1][k] + 1)
                dp[i][j] = min_presses
    return dp[-1][-1]
```

### C++
```cpp
int minPresses(string str, string target) {
    int dp[target.length() + 1][str.length() + 1];
    for (int i = 0; i <= target.length(); i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j <= str.length(); j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i <= target.length(); i++) {
        char t = target[i - 1];
        for (int j = 1; j <= str.length(); j++) {
            char s = str[j - 1];
            if (t >= s) {
                dp[i][j] = dp[i - 1][j] + 1;
            } else {
                int minPresses = INT_MAX;
                for (int k = 0; k < j; k++) {
                    if (s <= str[k]) {
                        minPresses = min(minPresses, dp[i - 1][k] + 1);
                    }
                }
                dp[i][j] = minPresses;
            }
        }
    }
    return dp[target.length()][0];
}
```

### JavaScript
```javascript
function minPresses(str, target) {
    let dp = new Array(target.length + 1).fill(0).map(() => new Array(str.length + 1).fill Infinity);
    for (let i = 0; i <= target.length; i++) {
        dp[i][0] = i;
    }
    for (let j = 0; j <= str.length; j++) {
        dp[0][j] = j;
    }
    for (let i = 1; i <= target.length; i++) {
        let t = target[i - 1];
        for (let j = 1; j <= str.length; j++) {
            let s = str[j - 1];
            if (t >= s) {
                dp[i][j] = dp[i - 1][j] + 1;
            } else {
                let minPresses = Infinity;
                for (let k = 0; k < j; k++) {
                    if (s <= str[k]) {
                        minPresses = Math.min(minPresses, dp[i - 1][k] + 1);
                    }
                }
                dp[i][j] = minPresses;
            }
        }
    }
    return dp[target.length][0];
}
```