---
id: "875952"
title: "Encode and Decode Strings"
slug: "encode-and-decode-strings"
difficulty: "Medium"
companyTags: []
tags: ["Strings", "Arrays"]
---

# Encode and Decode Strings
## Slug: encode-and-decode-strings
## Difficulty: Medium
## Id: 875952
## Topic Tags: Strings, Arrays
## Company Tags: None

### Summary
Given a string `s` and an integer `n`, we need to perform two operations:
1. **Encode**: Replace each character in the string with its ASCII value multiplied by `n`.
2. **Decode**: Reverse the encoding process.

This problem requires a basic understanding of strings, arrays, and mathematical operations.

### Detailed Explanation
To solve this problem, we will create two separate functions: one for encoding and another for decoding.

**Encoding Function**
The encoding function takes the input string `s` and integer `n` as parameters. It iterates through each character in the string, multiplies its ASCII value by `n`, and stores the result in a new array or string.

Here's the step-by-step breakdown:

1. Create an empty array or string to store the encoded values.
2. Iterate through each character in the input string using a loop (e.g., for-each or while-loop).
3. For each character, multiply its ASCII value by `n` and add the result to the new array or string.
4. Return the encoded array or string.

**Decoding Function**
The decoding function takes the encoded array or string and integer `n` as parameters. It iterates through each element in the encoded array or string, divides its value by `n`, and stores the result in a new array or string.

Here's the step-by-step breakdown:

1. Create an empty array or string to store the decoded values.
2. Iterate through each element in the encoded array or string using a loop (e.g., for-each or while-loop).
3. For each element, divide its value by `n` and add the result to the new array or string.
4. Return the decoded array or string.

**Time Complexity Analysis**
The time complexity of both encoding and decoding functions is O(n), where n is the length of the input string. This is because we are iterating through each character in the string once.

**Space Complexity Analysis**
The space complexity of both encoding and decoding functions is also O(n), as we are creating a new array or string to store the encoded or decoded values.

### Optimized Solutions

#### Java
```java
public class EncodeDecode {
    public static String encode(String s, int n) {
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            sb.append((int) c * n);
        }
        return sb.toString();
    }

    public static String decode(String s, int n) {
        StringBuilder sb = new StringBuilder();
        for (String str : s.split("")) {
            sb.append((char) Integer.parseInt(str) / n);
        }
        return sb.toString();
    }
}
```

#### Python
```python
class EncodeDecode:
    def encode(self, s: str, n: int) -> str:
        encoded = ""
        for c in s:
            encoded += str(ord(c) * n)
        return encoded

    def decode(self, s: str, n: int) -> str:
        decoded = ""
        for code in s.split():
            decoded += chr(int(code) // n)
        return decoded
```

#### C++
```cpp
class EncodeDecode {
public:
    string encode(string s, int n) {
        string encoded = "";
        for (char c : s) {
            encoded += to_string(c * n);
        }
        return encoded;
    }

    string decode(string s, int n) {
        string decoded = "";
        for (string code : split(s, "")) {
            decoded += (int(stoi(code)) / n);
        }
        return decoded;
    }

private:
    vector<string> split(const string& str, const string& delimiter) {
        vector<string> tokens;
        size_t pos = 0;
        while ((pos = str.find(delimiter)) != string::npos) {
            tokens.push_back(str.substr(0, pos));
            str.erase(0, pos + delimiter.length());
        }
        tokens.push_back(str);
        return tokens;
    }
};
```

#### JavaScript
```javascript
class EncodeDecode {
  encode(s, n) {
    let encoded = "";
    for (let c of s) {
      encoded += String.fromCharCode(c.charCodeAt(0) * n);
    }
    return encoded;
  }

  decode(s, n) {
    let decoded = "";
    for (let code of s.split("")) {
      decoded += String.fromCharCode(parseInt(code) / n);
    }
    return decoded;
  }
}
```

Note: The above solutions are provided as examples and may require adjustments based on specific requirements or constraints.