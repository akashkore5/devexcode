---
id: "703472"
title: "Construct binary palindrome by repeated appending and trimming"
slug: "construct-binary-palindrome-by-repeated-appending-and-trimming1005"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "DFS", "Graph", "palindrome", "Binary Representation", "Data Structures", "Algorithms"]
---

# Construct Binary Palindrome by Repeated Appending and Trimming

## Summary

Construct a binary palindrome by repeatedly appending and trimming a given binary number. A binary palindrome is a binary string that reads the same forwards and backwards. The problem requires us to develop an algorithm to construct this binary palindrome.

## Detailed Explanation

The approach to solve this problem involves a combination of DFS (Depth-First Search) and manipulation of binary strings. We start by creating a binary string from the given number. Then, we use DFS to append and trim the binary string until it becomes a palindrome.

Here's a step-by-step breakdown of the solution:

1. Convert the given binary number into a binary string.
2. Initialize an empty binary string `palindrome` to store the constructed palindrome.
3. Start a DFS from the first character of the binary string, moving towards the end.
4. For each character in the binary string, append it to `palindrome` if it is equal to the corresponding character at the opposite end of the palindrome (i.e., the same position but on the other side). If not, trim the last character from the palindrome and move towards the center.
5. Continue this process until the DFS reaches the middle of the binary string or the entire string has been processed.
6. The resulting `palindrome` is the constructed binary palindrome.

Time Complexity: O(n), where n is the length of the input binary number.
Space Complexity: O(1), as we only use a constant amount of space to store the `palindrome`.

## Optimized Solutions

### Java
```java
public class BinaryPalindrome {
    public static String constructBinaryPalindrome(int n) {
        StringBuilder palindrome = new StringBuilder();
        String binaryStr = Integer.toBinaryString(n);

        for (int i = 0; i < binaryStr.length(); i++) {
            if (i == 0 || i == binaryStr.length() - 1) {
                palindrome.append(binaryStr.charAt(i));
            } else {
                palindrome.append(binaryStr.charAt(i));
                while (!palindrome.toString().equals(reverseString(palindrome.toString()))) {
                    palindrome.deleteCharAt(palindrome.length() - 1);
                }
            }
        }

        return palindrome.toString();
    }

    private static String reverseString(String s) {
        StringBuilder sb = new StringBuilder(s).reverse();
        return sb.toString();
    }
}
```

### Python
```python
def construct_binary_palindrome(n):
    binary_str = bin(n)[2:]
    palindrome = ""

    for i in range(len(binary_str)):
        if i == 0 or i == len(binary_str) - 1:
            palindrome += binary_str[i]
        else:
            palindrome += binary_str[i]
            while palindrome != palindrome[::-1]:
                palindrome = palindrome[:-1]

    return palindrome
```

### C++
```cpp
#include <iostream>
#include <string>

std::string constructBinaryPalindrome(int n) {
    std::string binaryStr = std::to_string(n);
    std::string palindrome;

    for (int i = 0; i < binaryStr.length(); i++) {
        if (i == 0 || i == binaryStr.length() - 1) {
            palindrome += binaryStr[i];
        } else {
            palindrome += binaryStr[i];
            while (!palindromeCompare(palindrome, reverseString(palindrome))) {
                palindrome.pop_back();
            }
        }
    }

    return palindrome;
}

bool palindromeCompare(std::string s1, std::string s2) {
    if (s1.length() != s2.length()) return false;

    for (int i = 0; i < s1.length(); i++) {
        if (s1[i] != s2[s2.length() - i - 1]) return false;
    }

    return true;
}

std::string reverseString(std::string s) {
    std::string reversed = "";
    for (int i = s.length() - 1; i >= 0; i--) {
        reversed += s[i];
    }
    return reversed;
}
```

### JavaScript
```javascript
function constructBinaryPalindrome(n) {
    let binaryStr = n.toString(2);
    let palindrome = "";

    for (let i = 0; i < binaryStr.length; i++) {
        if (i === 0 || i === binaryStr.length - 1) {
            palindrome += binaryStr[i];
        } else {
            palindrome += binaryStr[i];
            while (!isPalindrome(palindrome)) {
                palindrome = palindrome.slice(0, -1);
            }
        }
    }

    return palindrome;
}

function isPalindrome(s) {
    let reversed = s.split("").reverse().join("");
    return s === reversed;
}
```

Note that the optimized solutions provided are in different programming languages but follow the same algorithmic approach as described above.