---
id: "879277"
title: "Operator Overloading In Python"
slug: "operator-overloading-in-python"
difficulty: "Easy"
companyTags: []
tags: []
---

# Operator Overloading In Python
## Slug: operator-overloading-in-python
## Difficulty: Easy
## Id: 879277
## Topic Tags: None
## Company Tags: None


### Summary
Operator overloading in Python is a technique that allows developers to redefine the behavior of operators such as `+`, `-`, `*`, `/`, `<`, `>`, etc. for user-defined classes. This feature enables objects of custom classes to support standard mathematical and logical operations, making it easier to work with complex data structures.

### Detailed Explanation
The goal is to create a class that supports basic arithmetic operations like addition, subtraction, multiplication, and division. We will define a `ComplexNumber` class with real and imaginary parts, and then overload the corresponding operators to perform these operations correctly.

Here's the step-by-step breakdown of the solution:

1. Define the `ComplexNumber` class:
```python
class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __str__(self):
        return f"{self.real} + {self.imag}i"
```

2. Implement operator overloading for addition and subtraction:
```python
def __add__(self, other):
    if isinstance(other, ComplexNumber):
        return ComplexNumber(self.real + other.real, self.imag + other.imag)
    else:
        raise TypeError("Unsupported operand type for +")

def __sub__(self, other):
    if isinstance(other, ComplexNumber):
        return ComplexNumber(self.real - other.real, self.imag - other.imag)
    else:
        raise TypeError("Unsupported operand type for -")
```

3. Implement operator overloading for multiplication and division:
```python
def __mul__(self, other):
    if isinstance(other, ComplexNumber):
        return ComplexNumber(
            self.real * other.real - self.imag * other.imag,
            self.real * other.imag + self.imag * other.real
        )
    else:
        raise TypeError("Unsupported operand type for *")

def __truediv__(self, other):
    if isinstance(other, ComplexNumber) and other.real ** 2 + other.imag ** 2 != 0:
        return ComplexNumber(
            (self.real * other.real + self.imag * other.imag) / (other.real ** 2 + other.imag ** 2),
            (self.imag * other.real - self.real * other.imag) / (other.real ** 2 + other.imag ** 2)
        )
    else:
        raise ZeroDivisionError("Cannot divide by zero")
```

### Optimized Solutions

#### Java
```java
class ComplexNumber {
    double real, imag;

    public ComplexNumber(double real, double imag) {
        this.real = real;
        this.imag = imag;
    }

    @Override
    public String toString() {
        return String.format("%f + %fi", real, imag);
    }

    public ComplexNumber add(ComplexNumber other) {
        if (other instanceof ComplexNumber)
            return new ComplexNumber(real + ((ComplexNumber) other).real, imag + ((ComplexNumber) other).imag);
        else throw new TypeError("Unsupported operand type for +");
    }

    public ComplexNumber subtract(ComplexNumber other) {
        if (other instanceof ComplexNumber)
            return new ComplexNumber(real - ((ComplexNumber) other).real, imag - ((ComplexNumber) other).imag);
        else throw new TypeError("Unsupported operand type for -");
    }

    public ComplexNumber multiply(ComplexNumber other) {
        if (other instanceof ComplexNumber)
            return new ComplexNumber(
                    real * ((ComplexNumber) other).real - imag * ((ComplexNumber) other).imag,
                    real * ((ComplexNumber) other).imag + imag * ((ComplexNumber) other).real
            );
        else throw new TypeError("Unsupported operand type for *");
    }

    public ComplexNumber divide(ComplexNumber other) {
        if (other instanceof ComplexNumber && ((ComplexNumber) other).real ** 2 + ((ComplexNumber) other).imag ** 2 != 0)
            return new ComplexNumber(
                    (real * ((ComplexNumber) other).real + imag * ((ComplexNumber) other).imag) / (((ComplexNumber) other).real ** 2 + ((ComplexNumber) other).imag ** 2),
                    (imag * ((ComplexNumber) other).real - real * ((ComplexNumber) other).imag) / (((ComplexNumber) other).real ** 2 + ((ComplexNumber) other).imag ** 2)
            );
        else throw new ZeroDivisionError("Cannot divide by zero");
    }
}
```

#### Python
```python
class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __str__(self):
        return f"{self.real} + {self.imag}i"

    def add(self, other):
        if isinstance(other, ComplexNumber):
            return ComplexNumber(self.real + other.real, self.imag + other.imag)
        else:
            raise TypeError("Unsupported operand type for +")

    def subtract(self, other):
        if isinstance(other, ComplexNumber):
            return ComplexNumber(self.real - other.real, self.imag - other.imag)
        else:
            raise TypeError("Unsupported operand type for -")

    def multiply(self, other):
        if isinstance(other, ComplexNumber):
            return ComplexNumber(
                self.real * other.real - self.imag * other.imag,
                self.real * other.imag + self.imag * other.real
            )
        else:
            raise TypeError("Unsupported operand type for *")

    def divide(self, other):
        if isinstance(other, ComplexNumber) and other.real ** 2 + other.imag ** 2 != 0:
            return ComplexNumber(
                (self.real * other.real + self.imag * other.imag) / (other.real ** 2 + other.imag ** 2),
                (self.imag * other.real - self.real * other.imag) / (other.real ** 2 + other.imag ** 2)
            )
        else:
            raise ZeroDivisionError("Cannot divide by zero")
```

#### C++
```cpp
class ComplexNumber {
public:
    double real, imag;

    ComplexNumber(double real, double imag) : real(real), imag(imag) {}

    std::string toString() {
        return std::to_string(real) + " + " + std::to_string(imag) + "i";
    }

    ComplexNumber add(const ComplexNumber& other) const {
        return ComplexNumber(real + other.real, imag + other.imag);
    }

    ComplexNumber subtract(const ComplexNumber& other) const {
        return ComplexNumber(real - other.real, imag - other.imag);
    }

    ComplexNumber multiply(const ComplexNumber& other) const {
        return ComplexNumber(
            real * other.real - imag * other.imag,
            real * other.imag + imag * other.real
        );
    }

    ComplexNumber divide(const ComplexNumber& other) const {
        if (other.real ** 2 + other.imag ** 2 != 0)
            return ComplexNumber(
                (real * other.real + imag * other.imag) / (other.real ** 2 + other.imag ** 2),
                (imag * other.real - real * other.imag) / (other.real ** 2 + other.imag ** 2)
            );
        else
            throw std::runtime_error("Cannot divide by zero");
    }
};
```

#### JavaScript
```javascript
class ComplexNumber {
    constructor(real, imag) {
        this.real = real;
        this.imag = imag;
    }

    toString() {
        return `${this.real} + ${this.imag}i`;
    }

    add(other) {
        if (other instanceof ComplexNumber)
            return new ComplexNumber(this.real + other.real, this.imag + other.imag);
        else throw new TypeError("Unsupported operand type for +");
    }

    subtract(other) {
        if (other instanceof ComplexNumber)
            return new ComplexNumber(this.real - other.real, this.imag - other.imag);
        else throw new TypeError("Unsupported operand type for -");
    }

    multiply(other) {
        if (other instanceof ComplexNumber)
            return new ComplexNumber(
                this.real * other.real - this.imag * other.imag,
                this.real * other.imag + this.imag * other.real
            );
        else throw new TypeError("Unsupported operand type for *");
    }

    divide(other) {
        if (other instanceof ComplexNumber && other.real ** 2 + other.imag ** 2 != 0)
            return new ComplexNumber(
                (this.real * other.real + this.imag * other.imag) / (other.real ** 2 + other.imag ** 2),
                (this.imag * other.real - this.real * other.imag) / (other.real ** 2 + other.imag ** 2)
            );
        else throw new Error("Cannot divide by zero");
    }
}
```