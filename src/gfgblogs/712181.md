---
id: "712181"
title: "Minimal Cost"
slug: "minimal-cost"
difficulty: "Medium"
companyTags: []
tags: ["Dynamic Programming", "Arrays", "Data Structures", "Algorithms"]
---

**Minimal Cost**
===============

**Slug:** minimal-cost
**Difficulty:** Medium
**Id:** 712181
**Topic Tags:** Dynamic Programming, Arrays, Data Structures, Algorithms
**Company Tags:** None

## Summary
The Minimal Cost problem is a dynamic programming optimization problem that involves finding the minimum cost of a given array. The problem requires an algorithmic approach to solve efficiently.

## Detailed Explanation
The Minimal Cost problem can be explained as follows: Given an array of integers `arr` and another integer `k`, find the minimum cost to reach all elements in the array. The cost to reach each element is equal to its value, but with a twist - we can only jump `k` steps at a time.

To solve this problem, we will use dynamic programming. Let's define two arrays: `dp` and `prev`. `dp[i]` will store the minimum cost to reach the `i-th` element in the array, and `prev[i]` will store the previous index from which we can jump to the `i-th` element.

Here's a step-by-step breakdown of the solution:

1. Initialize the first element of both arrays: `dp[0] = 0`, `prev[0] = -1`.
2. Iterate through the array, starting from the second element (`i = 1`). For each element:
   * Calculate the minimum cost to reach this element by considering all possible jumps from the previous elements that are within `k` steps: `dp[i] = min(dp[j] + arr[i]) for j in range(max(0, i-k), i)`.
   * Update `prev[i]` with the index of the previous element that gives us the minimum cost to reach this element.
3. The minimum cost to reach all elements is stored in the last element of the `dp` array: `min_cost = dp[-1]`.

Time complexity: O(n), where n is the size of the input array.
Space complexity: O(n), as we need to store the `dp` and `prev` arrays.

## Optimized Solutions
### Java
```java
public class MinimalCost {
    public static int findMinCost(int[] arr, int k) {
        int n = arr.length;
        int[] dp = new int[n];
        int[] prev = new int[n];
        dp[0] = 0;
        prev[0] = -1;
        for (int i = 1; i < n; i++) {
            int minCost = Integer.MAX_VALUE;
            for (int j = Math.max(0, i-k); j < i; j++) {
                if (dp[j] + arr[i] < minCost) {
                    minCost = dp[j] + arr[i];
                    prev[i] = j;
                }
            }
            dp[i] = minCost;
        }
        return dp[n-1];
    }
```

### Python
```python
def find_min_cost(arr, k):
    n = len(arr)
    dp = [0] * n
    prev = [-1] * n
    dp[0] = 0
    for i in range(1, n):
        min_cost = float('inf')
        for j in range(max(0, i-k), i):
            if dp[j] + arr[i] < min_cost:
                min_cost = dp[j] + arr[i]
                prev[i] = j
        dp[i] = min_cost
    return dp[-1]
```

### C++
```cpp
class MinimalCost {
public:
    int findMinCost(int* arr, int k) {
        int n = *(&arr - 1);
        int dp[n];
        int prev[n];
        dp[0] = 0;
        prev[0] = -1;
        for (int i = 1; i < n; i++) {
            int minCost = INT_MAX;
            for (int j = std::max(0, i-k); j < i; j++) {
                if (dp[j] + arr[i] < minCost) {
                    minCost = dp[j] + arr[i];
                    prev[i] = j;
                }
            }
            dp[i] = minCost;
        }
        return dp[n-1];
    }
};
```

### JavaScript
```javascript
function findMinCost(arr, k) {
  let n = arr.length;
  let dp = new Array(n).fill(0);
  let prev = new Array(n).fill(-1);
  dp[0] = 0;
  for (let i = 1; i < n; i++) {
    let minCost = Infinity;
    for (let j = Math.max(0, i-k); j < i; j++) {
      if (dp[j] + arr[i] < minCost) {
        minCost = dp[j] + arr[i];
        prev[i] = j;
      }
    }
    dp[i] = minCost;
  }
  return dp[n-1];
}
```