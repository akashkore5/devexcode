---
id: "709926"
title: "Number of pairs"
slug: "number-of-pairs-1645358985"
difficulty: "Hard"
companyTags: []
tags: ["Dynamic Programming", "Graph", "Disjoint Set", "Data Structures", "Algorithms"]
---

Here is a detailed Markdown blog post for the problem:

# Number of Pairs
## Summary

The problem is to find the number of pairs in a graph where each node has an even degree. The key concepts involved are dynamic programming and disjoint sets.

## Detailed Explanation

To solve this problem, we can use a combination of dynamic programming and disjoint sets. We will start by initializing an array `dp` of size `n+1`, where `n` is the number of nodes in the graph. We will also initialize a set `parent` to keep track of the parent of each node.

We will then iterate over each node in the graph, and for each node, we will find all its neighbors using DFS. For each neighbor, we will check if it has an even degree. If it does, we will add 1 to the count of pairs.

To avoid counting the same pair multiple times, we can use a disjoint set data structure. We will initialize each node as its own parent, and then for each edge in the graph, we will union the two nodes that the edge connects. This way, all nodes with the same connected component will be part of the same set.

Finally, we will iterate over each set and add 1 to the count of pairs for each set that has more than one node. This is because a pair can only exist between two nodes in the same set if they have an even degree.

Here is the step-by-step breakdown:

* Initialize `dp` array of size `n+1`
* Initialize `parent` set
* Iterate over each node in the graph:
	+ Find all neighbors using DFS
	+ For each neighbor, check if it has an even degree and add 1 to the count of pairs if it does
	+ Use disjoint sets to avoid counting the same pair multiple times
* Iterate over each set and add 1 to the count of pairs for each set that has more than one node

Time complexity: O(n)
Space complexity: O(n)

## Optimized Solutions

### Java
```java
int countPairs(int[][] graph) {
    int n = graph.length;
    boolean[] visited = new boolean[n];
    List<Integer>[] parentList = new List[n];

    for (int i = 0; i < n; i++) {
        parentList[i] = new ArrayList<>();
        parentList[i].add(i);
    }

    for (int i = 0; i < n; i++) {
        for (int j = graph[i].length - 1; j >= 0; j--) {
            int neighbor = graph[i][j];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                parentList[neighbor].add(i);
            }
        }
    }

    int count = 0;
    for (int i = 0; i < n; i++) {
        if (parentList[i].size() > 1) {
            count++;
        }
    }

    return count;
}
```

### Python
```python
def count_pairs(graph):
    n = len(graph)
    visited = [False] * n
    parent_list = [[] for _ in range(n)]

    for i in range(n):
        parent_list[i].append(i)

    for i in range(n):
        for j in range(len(graph[i]) - 1, -1, -1):
            neighbor = graph[i][j]
            if not visited[neighbor]:
                visited[neighbor] = True
                parent_list[neighbor].append(i)

    count = 0
    for i in range(n):
        if len(parent_list[i]) > 1:
            count += 1

    return count
```

### C++
```cpp
int countPairs(int graph[][1000], int n) {
    bool visited[n];
    for (int i = 0; i < n; i++) {
        visited[i] = false;
    }

    int parent[n][20];
    for (int i = 0; i < n; i++) {
        parent[i][0] = i;
    }

    for (int i = 0; i < n; i++) {
        for (int j = graph[i].size() - 1; j >= 0; j--) {
            int neighbor = graph[i][j];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                parent[neighbor][0] = i;
            }
        }
    }

    int count = 0;
    for (int i = 0; i < n; i++) {
        if (parent[i][0] > 1) {
            count++;
        }
    }

    return count;
}
```

### JavaScript
```javascript
function countPairs(graph) {
    let n = graph.length;
    let visited = new Array(n).fill(false);
    let parentList = new Array(n);

    for (let i = 0; i < n; i++) {
        parentList[i] = [i];
    }

    for (let i = 0; i < n; i++) {
        for (let j = graph[i].length - 1; j >= 0; j--) {
            let neighbor = graph[i][j];
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                parentList[neighbor].push(i);
            }
        }
    }

    let count = 0;
    for (let i = 0; i < n; i++) {
        if (parentList[i].length > 1) {
            count++;
        }
    }

    return count;
}
```

I hope this helps! Let me know if you have any questions.