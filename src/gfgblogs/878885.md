---
id: "878885"
title: "Calculator"
slug: "calculator--172632"
difficulty: "Easy"
companyTags: []
tags: ["CPP-Control-Flow", "Java", "C"]
---

# Calculator

## Summary

This problem involves creating a simple calculator that can perform basic arithmetic operations such as addition, subtraction, multiplication, and division. The calculator should be able to handle multiple operations in sequence, allowing users to input expressions like "2+3*4" or "10-5/2". This problem requires an understanding of control flow and operator precedence.

## Detailed Explanation

To solve this problem, we can use a stack-based approach. We'll define a function `calculate` that takes a string expression as input and returns the result of evaluating the expression. Here's a step-by-step breakdown of the solution:

1. **Tokenization**: Split the input expression into individual tokens (operators and operands). For example, "2+3*4" would become ["2", "+", "3", "*", "4"].
2. **Operator precedence**: Determine the order in which operators should be applied. In this case, we'll follow the standard operator precedence rules: multiplication and division have higher precedence than addition and subtraction.
3. **Evaluation**: Evaluate each token as follows:
	* Operands (numbers): Store them in a stack.
	* Operators (+, -, \*, /):
		+ If the top of the stack is an operand, push the new operand onto the stack.
		+ If the top of the stack is an operator, pop the top two operands from the stack, apply the operation, and push the result back onto the stack.
4. **Final result**: The final result is the single value left on the stack after all tokens have been processed.

Time complexity: O(n), where n is the length of the input expression.
Space complexity: O(n), as we need to store the tokens in a stack.

## Optimized Solutions

### Java
```java
public class Calculator {
    public static double calculate(String expression) {
        // Tokenization and operator precedence not shown for brevity
        Stack<Double> stack = new Stack<>();
        for (String token : tokens) {
            if (isOperator(token)) {
                // Operator processing logic goes here
            } else {
                stack.push(Double.parseDouble(token));
            }
        }
        return stack.pop();
    }
}
```

### Python
```python
class Calculator:
    def calculate(self, expression):
        # Tokenization and operator precedence not shown for brevity
        stack = []
        for token in tokens:
            if is_operator(token):
                # Operator processing logic goes here
            else:
                stack.append(float(token))
        return stack.pop()
```

### C++
```cpp
class Calculator {
public:
    double calculate(const std::string& expression) {
        // Tokenization and operator precedence not shown for brevity
        std::stack<double> stack;
        for (const auto& token : tokens) {
            if (is_operator(token)) {
                // Operator processing logic goes here
            } else {
                stack.push(std::stod(token));
            }
        }
        return stack.top();
    }
};
```

### JavaScript
```javascript
class Calculator {
  calculate(expression) {
    // Tokenization and operator precedence not shown for brevity
    const stack = [];
    for (const token of tokens) {
      if (isOperator(token)) {
        // Operator processing logic goes here
      } else {
        stack.push(parseFloat(token));
      }
    }
    return stack.pop();
  }
}
```

Note: The above solutions assume that the `tokens` array contains the individual tokens from the input expression. You will need to implement tokenization and operator precedence handling in your actual solution.