---
id: "700513"
title: "Polynomial Addition"
slug: "polynomial-addition"
difficulty: "Medium"
companyTags: ["Amazon"]
tags: ["Linked List", "Mathematical", "Data Structures", "Algorithms"]
---

Here is a detailed Markdown blog post for the Polynomial Addition problem:

**Polynomial Addition**
=====================

### Summary

The Polynomial Addition problem involves adding two polynomials represented as linked lists. Each node in the linked list represents a term in the polynomial, with the value and exponent of each term stored in the node. The task is to write an algorithm that adds these two polynomials by iterating through their terms and combining like terms.

### Detailed Explanation

To solve this problem, we'll first initialize a new linked list to store the result of the addition. Then, we'll iterate through the terms of both input polynomials simultaneously. For each term, we'll check if it's already present in the result polynomial or if it's a new term that needs to be added.

Here's a step-by-step breakdown of the algorithm:

1. Initialize an empty linked list `result` to store the sum of the two polynomials.
2. Iterate through the terms of both input polynomials simultaneously using three pointers: `i` for the first polynomial, `j` for the second polynomial, and `k` for the result polynomial.
3. For each term, check if it's already present in the result polynomial by comparing the exponents. If the exponents are equal, add the values of the two terms and update the value of the corresponding node in the result polynomial.
4. If the exponents are not equal, create a new node in the result polynomial with the term's value and exponent.
5. Continue iterating through the terms until one of the input polynomials is exhausted.
6. Return the resulting linked list as the sum of the two input polynomials.

The time complexity of this algorithm is O(n), where n is the total number of terms in both input polynomials, since we're iterating through each term once. The space complexity is also O(n) because we're storing the result polynomial in a new linked list.

### Optimized Solutions

Here are optimized solutions for the Polynomial Addition problem in various programming languages:

#### Java
```java
class Node {
    int value;
    int exponent;

    public Node(int value, int exponent) {
        this.value = value;
        this.exponent = exponent;
    }
}

public class PolynomialAddition {
    public static Node[] addPolynomials(Node[] poly1, Node[] poly2) {
        Node[] result = new Node[0];
        for (int i = 0; i < Math.max(poly1.length, poly2.length); i++) {
            int value = 0;
            if (i < poly1.length && poly1[i].exponent == i) {
                value += poly1[i].value;
            }
            if (i < poly2.length && poly2[i].exponent == i) {
                value += poly2[i].value;
            }
            if (value != 0 || result.length == 0) {
                Node newNode = new Node(value, i);
                Node[] temp = new Node[result.length + 1];
                System.arraycopy(result, 0, temp, 0, result.length);
                temp[temp.length - 1] = newNode;
                result = temp;
            }
        }
        return result;
    }
}
```

#### Python
```python
class Node:
    def __init__(self, value, exponent):
        self.value = value
        self.exponent = exponent

def add_polynomials(poly1, poly2):
    result = []
    for i in range(max(len(poly1), len(poly2))):
        value = 0
        if i < len(poly1) and poly1[i].exponent == i:
            value += poly1[i].value
        if i < len(poly2) and poly2[i].exponent == i:
            value += poly2[i].value
        if value != 0 or not result:
            node = Node(value, i)
            result.append(node)
    return result

# Example usage
poly1 = [Node(3, 0), Node(2, 1)]
poly2 = [Node(-1, 0), Node(4, 2)]
result = add_polynomials(poly1, poly2)
```

#### C++
```cpp
struct Node {
    int value;
    int exponent;

    Node(int value, int exponent) : value(value), exponent(exponent) {}
};

std::vector<Node> addPolynomials(const std::vector<Node>& poly1, const std::vector<Node>& poly2) {
    std::vector<Node> result;
    for (int i = 0; i <= std::max(poly1.size(), poly2.size()); i++) {
        int value = 0;
        if (i < poly1.size() && poly1[i].exponent == i) {
            value += poly1[i].value;
        }
        if (i < poly2.size() && poly2[i].exponent == i) {
            value += poly2[i].value;
        }
        if (value != 0 || result.empty()) {
            Node newNode = Node(value, i);
            result.push_back(newNode);
        }
    }
    return result;
}
```

#### JavaScript
```javascript
class Node {
    constructor(value, exponent) {
        this.value = value;
        this.exponent = exponent;
    }
}

function addPolynomials(poly1, poly2) {
    let result = [];
    for (let i = 0; i <= Math.max(poly1.length, poly2.length); i++) {
        let value = 0;
        if (i < poly1.length && poly1[i].exponent === i) {
            value += poly1[i].value;
        }
        if (i < poly2.length && poly2[i].exponent === i) {
            value += poly2[i].value;
        }
        if (value !== 0 || !result.length) {
            let newNode = new Node(value, i);
            result.push(newNode);
        }
    }
    return result;
}

// Example usage
const poly1 = [new Node(3, 0), new Node(2, 1)];
const poly2 = [new Node(-1, 0), new Node(4, 2)];
const result = addPolynomials(poly1, poly2);
```

These optimized solutions use a similar approach to the detailed explanation above, with minor differences in syntax and implementation details.