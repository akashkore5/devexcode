---
id: "712461"
title: "Minimum Window Substring"
slug: "minimum-window-subsequence"
difficulty: "Medium"
companyTags: []
tags: ["Dynamic Programming", "Arrays", "Algorithms"]
---

**Minimum Window Substring**
=====================

**Slug**: minimum-window-subsequence
**Difficulty**: Medium
**Id**: 712461
**Topic Tags**: Dynamic Programming, Arrays, Algorithms
**Company Tags**: None

## Summary
The Minimum Window Substring problem involves finding the shortest window in a given string that contains all characters of another input string. The goal is to find the smallest substring within the original string that has all the characters present in the target string.

## Detailed Explanation
To solve this problem, we will use dynamic programming. We will create two pointers, `start` and `end`, to traverse the original string. The `start` pointer points to the beginning of the current window, while the `end` pointer points to the end of the current window.

We also maintain a dictionary, `dict`, to keep track of the frequency of each character in the target string. As we traverse the original string, we update the frequency of each character in the `dict`. When we find a character that is not present in the target string or if its frequency becomes zero, we move the `start` pointer forward until we find all characters from the target string again.

Here's the step-by-step breakdown:

1. Initialize `start` and `end` pointers to 0.
2. Create an empty dictionary `dict`.
3. Iterate through the original string using the `end` pointer.
4. For each character, update its frequency in the `dict`.
5. If the frequency of a character becomes zero or if it is not present in the target string, move the `start` pointer forward until we find all characters from the target string again.
6. Update the minimum window size and the start and end indices accordingly.
7. Return the minimum window substring.

Here's an example:

Original String: "ADOBECODEBANC"
Target String: "ABC"

Window: "BANC" is the smallest window that contains all characters of the target string.

Time complexity: O(n), where n is the length of the original string.
Space complexity: O(1), as we only use a constant amount of space to store the dictionary and pointers.

## Optimized Solutions

### Java
```java
public class MinimumWindowSubstring {
    public static String minWindow(String s, String t) {
        if (s == null || t == null || s.length() < t.length()) {
            return "";
        }
        
        int start = 0;
        int end = 0;
        int formed = 0;
        int windowStart = 0;
        int minLength = Integer.MAX_VALUE;
        String result = "";
        
        int[] dict = new int[256];
        
        for (int i = 0; i < t.length(); i++) {
            dict[t.charAt(i)]++;
        }
        
        while (end < s.length()) {
            char rightChar = s.charAt(end);
            if (dict[rightChar] > 0) {
                formed++;
            }
            dict[rightChar]--;
            
            while (formed == t.length() && start <= end) {
                char leftChar = s.charAt(start);
                if (end - start + 1 < minLength) {
                    minLength = end - start + 1;
                    windowStart = start;
                    result = s.substring(windowStart, end + 1);
                }
                
                dict[leftChar]++;
                if (dict[leftChar] > 0) {
                    formed--;
                }
                start++;
            }
            
            end++;
        }
        
        return result;
    }
}
```

### Python
```python
def min_window(s, t):
    if not s or not t or len(s) < len(t):
        return ""

    start = 0
    end = 0
    formed = 0
    windowStart = 0
    minLength = float("inf")
    result = ""
    
    dict = {}
    for char in t:
        if char not in dict:
            dict[char] = 0
        dict[char] += 1
    
    while end < len(s):
        rightChar = s[end]
        if rightChar in dict and dict[rightChar] > 0:
            formed += 1
        dict[rightChar] -= 1
        
        while formed == len(t) and start <= end:
            leftChar = s[start]
            if end - start + 1 < minLength:
                minLength = end - start + 1
                windowStart = start
                result = s[windowStart:end+1]
            
            dict[leftChar] += 1
            if leftChar in dict and dict[leftChar] > 0:
                formed -= 1
            start += 1
        
        end += 1
    
    return result
```

### C++
```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.empty() || t.empty() || s.length() < t.length()) {
            return "";
        }
        
        int start = 0;
        int end = 0;
        int formed = 0;
        int windowStart = 0;
        int minLength = INT_MAX;
        string result = "";
        
        unordered_map<char, int> dict;
        for (char c : t) {
            if (dict.count(c)) {
                dict[c]++;
            } else {
                dict[c] = 1;
            }
        }
        
        while (end < s.length()) {
            char rightChar = s[end];
            if (dict.count(rightChar) && dict[rightChar] > 0) {
                formed++;
            }
            dict[rightChar]--;
            
            while (formed == t.length() && start <= end) {
                char leftChar = s[start];
                if (end - start + 1 < minLength) {
                    minLength = end - start + 1;
                    windowStart = start;
                    result = s.substr(windowStart, end - start + 1);
                }
                
                dict[leftChar]++;
                if (dict.count(leftChar) && dict[leftChar] > 0) {
                    formed--;
                }
                start++;
            }
            
            end++;
        }
        
        return result;
    }
};
```

### JavaScript
```javascript
function minWindow(s, t) {
    if (!s || !t || s.length < t.length) {
        return "";
    }
    
    let start = 0;
    let end = 0;
    let formed = 0;
    let windowStart = 0;
    let minLength = Infinity;
    let result = "";
    
    let dict = {};
    for (let char of t) {
        if (!dict[char]) {
            dict[char] = 0;
        }
        dict[char]++;
    }
    
    while (end < s.length()) {
        let rightChar = s[end];
        if (dict[rightChar] && dict[rightChar] > 0) {
            formed++;
        }
        dict[rightChar]--;
        
        while (formed === t.length() && start <= end) {
            let leftChar = s[start];
            if (end - start + 1 < minLength) {
                minLength = end - start + 1;
                windowStart = start;
                result = s.substring(windowStart, end + 1);
            }
            
            dict[leftChar]++;
            if (dict[leftChar] && dict[leftChar] > 0) {
                formed--;
            }
            start++;
        }
        
        end++;
    }
    
    return result;
}
```