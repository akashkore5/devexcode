---
id: "881444"
title: "Parties and seats"
slug: "parties-and-seats--191330"
difficulty: "Basic"
companyTags: []
tags: ["Map", "Data Structures"]
---

Here is the generated Markdown blog post for the "Parties and seats" problem:

**Parties and Seats**
=====================

## Summary
The problem revolves around a party with multiple attendees, where each person has a specific seat preference. The goal is to allocate seats to these individuals in a way that maximizes overall happiness or satisfaction. This problem involves concepts from data structures, particularly maps.

## Detailed Explanation
To solve this problem, we can use a map data structure to keep track of the preferences and assign seats accordingly. We'll iterate through each person's preference list and check if their preferred seat is available. If it is, we allocate that seat; otherwise, we move on to the next preference.

Here's a step-by-step breakdown:

1. Initialize an empty map `seats` to store the assigned seats.
2. Iterate through each person's preference list:
	* For each preference, check if the preferred seat is available (i.e., not already assigned).
	* If it is, assign that seat to the person and update the `seats` map.
	* If not, move on to the next preference.
3. Once all preferences have been processed, return the `seats` map as the final result.

Time complexity: O(n), where n is the number of people or seats. We iterate through each person's preference list once, and for each iteration, we perform a constant-time operation (checking availability or updating the map).

Space complexity: O(n), since we store the assigned seats in a map with n entries.

## Optimized Solutions

### Java
```java
Map<Integer, Integer> seats = new HashMap<>();
for (int i = 0; i < people.size(); i++) {
    int personId = people.get(i);
    for (int seat : preferences.get(personId)) {
        if (!seats.containsKey(seat) || seats.get(seat) == personId) {
            seats.put(seat, personId);
            break;
        }
    }
}
```

### Python
```python
seats = {}
for person in people:
    for seat in preferences[person]:
        if seat not in seats or seats[seat] == person:
            seats[seat] = person
            break
```

### C++
```cpp
map<int, int> seats;
for (int i = 0; i < people.size(); i++) {
    int personId = people[i];
    for (int seat : preferences[personId]) {
        if (!seats.count(seat) || seats[seat] == personId) {
            seats[seat] = personId;
            break;
        }
    }
}
```

### JavaScript
```javascript
const seats = {};
for (let i = 0; i < people.length; i++) {
    const personId = people[i];
    for (let seat of preferences[personId]) {
        if (!seats.hasOwnProperty(seat) || seats[seat] === personId) {
            seats[seat] = personId;
            break;
        }
    }
}
```

Note: The above solutions assume that the `people` and `preferences` arrays are already defined, and the seat preference values are integers starting from 0.