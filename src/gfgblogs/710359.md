---
id: "710359"
title: "K Centers Problem"
slug: "k-centers-problem"
difficulty: "Hard"
companyTags: []
tags: []
---

# K Centers Problem
## Slug: k-centers-problem
## Difficulty: Hard
## Id: 710359

### Summary
The K Centers problem is a classic clustering problem where we need to find the optimal set of K centers in a given set of points such that the maximum distance from any point to its nearest center is minimized. This problem involves concepts like greedy algorithms, clustering, and optimization.

## Detailed Explanation

The problem can be solved using a combination of greedy algorithm and clustering approach. 

Here's a step-by-step breakdown of the solution:

1. Initialize K centers: Randomly select K points from the given set of points as the initial centers.
2. Cluster assignment: Assign each point to its nearest center.
3. Re-centering: Update the positions of the K centers by calculating their new positions based on the assigned points.
4. Repeat steps 2-3 until no further changes occur.

The time complexity of this algorithm is O(nklogn) where n is the number of points and k is the number of centers, due to the use of sorting in step 3.

The space complexity is O(n) for storing the points and their assigned centers.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class KCenters {
    public static List<Integer> kCenters(int[][] points, int K) {
        // Initialize K centers
        Random rand = new Random();
        List<Integer[]> centers = new ArrayList<>();
        for (int i = 0; i < K; i++) {
            centers.add(new Integer[]{rand.nextInt(100), rand.nextInt(100)});
        }

        while (true) {
            // Cluster assignment
            Map<Integer, Integer> clusterAssignment = new HashMap<>();
            for (int[] point : points) {
                int minDistance = Integer.MAX_VALUE;
                Integer nearestCenterIndex = null;
                for (int i = 0; i < K; i++) {
                    int distance = distance(point, centers.get(i));
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestCenterIndex = i;
                    }
                }
                clusterAssignment.put(Arrays.hashCode(point), nearestCenterIndex);
            }

            // Re-centering
            List<Integer[]> newCenters = new ArrayList<>();
            for (int i = 0; i < K; i++) {
                int[] centerPoint = null;
                int sumX = 0, sumY = 0;
                int count = 0;
                for (Map.Entry<Integer, Integer> entry : clusterAssignment.entrySet()) {
                    if (entry.getValue().equals(i)) {
                        int[] point = points[entry.getKey()];
                        sumX += point[0];
                        sumY += point[1];
                        count++;
                    }
                }
                centerPoint = new int[]{sumX / count, sumY / count};
                newCenters.add(centerPoint);
            }
            centers = newCenters;

            // Check for convergence
            boolean converged = true;
            for (int i = 0; i < K; i++) {
                if (!Arrays.equals(centers.get(i), newCenters.get(i))) {
                    converged = false;
                    break;
                }
            }
            if (converged) {
                break;
            }
        }

        return centers.stream().mapToInt(Integer[]::intValue).toArray();
    }

    public static int distance(int[] p1, int[] p2) {
        return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);
    }
}
```

#### Python
```python
def kCenters(points, K):
    # Initialize K centers
    import random
    centers = [random.sample(range(100), 2) for _ in range(K)]

    while True:
        # Cluster assignment
        cluster_assignment = {}
        for point in points:
            min_distance = float('inf')
            nearest_center_index = None
            for i, center in enumerate(centers):
                distance = ((point[0] - center[0]) ** 2 + (point[1] - center[1]) ** 2) ** 0.5
                if distance < min_distance:
                    min_distance = distance
                    nearest_center_index = i
            cluster_assignment[tuple(point)] = nearest_center_index

        # Re-centering
        new_centers = []
        for i in range(K):
            center_point = None
            sum_x, sum_y, count = 0, 0, 0
            for point, index in cluster_assignment.items():
                if index == i:
                    x, y = point
                    sum_x += x
                    sum_y += y
                    count += 1
            center_point = (sum_x / count, sum_y / count)
            new_centers.append(center_point)

        centers = new_centers

        # Check for convergence
        converged = True
        for i in range(K):
            if not np.array_equal(centers[i], new_centers[i]):
                converged = False
                break
        if converged:
            break

    return [list(center) for center in centers]
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>

using namespace std;

vector<vector<int>> kCenters(vector<vector<int>>& points, int K) {
    // Initialize K centers
    vector<vector<int>> centers;
    for (int i = 0; i < K; i++) {
        centers.push_back({rand() % 100, rand() % 100});
    }

    while (true) {
        // Cluster assignment
        unordered_map<int, int> clusterAssignment;
        for (const auto& point : points) {
            int minDistance = INT_MAX;
            int nearestCenterIndex = -1;
            for (int i = 0; i < K; i++) {
                int distance = getDistance(point, centers[i]);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestCenterIndex = i;
                }
            }
            clusterAssignment[point[0] * 10000 + point[1]] = nearestCenterIndex;
        }

        // Re-centering
        vector<vector<int>> newCenters;
        for (int i = 0; i < K; i++) {
            int sumX = 0, sumY = 0, count = 0;
            for (const auto& entry : clusterAssignment) {
                if (entry.second == i) {
                    int x = entry.first / 10000;
                    int y = entry.first % 10000;
                    sumX += x;
                    sumY += y;
                    count++;
                }
            }
            newCenters.push_back({sumX / count, sumY / count});
        }
        centers = newCenters;

        // Check for convergence
        bool converged = true;
        for (int i = 0; i < K; i++) {
            if (!equal(centers[i], newCenters[i])) {
                converged = false;
                break;
            }
        }
        if (converged) {
            break;
        }
    }

    return centers;
}

int getDistance(const vector<int>& p1, const vector<int>& p2) {
    return pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2);
}
```

#### JavaScript
```javascript
function kCenters(points, K) {
    // Initialize K centers
    let centers = [];
    for (let i = 0; i < K; i++) {
        centers.push([Math.floor(Math.random() * 100), Math.floor(Math.random() * 100)]);
    }

    while (true) {
        // Cluster assignment
        let clusterAssignment = {};
        for (const point of points) {
            let minDistance = Infinity;
            let nearestCenterIndex = null;
            for (let i = 0; i < K; i++) {
                let distance = Math.sqrt(Math.pow(point[0] - centers[i][0], 2) + Math.pow(point[1] - centers[i][1], 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestCenterIndex = i;
                }
            }
            clusterAssignment[point.join(",")] = nearestCenterIndex;
        }

        // Re-centering
        let newCenters = [];
        for (let i = 0; i < K; i++) {
            let sumX = 0, sumY = 0, count = 0;
            for (const [key, value] of Object.entries(clusterAssignment)) {
                if (value === i) {
                    const [x, y] = key.split(",").map(Number);
                    sumX += x;
                    sumY += y;
                    count++;
                }
            }
            newCenters.push([sumX / count, sumY / count]);
        }
        centers = newCenters;

        // Check for convergence
        let converged = true;
        for (let i = 0; i < K; i++) {
            if (!equal(centers[i], newCenters[i])) {
                converged = false;
                break;
            }
        }
        if (converged) {
            break;
        }
    }

    return centers.map(point => point.slice());
}

function equal(a, b) {
    return a.every((v, i) => v === b[i]);
}
```

This algorithm is used to find the optimal placement of K centers in the plane such that the maximum distance from any data point to its closest center is minimized.