---
id: "714247"
title: "BST Maximum Difference"
slug: "bst-maximum-difference--170647"
difficulty: "Medium"
companyTags: []
tags: ["DFS", "Binary Search Tree", "Data Structures", "Algorithms"]
---

**BST Maximum Difference**
=====================

## Summary
Given a Binary Search Tree (BST), find the maximum difference between the values of two nodes in the tree. The BST is defined as follows: every node has a value, and for each node, all its left child's values are less than the node's value, while all its right child's values are greater than the node's value.

## Detailed Explanation
The problem can be solved by performing an In-Order Traversal of the BST. The maximum difference will occur when the largest node in the tree is paired with the smallest node. This pair can be found during the traversal by keeping track of the minimum and maximum values seen so far. The time complexity for this algorithm is O(n), where n is the number of nodes in the tree, since we need to visit each node once.

Here's a step-by-step breakdown:

1. Initialize variables to keep track of the minimum and maximum values seen so far: `minVal` and `maxVal`.
2. Perform an In-Order Traversal of the BST:
	* For each node, update `minVal` if the node's value is smaller than the current `minVal`.
	* Update `maxVal` if the node's value is larger than the current `maxVal`.
3. The maximum difference between two nodes in the tree is the difference between the current `maxVal` and `minVal`.

Time complexity: O(n)
Space complexity: O(1)

## Optimized Solutions
### Java
```java
public class BSTMaximumDifference {
    public int maxDifference(Node root) {
        if (root == null) return 0;
        
        int minVal = Integer.MAX_VALUE;
        int maxVal = Integer.MIN_VALUE;
        maxDifferenceHelper(root, ref(minVal), ref(maxVal));
        return maxVal - minVal;
    }
    
    private void maxDifferenceHelper(Node node, Ref<Integer> minVal, Ref<Integer> maxVal) {
        if (node == null) return;
        
        maxDifferenceHelper(node.left, minVal, maxVal);
        *minVal = Math.min(*minVal, node.val);
        *maxVal = Math.max(*maxVal, node.val);
        maxDifferenceHelper(node.right, minVal, maxVal);
    }
}
```

### Python
```python
class BSTMaximumDifference:
    def max_difference(self, root):
        if not root: return 0
        
        min_val = float('inf')
        max_val = float('-inf')
        self.max_difference_helper(root, ref(min_val), ref(max_val))
        return max_val - min_val

    def max_difference_helper(self, node, min_val, max_val):
        if not node:
            return
        self.max_difference_helper(node.left, min_val, max_val)
        min_val[0] = min(min_val[0], node.val)
        max_val[0] = max(max_val[0], node.val)
        self.max_difference_helper(node.right, min_val, max_val)
```

### C++
```cpp
class BSTMaximumDifference {
public:
    int maxDifference(Node* root) {
        if (root == nullptr) return 0;
        
        int minVal = INT_MAX;
        int maxVal = INT_MIN;
        maxDifferenceHelper(root, &minVal, &maxVal);
        return maxVal - minVal;
    }
    
    void maxDifferenceHelper(Node* node, int* minVal, int* maxVal) {
        if (node == nullptr) return;
        
        maxDifferenceHelper(node->left, minVal, maxVal);
        *minVal = std::min(*minVal, node->val);
        *maxVal = std::max(*maxVal, node->val);
        maxDifferenceHelper(node->right, minVal, maxVal);
    }
};
```

### JavaScript
```javascript
class BSTMaximumDifference {
  maxDifference(root) {
    if (!root) return 0;
    
    let minVal = Infinity;
    let maxVal = -Infinity;
    this.maxDifferenceHelper(root, ref(minVal), ref(maxVal));
    return maxVal - minVal;
  }
  
  maxDifferenceHelper(node, minVal, maxVal) {
    if (!node) return;
    this.maxDifferenceHelper(node.left, minVal, maxVal);
    minVal = Math.min(minVal, node.val);
    maxVal = Math.max(maxVal, node.val);
    this.maxDifferenceHelper(node.right, minVal, maxVal);
  }
}
```

Note: The `ref` function is used to pass variables by reference in the Java and JavaScript solutions.