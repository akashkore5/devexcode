---
id: "881859"
title: "Lexicographically Smallest String"
slug: "lexicographically-smallest-string--151951"
difficulty: "Easy"
companyTags: []
tags: ["Misc", "STL"]
---

**Lexicographically Smallest String**
=============================

### Summary
Given a set of strings, find the lexicographically smallest string. The problem involves comparing strings based on their alphabetical order.

## Detailed Explanation
The problem can be solved by sorting the given strings in lexicographical order (i.e., alphabetically) and then returning the first string from the sorted list. This approach ensures that the returned string is the smallest in lexicographical order.

Here's a step-by-step breakdown of the solution:

1.  Initialize an empty priority queue.
2.  Iterate over each string in the input set.
3.  For each string, insert it into the priority queue as a comparison object (e.g., a custom comparator can be used for strings).
4.  Extract the smallest string from the priority queue and return it.

The time complexity of this solution is O(n log n) due to sorting, where n is the number of input strings. The space complexity is O(n) for storing the priority queue.

### Optimized Solutions

#### Java
```java
import java.util.PriorityQueue;
import java.util.Comparator;

public class Main {
    public static String findSmallestString(String[] strArray) {
        PriorityQueue<String> queue = new PriorityQueue<>(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.compareTo(s2);
            }
        });

        for (String str : strArray) {
            queue.add(str);
        }

        return queue.poll();
    }
}
```

#### Python
```python
def find_smallest_string(string_list):
    import heapq

    pq = []

    for string in string_list:
        heapq.heappush(pq, string)

    return heapq.heappop(pq)
```

#### C++
```cpp
#include <queue>
#include <string>

std::string findSmallestString(const std::vector<std::string>& strArray) {
    std::priority_queue<std::string> queue;

    for (const auto& str : strArray) {
        queue.push(str);
    }

    return queue.top();
}
```

#### JavaScript
```javascript
function findSmallestString(stringArray) {
    let pq = [];

    for (let string of stringArray) {
        pq.push(string);
    }

    pq.sort((a, b) => a.localeCompare(b));

    return pq[0];
}
```

Note: In the JavaScript solution, we use the `localeCompare()` method to compare strings in lexicographical order. The time complexity is O(n log n) due to sorting, and the space complexity is O(n) for storing the priority queue or sorted array.