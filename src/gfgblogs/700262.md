---
id: "700262"
title: "Almost Prime Numbers"
slug: "almost-prime-numbers"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Prime Number", "Data Structures"]
---

Here is the generated Markdown blog post for the "Almost Prime Numbers" problem:

**Almost Prime Numbers**
=====================

### Summary

This problem involves identifying almost prime numbers within a given range. An almost prime number is a number that has only two distinct prime factors. This problem requires an understanding of prime numbers and their properties.

### Detailed Explanation

To solve this problem, we can start by iterating through the given range of numbers. For each number, we need to check if it's prime or not. If the number is prime, then we need to find its prime factors. If a prime number has more than two distinct prime factors, it's not an almost prime number.

Here's a step-by-step breakdown of the solution:

1. Start by iterating through the given range of numbers.
2. For each number, check if it's prime or not. You can use the Sieve of Eratosthenes algorithm to efficiently check for primality.
3. If the number is prime, then find its prime factors using a similar approach as in step 2.
4. Count the distinct prime factors. If there are more than two, the number is not an almost prime number.

Here's a simple ASCII art diagram illustrating this process:
```
          +---------------+
          | Iterate through |
          |   range of numbers |
          +---------------+
                  |
                  v
+---------------------------------------+
|  Check if each number is prime?      |
|  (Use Sieve of Eratosthenes)         |
+---------------------------------------+
                  |
                  v
+---------------------------------------+
|  If prime, find its prime factors?   |
|  (Similar to step 2)              |
+---------------------------------------+
                  |
                  v
+---------------------------------------+
|  Count distinct prime factors?      |
|  (If more than two, not almost prime)|
+---------------------------------------+
```

Time complexity: O(n log log n) for the Sieve of Eratosthenes algorithm and O(sqrt(p)) for finding prime factors. Space complexity: O(n) for storing the sieve.

### Optimized Solutions

#### Java
```java
public class AlmostPrime {
    public static List<Integer> findAlmostPrimes(int start, int end) {
        List<Integer> almostPrimes = new ArrayList<>();
        boolean[] isPrime = new boolean[end + 1];
        
        // Initialize sieve
        for (int i = 2; i * i <= end; i++) {
            if (!isPrime[i]) {
                for (int j = i * i; j <= end; j += i) {
                    isPrime[j] = true;
                }
            }
        }
        
        // Find almost primes
        for (int i = start; i <= end; i++) {
            if (!isPrime[i]) {
                int factors = 0;
                for (int j = 2; j * j <= i; j++) {
                    if (i % j == 0) {
                        factors++;
                        while (i % j == 0) {
                            i /= j;
                        }
                    }
                }
                if (factors <= 2) {
                    almostPrimes.add(i);
                }
            }
        }
        
        return almostPrimes;
    }
}
```

#### Python
```python
def find_almost_primes(start, end):
    is_prime = [True] * (end + 1)
    
    # Initialize sieve
    for i in range(2, int(end ** 0.5) + 1):
        if not is_prime[i]:
            for j in range(i * i, end + 1, i):
                is_prime[j] = False
    
    # Find almost primes
    almost_primes = []
    for i in range(start, end + 1):
        if not is_prime[i]:
            factors = 0
            for j in range(2, int(i ** 0.5) + 1):
                if i % j == 0:
                    factors += 1
                    while i % j == 0:
                        i //= j
            if factors <= 2:
                almost_primes.append(i)
    
    return almost_primes
```

#### C++
```cpp
#include <vector>
#include <cmath>

std::vector<int> findAlmostPrimes(int start, int end) {
    std::vector<bool> isPrime(end + 1, true);
    
    // Initialize sieve
    for (int i = 2; i * i <= end; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= end; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    // Find almost primes
    std::vector<int> almostPrimes;
    for (int i = start; i <= end; i++) {
        if (!isPrime[i]) {
            int factors = 0;
            for (int j = 2; j * j <= i; j++) {
                if (i % j == 0) {
                    factors++;
                    while (i % j == 0) {
                        i /= j;
                    }
                }
            }
            if (factors <= 2) {
                almostPrimes.push_back(i);
            }
        }
    }
    
    return almostPrimes;
}
```

#### JavaScript
```javascript
function findAlmostPrimes(start, end) {
    const isPrime = new Array(end + 1).fill(true);
    
    // Initialize sieve
    for (let i = 2; i * i <= end; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j <= end; j += i) {
                isPrime[j] = false;
            }
        }
    }
    
    // Find almost primes
    const almostPrimes = [];
    for (let i = start; i <= end; i++) {
        if (!isPrime[i]) {
            let factors = 0;
            for (let j = 2; j * j <= i; j++) {
                if (i % j == 0) {
                    factors++;
                    while (i % j == 0) {
                        i /= j;
                    }
                }
            }
            if (factors <= 2) {
                almostPrimes.push(i);
            }
        }
    }
    
    return almostPrimes;
}
```