---
id: "710349"
title: "Partition a set into two subsets such that the difference of subset sums is minimum (Set-2)"
slug: "partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum-set-2"
difficulty: "Hard"
companyTags: []
tags: []
---

**Partition a set into two subsets such that the difference of subset sums is minimum (Set-2)**
===========================================================

## Summary
Given a set of integers, partition it into two subsets such that the absolute difference between their sums is minimized. This problem involves dynamic programming and requires finding an optimal solution by considering all possible subsets.

## Detailed Explanation
The given problem can be solved using dynamic programming. We will use a 2D array dp where dp[i][j] represents whether we can partition the first i elements into two sets such that their sum difference is j. Initially, we set all values of dp to false because it's not possible to partition an empty set.

Now, for each element in the set, if the current element is less than or equal to j, we update dp[i][j] to true if either:

* The left half (i.e., elements from 0 to i-1) can be partitioned into two sets with a sum difference of j - a[i], and
* The right half (i.e., elements from i+1 to n-1) can be partitioned into two sets with a sum difference of a[i]

Here's the step-by-step breakdown:

1. Initialize dp as a 2D array where dp[i][j] = false for all i, j.
2. Iterate through each element in the set from left to right:
   * If the current element is less than or equal to j:
     + Update dp[i][j] to true if either:
       - The left half (i.e., elements from 0 to i-1) can be partitioned into two sets with a sum difference of j - a[i], and
       - The right half (i.e., elements from i+1 to n-1) can be partitioned into two sets with a sum difference of a[i]
3. Find the minimum absolute difference between any pair of sums.

Time complexity: O(n \* S), where n is the number of elements and S is the maximum value in the set.
Space complexity: O(n \* S).

## Optimized Solutions
### Java
```java
public class Solution {
    public int minDiff(int[] a) {
        int n = a.length;
        int[] sum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + a[i];
        }
        
        int[][] dp = new int[n][sum[n]];
        dp[0][0] = true;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= sum[n]; j++) {
                if (a[i] <= j) {
                    dp[i][j] = dp[i - 1][j - a[i]] || dp[i - 1][j];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        
        int minDiff = Integer.MAX_VALUE;
        for (int j = sum[n] / 2; j >= 0; j--) {
            if (dp[n - 1][sum[n] - j]) {
                minDiff = Math.min(minDiff, sum[n] - j);
                break;
            }
        }
        
        return minDiff;
    }
}
```

### Python
```python
def min_diff(a):
    n = len(a)
    sum_a = [0] * (n + 1)
    for i in range(n):
        sum_a[i + 1] = sum_a[i] + a[i]
    
    dp = [[False] * (sum_a[n]) for _ in range(n)]
    dp[0][0] = True
    for i in range(1, n):
        for j in range(sum_a[n]):
            if a[i] <= j:
                dp[i][j] = (dp[i - 1][j - a[i]] or dp[i - 1][j])
            else:
                dp[i][j] = dp[i - 1][j]
    
    min_diff = float('inf')
    for j in range(sum_a[n] // 2, -1, -1):
        if dp[n - 1][sum_a[n] - j]:
            min_diff = min(min_diff, sum_a[n] - j)
            break
    
    return min_diff
```

### C++
```cpp
#include <vector>
using namespace std;

int minDiff(vector<int>& a) {
    int n = a.size();
    vector<int> sum(n + 1, 0);
    for (int i = 0; i < n; i++) {
        sum[i + 1] = sum[i] + a[i];
    }
    
    vector<vector<bool>> dp(n, vector<bool>(sum[n], false));
    dp[0][0] = true;
    for (int i = 1; i < n; i++) {
        for (int j = 0; j <= sum[n]; j++) {
            if (a[i] <= j) {
                dp[i][j] = dp[i - 1][j - a[i]] || dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    
    int minDiff = INT_MAX;
    for (int j = sum[n] / 2; j >= 0; j--) {
        if (dp[n - 1][sum[n] - j]) {
            minDiff = min(minDiff, sum[n] - j);
            break;
        }
    }
    
    return minDiff;
}
```

### JavaScript
```javascript
function minDiff(a) {
    let n = a.length;
    let sum = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        sum[i + 1] = sum[i] + a[i];
    }
    
    let dp = new Array(n).fill().map(() => new Array(sum[n]).fill(false));
    dp[0][0] = true;
    for (let i = 1; i < n; i++) {
        for (let j = 0; j <= sum[n]; j++) {
            if (a[i] <= j) {
                dp[i][j] = dp[i - 1][j - a[i]] || dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    
    let minDiff = Infinity;
    for (let j = sum[n] / 2; j >= 0; j--) {
        if (dp[n - 1][sum[n] - j]) {
            minDiff = Math.min(minDiff, sum[n] - j);
            break;
        }
    }
    
    return minDiff;
}
```