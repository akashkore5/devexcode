---
id: "700696"
title: "Tilt of Binary Tree"
slug: "tilt-of-binary-tree"
difficulty: "Easy"
companyTags: []
tags: ["Tree", "Data Structures"]
---

**Tilt of Binary Tree**
=====================

**Slug**: tilt-of-binary-tree
**Difficulty**: Easy
**Id**: 700696
**Topic Tags**: Tree, Data Structures
**Company Tags**: None

## Summary
The Tilt of Binary Tree problem involves calculating the total absolute difference between left and right children of each node in a binary tree. This difference is known as the tilt of each node.

Given a binary tree, we need to calculate the total tilt of all nodes in the tree. The tilt of a node is defined as the absolute difference between its left child's value and its right child's value.

## Detailed Explanation
To solve this problem, we will perform an in-order traversal of the binary tree. This traversal allows us to visit all the nodes in the tree while maintaining the correct order (left-root-right).

Here's a step-by-step breakdown of the solution:

1. Start at the root node.
2. Traverse left subtree recursively until you reach a leaf node or the left child is null.
3. At each node, calculate the tilt by subtracting the value of the right child from the value of the left child.
4. Add this tilt to the total tilt.
5. Repeat steps 1-4 for all nodes in the tree.

Time complexity: O(n), where n is the number of nodes in the tree.
Space complexity: O(h), where h is the height of the tree (in case of a skewed tree).

## Optimized Solutions

### Java
```java
class Solution {
    int sum = 0;
    public int findTilt(TreeNode root) {
        helper(root);
        return sum;
    }
    
    private void helper(TreeNode node) {
        if (node == null) {
            return;
        }
        
        int leftSum = getSum(node.left);
        int rightSum = getSum(node.right);
        sum += Math.abs(leftSum - rightSum);
        
        helper(node.left);
        helper(node.right);
    }
    
    private int getSum(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        return node.val + getSum(node.left) + getSum(node.right);
    }
}
```

### Python
```python
class Solution:
    def findTilt(self, root):
        self.sum = 0
        self.helper(root)
        return self.sum
    
    def helper(self, node):
        if not node:
            return
        
        left_sum = self.get_sum(node.left)
        right_sum = self.get_sum(node.right)
        self.sum += abs(left_sum - right_sum)
        
        self.helper(node.left)
        self.helper(node.right)
    
    def get_sum(self, node):
        if not node:
            return 0
        
        return node.val + self.get_sum(node.left) + self.get_sum(node.right)
```

### C++
```cpp
class Solution {
public:
    int findTilt(TreeNode* root) {
        sum = 0;
        helper(root);
        return sum;
    }
    
private:
    void helper(TreeNode* node) {
        if (!node) {
            return;
        }
        
        int leftSum = get_sum(node->left);
        int rightSum = get_sum(node->right);
        sum += abs(leftSum - rightSum);
        
        helper(node->left);
        helper(node->right);
    }
    
    int get_sum(TreeNode* node) {
        if (!node) {
            return 0;
        }
        
        return node->val + get_sum(node->left) + get_sum(node->right);
    }
};
```

### JavaScript
```javascript
class Solution {
    findTilt(root) {
        this.sum = 0;
        this.helper(root);
        return this.sum;
    }
    
    helper(node) {
        if (!node) {
            return;
        }
        
        const leftSum = this.get_sum(node.left);
        const rightSum = this.get_sum(node.right);
        this.sum += Math.abs(leftSum - rightSum);
        
        this.helper(node.left);
        this.helper(node.right);
    }
    
    get_sum(node) {
        if (!node) {
            return 0;
        }
        
        return node.val + this.get_sum(node.left) + this.get_sum(node.right);
    }
}
```