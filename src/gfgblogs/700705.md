---
id: "700705"
title: "Rotate doubly Linked List"
slug: "rotate-doubly-linked-list-by-p-nodes"
difficulty: "Easy"
companyTags: []
tags: ["doubly-linked-list", "Linked List", "Data Structures"]
---

# Rotate Doubly Linked List by P Nodes
## Summary
Given a doubly linked list and an integer `p`, rotate the list to the right by `p` nodes. This problem involves manipulating a doubly linked list, where each node has references to both the previous (`prev`) and next (`next`) nodes.

## Detailed Explanation
To solve this problem, we'll follow these steps:

1. Initialize three pointers: `current`, `prev_node`, and `new_tail`. Set `current` to the head of the list.
2. Move `current` `p` nodes to the right. If `p` is greater than the length of the list, move `p % length` nodes to the right (since rotating by the full length of the list is equivalent to not rotating at all).
3. Update `prev_node` and `new_tail` accordingly:
	* Set `prev_node` to the node before `current`.
	* Set `new_tail` to the node after `current`.
4. Update the `next` pointer of `prev_node` to point to `new_tail`. This effectively moves the tail of the list to the right by `p` nodes.
5. Update the `prev` pointer of `new_tail` to point to `prev_node`. This sets the new head of the rotated list.

Here's a diagram illustrating the steps:
```
       +----+      +----+      +----+
       |  A  |     |  B  |     |  C  |
       +----+      +----+      +----+
           ^          ^          ^
           |          |          |
       +----+      +----+      +----+
       | prev_node |     | current |     | new_tail |
       +----+      +----+      +----+
```
In the diagram, `A` is the original head of the list, and `C` is the original tail. The rotation moves the tail to the right by 2 nodes.

Time complexity: O(n), where n is the length of the list.
Space complexity: O(1), as we only use a few extra pointers.

## Optimized Solutions

### Java
```java
public class DoublyLinkedList {
    public void rotate(int p) {
        if (head == null || head.next == null) return;

        Node current = head;
        for (int i = 0; i < p && current.next != null; i++) {
            current = current.next;
        }
        Node newTail = current;
        while (newTail.next != null) {
            newTail = newTail.next;
        }
        newTail.next = head;
        head.prev = newTail;
    }
}
```

### Python
```python
class DoublyLinkedList:
    def rotate(self, p):
        if not self.head or not self.head.next: return

        current = self.head
        for _ in range(p):
            if not current.next: break
            current = current.next
        new_tail = current
        while new_tail.next:
            new_tail = new_tail.next
        new_tail.next = self.head
        self.head.prev = new_tail
```

### C++
```cpp
class DoublyLinkedList {
public:
    void rotate(int p) {
        if (head == nullptr || head->next == nullptr) return;

        Node* current = &head;
        for (int i = 0; i < p && current->next != nullptr; i++) {
            current = current->next;
        }
        Node* new_tail = current;
        while (new_tail->next != nullptr) {
            new_tail = new_tail->next;
        }
        new_tail->next = head;
        head->prev = new_tail;
    }
};
```

### JavaScript
```javascript
class DoublyLinkedList {
  rotate(p) {
    if (!this.head || !this.head.next) return;

    let current = this.head;
    for (let i = 0; i < p && current.next; i++) {
      current = current.next;
    }
    const newTail = current;
    while (newTail.next) {
      newTail = newTail.next;
    }
    newTail.next = this.head;
    this.head.prev = newTail;
  }
}
```