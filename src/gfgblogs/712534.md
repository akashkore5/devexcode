---
id: "712534"
title: "Introduction to Doubly Linked List"
slug: "introduction-to-doubly-linked-list"
difficulty: "Easy"
companyTags: []
tags: []
---

Here is the Markdown blog post for the "Introduction to Doubly Linked List" problem:

# Introduction to Doubly Linked List
## Summary
Given a doubly linked list, write an algorithm to insert a new node at the beginning and end of the list. The key concepts involved are doubly linked lists, nodes, and pointers.

## Detailed Explanation

### Insertion at Beginning

To insert a new node at the beginning of the list, we first create a new node with the given data. Then, we update the `prev` pointer of the current head node to point to the new node. Finally, we set the `next` pointer of the new node to the current head node and update the head node to point to the new node.

### Insertion at End

To insert a new node at the end of the list, we first find the last node in the list by traversing from the head node until we reach a node with `next` pointer set to `NULL`. Then, we create a new node and update its `prev` and `next` pointers. The `prev` pointer is set to point to the last node, and the `next` pointer is set to `NULL`.

### Step-by-Step Breakdown

Here's a step-by-step breakdown of the solution:

1. Create a new node with the given data.
2. Update the `prev` pointer of the current head node to point to the new node (insertion at beginning).
3. Set the `next` pointer of the new node to the current head node (insertion at beginning).
4. Update the head node to point to the new node (insertion at beginning).
5. Find the last node in the list by traversing from the head node until we reach a node with `next` pointer set to `NULL`.
6. Create a new node and update its `prev` and `next` pointers.
7. Set the `prev` pointer of the new node to point to the last node (insertion at end).
8. Set the `next` pointer of the new node to `NULL` (insertion at end).

### Time Complexity Analysis

The time complexity for both insertion operations is O(1) because we only need to update a few pointers.

### Space Complexity Analysis

The space complexity is O(1) because we are not using any additional space that scales with the input size.

## Optimized Solutions
#### Java
```java
public class DoublyLinkedList {
    public void insertAtBeginning(int data) {
        Node newNode = new Node(data);
        if (head == null) {
            head = tail = newNode;
        } else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
        }
    }

    public void insertAtEnd(int data) {
        Node newNode = new Node(data);
        if (tail == null) {
            head = tail = newNode;
        } else {
            newNode.prev = tail;
            tail.next = newNode;
            tail = newNode;
        }
    }
}
```
#### Python
```python
class DoublyLinkedList:
    def insert_at_beginning(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

    def insert_at_end(self, data):
        new_node = Node(data)
        if self.tail is None:
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
```
#### C++
```cpp
class DoublyLinkedList {
public:
    void insertAtBeginning(int data) {
        Node* newNode = new Node(data);
        if (head == nullptr) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
    }

    void insertAtEnd(int data) {
        Node* newNode = new Node(data);
        if (tail == nullptr) {
            head = tail = newNode;
        } else {
            newNode->prev = tail;
            tail->next = newNode;
            tail = newNode;
        }
    }
};
```
#### JavaScript
```javascript
class DoublyLinkedList {
    insertAtBeginning(data) {
        const newNode = new Node(data);
        if (this.head === null) {
            this.head = this.tail = newNode;
        } else {
            newNode.next = this.head;
            this.head.prev = newNode;
            this.head = newNode;
        }
    }

    insertAtEnd(data) {
        const newNode = new Node(data);
        if (this.tail === null) {
            this.head = this.tail = newNode;
        } else {
            newNode.prev = this.tail;
            this.tail.next = newNode;
            this.tail = newNode;
        }
    }
}
```
Note: The above solutions assume that the `Node` class has been implemented to represent a node in the doubly linked list.