---
id: "713973"
title: "Reverse both parts"
slug: "reverse-both-parts--170647"
difficulty: "Easy"
companyTags: []
tags: ["Linked List", "Data Structures"]
---

**Reverse both parts**
=====================================



## Summary
Given a linked list, reverse the first half and then the second half. This problem involves understanding how to manipulate a linked list and reversing it.

## Detailed Explanation
To solve this problem, we'll divide the linked list into two halves - the first half and the second half. Then, we'll reverse each of these halves separately.

Here's a step-by-step breakdown:

1. **Find the middle of the linked list**: Traverse the linked list until you reach its middle. This can be done by counting the number of nodes or using a fast-slow pointer approach.
2. **Reverse the first half**: Traverse the linked list from the head to the middle node, reversing each node as you go. You'll need to update the `next` pointers accordingly.
3. **Reverse the second half**: Traverse the linked list from the middle node to the end, reversing each node as you go. Again, update the `next` pointers correctly.
4. **Combine the two reversed halves**: Set the new head of the reversed linked list to be the first node of the reversed first half. The rest of the nodes will follow in reverse order.

Time complexity: O(n), where n is the number of nodes in the linked list. This is because we're traversing the linked list twice.
Space complexity: O(1), as we're only using a constant amount of space to store our pointers and variables.

## Optimized Solutions
### Java
```java
public class LinkedList {
    public Node reverseBothParts(Node head) {
        if (head == null || head.next == null) return head;

        // Find the middle node
        Node slow = head;
        Node fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Reverse the first half
        Node prev = null;
        Node curr = head;
        while (curr != slow) {
            Node nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }

        // Reverse the second half
        prev = null;
        curr = slow;
        while (curr.next != null) {
            Node nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }

        // Combine the two reversed halves
        head = prev;
        return head;
    }
}
```

### Python
```python
class LinkedList:
    def reverse_both_parts(self, head):
        if head is None or head.next is None: 
            return head

        # Find the middle node
        slow = head
        fast = head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next

        # Reverse the first half
        prev = None
        curr = head
        while curr != slow:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp

        # Reverse the second half
        prev = None
        curr = slow
        while curr.next:
            next_temp = curr.next
            curr.next = prev
            prev = curr
            curr = next_temp

        # Combine the two reversed halves
        head = prev
        return head
```

### C++
```cpp
class LinkedList {
public:
    Node* reverseBothParts(Node* head) {
        if (head == nullptr || head->next == nullptr) 
            return head;

        // Find the middle node
        Node* slow = head;
        Node* fast = head;
        while (fast->next && fast->next->next) {
            slow = slow->next;
            fast = fast->next->next;
        }

        // Reverse the first half
        Node* prev = nullptr;
        Node* curr = head;
        while (curr != slow) {
            Node* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }

        // Reverse the second half
        prev = nullptr;
        curr = slow;
        while (curr->next) {
            Node* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }

        // Combine the two reversed halves
        head = prev;
        return head;
    }
};
```

### JavaScript
```javascript
class LinkedList {
  reverseBothParts(head) {
    if (head === null || head.next === null) 
      return head;

    // Find the middle node
    let slow = head;
    let fast = head;
    while (fast.next && fast.next.next) {
      slow = slow.next;
      fast = fast.next.next;
    }

    // Reverse the first half
    let prev = null;
    let curr = head;
    while (curr !== slow) {
      let nextTemp = curr.next;
      curr.next = prev;
      prev = curr;
      curr = nextTemp;
    }

    // Reverse the second half
    prev = null;
    curr = slow;
    while (curr.next) {
      let nextTemp = curr.next;
      curr.next = prev;
      prev = curr;
      curr = nextTemp;
    }

    // Combine the two reversed halves
    head = prev;
    return head;
  }
}
```
Note that these solutions assume a basic understanding of linked lists and reversal algorithms.