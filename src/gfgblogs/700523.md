---
id: "700523"
title: "Merge Sort for Linked List"
slug: "sort-a-linked-list"
difficulty: "Medium"
companyTags: ["Paytm", "Accolite", "Amazon", "Microsoft", "MAQ Software", "Adobe", "Veritas"]
tags: ["Linked List", "Sorting", "Merge Sort", "Data Structures", "Algorithms"]
---

**Sort a Linked List**
=====================



### Summary

In this problem, we are given a linked list and asked to sort it using the merge sort algorithm. This is a medium-level difficulty problem that requires understanding of both linked lists and the merge sort algorithm.

### Detailed Explanation

To solve this problem, we will use the merge sort algorithm, which is a divide-and-conquer approach. The idea behind merge sort is to divide the list into smaller sublists until each sublist contains only one element (in other words, they are sorted), then combine these sorted sublists back together to form the final sorted list.

Here's how it works:

1. If the linked list has one or zero elements, return the original list because it's already sorted.
2. Split the linked list into two halves of roughly equal length (or the remaining half if the size is odd).
3. Recursively apply step 1 to each half until you have lists of size 1 (which are already sorted).
4. Merge the sorted halves back together, maintaining the correct order.

Here's an ASCII art diagram illustrating this process:

```
          +----------------+
          |  5 -> 2 -> 8 -> 3 |
          +----------------+
                  |
                  v
+---------------+       +---------------+
|  2 -> 1      |       |  3 -> 4 -> 6  |
+---------------+       +---------------+
                  |
                  v
+---------------+       +---------------+
|  1             |       |  4             |
|  (sorted)    |       |  (sorted)    |
+---------------+       +---------------+
```

In this example, we start with a list of five elements. We split it into two halves: `2 -> 1` and `3 -> 4 -> 6`. We then recursively apply the same process to each half until we have lists of size 1. Finally, we merge these sorted halves back together to form the final sorted list.

The time complexity of this algorithm is O(n log n), where n is the number of elements in the linked list. The space complexity is O(n) due to the recursive function calls and temporary arrays used during the merging process.

### Optimized Solutions

#### Java
```java
public class LinkedList {
    public static Node mergeSort(Node head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        Node mid = getMiddle(head);
        Node nextToMid = mid.next;
        mid.next = null;
        
        Node left = mergeSort(head);
        Node right = mergeSort(nextToMid);
        
        return merge(left, right);
    }
    
    public static Node getMiddle(Node head) {
        if (head == null) {
            return head;
        }
        
        Node slow = head;
        Node fast = head;
        
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        return slow;
    }
    
    public static Node merge(Node a, Node b) {
        if (a == null) {
            return b;
        } else if (b == null) {
            return a;
        }
        
        if (a.data <= b.data) {
            a.next = merge(a.next, b);
            return a;
        } else {
            b.next = merge(a, b.next);
            return b;
        }
    }
}
```

#### Python
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def merge_sort(head):
    if head is None or head.next is None:
        return head
    
    mid = get_middle(head)
    next_to_mid = mid.next
    mid.next = None
    
    left = merge_sort(head)
    right = merge_sort(next_to_mid)
    
    return merge(left, right)

def get_middle(head):
    if head is None:
        return head
    
    slow = head
    fast = head
    
    while fast.next is not None and fast.next.next is not None:
        slow = slow.next
        fast = fast.next.next
    
    return slow

def merge(a, b):
    if a is None:
        return b
    elif b is None:
        return a
    
    if a.data <= b.data:
        a.next = merge(a.next, b)
        return a
    else:
        b.next = merge(a, b.next)
        return b
```

#### C++
```cpp
class Node {
public:
    int data;
    Node* next;

    Node(int x) : data(x), next(NULL) {}
};

Node* mergeSort(Node* head) {
    if (head == NULL || head->next == NULL) {
        return head;
    }

    Node* mid = getMiddle(head);
    Node* nextToMid = mid->next;
    mid->next = NULL;

    Node* left = mergeSort(head);
    Node* right = mergeSort(nextToMid);

    return merge(left, right);
}

Node* getMiddle(Node* head) {
    if (head == NULL) {
        return head;
    }

    Node* slow = head;
    Node* fast = head;

    while (fast->next != NULL && fast->next->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;
}

Node* merge(Node* a, Node* b) {
    if (a == NULL) {
        return b;
    } else if (b == NULL) {
        return a;
    }

    if (a->data <= b->data) {
        a->next = merge(a->next, b);
        return a;
    } else {
        b->next = merge(a, b->next);
        return b;
    }
}
```

#### JavaScript
```javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

function mergeSort(head) {
  if (head === null || head.next === null) {
    return head;
  }

  let mid = getMiddle(head);
  let nextToMid = mid.next;
  mid.next = null;

  let left = mergeSort(head);
  let right = mergeSort(nextToMid);

  return merge(left, right);
}

function getMiddle(head) {
  if (head === null) {
    return head;
  }

  let slow = head;
  let fast = head;

  while (fast.next !== null && fast.next.next !== null) {
    slow = slow.next;
    fast = fast.next.next;
  }

  return slow;
}

function merge(a, b) {
  if (a === null) {
    return b;
  } else if (b === null) {
    return a;
  }

  if (a.data <= b.data) {
    a.next = merge(a.next, b);
    return a;
  } else {
    b.next = merge(a, b.next);
    return b;
  }
}
```

Note that these optimized solutions are in the form of class definitions for Java and C++, while Python and JavaScript use functions.