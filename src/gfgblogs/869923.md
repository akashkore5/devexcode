---
id: "869923"
title: "Largest Pair Sum"
slug: "pair-sum--120604"
difficulty: "Easy"
companyTags: []
tags: ["two-pointer-algorithm", "Arrays", "Searching"]
---

**Largest Pair Sum**
==================

### Slug: pair-sum--120604
### Difficulty: Easy
### Id: 869923
### Topic Tags: two-pointer-algorithm, Arrays, Searching
### Company Tags: None

## Summary
Given an array of integers, the task is to find the largest pair sum possible by choosing any two elements from the given array. This problem involves searching and sorting techniques.

## Detailed Explanation
To solve this problem, we can use a simple algorithm that iterates through the array once. We maintain two pointers, one at the start of the array and one at the end. At each step, we compare the values at these positions and update our pair sum accordingly.

Here's the step-by-step breakdown:

1. Initialize two pointers, `start` and `end`, to the first and last elements of the array respectively.
2. Compare the values at `start` and `end`.
3. If `start` is smaller than `end`, update `pair_sum` with the sum of these two values and move `start` one step forward.
4. If `end` is smaller than `start`, update `pair_sum` with the sum of these two values and move `end` one step backward.
5. Repeat steps 2-4 until `start` meets or crosses `end`.
6. The final value of `pair_sum` is the largest possible pair sum.

The time complexity of this algorithm is O(n), where n is the size of the input array, as we only need to iterate through the array once. The space complexity is O(1) since we're not using any additional space that scales with the input size.

## Optimized Solutions
### Java
```java
public int largestPairSum(int[] arr) {
    if (arr.length < 2) return -1; // edge case

    int start = 0, end = arr.length - 1;
    int pair_sum = Integer.MIN_VALUE;

    while (start <= end) {
        if (arr[start] > arr[end]) {
            pair_sum = Math.max(pair_sum, arr[start] + arr[end]);
            start++;
        } else {
            pair_sum = Math.max(pair_sum, arr[start] + arr[end]);
            end--;
        }
    }

    return pair_sum;
}
```

### Python
```python
def largest_pair_sum(arr):
    if len(arr) < 2:
        return -1  # edge case

    start, end = 0, len(arr) - 1
    pair_sum = float('-inf')

    while start <= end:
        if arr[start] > arr[end]:
            pair_sum = max(pair_sum, arr[start] + arr[end])
            start += 1
        else:
            pair_sum = max(pair_sum, arr[start] + arr[end])
            end -= 1

    return pair_sum
```

### C++
```cpp
int largestPairSum(int* arr, int n) {
    if (n < 2) return -1; // edge case

    int start = 0, end = n - 1;
    int pair_sum = INT_MIN;

    while (start <= end) {
        if (arr[start] > arr[end]) {
            pair_sum = std::max(pair_sum, arr[start] + arr[end]);
            start++;
        } else {
            pair_sum = std::max(pair_sum, arr[start] + arr[end]);
            end--;
        }
    }

    return pair_sum;
}
```

### JavaScript
```javascript
function largestPairSum(arr) {
  if (arr.length < 2) return -1; // edge case

  let start = 0, end = arr.length - 1;
  let pair_sum = Number.MIN_VALUE;

  while (start <= end) {
    if (arr[start] > arr[end]) {
      pair_sum = Math.max(pair_sum, arr[start] + arr[end]);
      start++;
    } else {
      pair_sum = Math.max(pair_sum, arr[start] + arr[end]);
      end--;
    }
  }

  return pair_sum;
}
```