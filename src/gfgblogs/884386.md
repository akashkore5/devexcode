---
id: "884386"
title: "Subarrays With At Most K Distinct Integers"
slug: "subarrays-with-at-most-k-distinct-integers"
difficulty: "Medium"
companyTags: []
tags: ["sliding-window", "Arrays", "Data Structures", "Algorithms"]
---

Here is the detailed Markdown blog post for the problem "Subarrays With At Most K Distinct Integers":

**Subarrays With At Most K Distinct Integers**
==================================================

### Summary
Given an array `nums` and an integer `k`, find the number of subarrays that have at most `k` distinct integers. A subarray is a contiguous part of the original array.

This problem involves arrays, data structures, and algorithms. The key concept is to use a sliding window approach to efficiently count the number of subarrays with at most `k` distinct integers.

### Detailed Explanation
We can solve this problem using a sliding window approach. Initialize two pointers, `left` and `right`, to the start of the array. Initialize a set `distinct` to store the distinct elements in the current window.

Step 1: Expand the window
Move the `right` pointer to the right until there are more than `k` distinct elements in the window. At each step, add the new element to the `distinct` set and update the size of the window.

Step 2: Shrink the window
When the number of distinct elements exceeds `k`, move the `left` pointer to the right and remove the leftmost element from the `distinct` set. Update the size of the window.

Step 3: Count subarrays
For each window, count the number of subarrays that have at most `k` distinct integers. This is done by considering all possible subarrays within the current window.

Time complexity: O(n), where n is the length of the array.
Space complexity: O(k), for storing the distinct elements in the set.

### Optimized Solutions
#### Java
```java
public int numSubarrayKDistinct(int[] nums, int k) {
    int left = 0, right = 0;
    Set<Integer> distinct = new HashSet<>();
    int count = 0;

    while (right < nums.length) {
        while (distinct.size() > k) {
            distinct.remove(nums[left]);
            left++;
        }
        if (distinct.size() <= k) {
            for (int i = left; i <= right; i++) {
                count += right - i + 1;
            }
        }
        distinct.add(nums[right]);
        right++;
    }

    return count;
}
```

#### Python
```python
def numSubarrayKDistinct(nums, k):
    left = 0
    right = 0
    distinct = set()
    count = 0

    while right < len(nums):
        while len(distinct) > k:
            distinct.remove(nums[left])
            left += 1
        if len(distinct) <= k:
            for i in range(left, right + 1):
                count += right - i + 1
        distinct.add(nums[right])
        right += 1

    return count
```

#### C++
```cpp
int numSubarrayKDistinct(vector<int>& nums, int k) {
    int left = 0, right = 0;
    unordered_set<int> distinct;
    int count = 0;

    while (right < nums.size()) {
        while (distinct.size() > k) {
            distinct.erase(nums[left]);
            left++;
        }
        if (distinct.size() <= k) {
            for (int i = left; i <= right; i++) {
                count += right - i + 1;
            }
        }
        distinct.insert(nums[right]);
        right++;
    }

    return count;
}
```

#### JavaScript
```javascript
function numSubarrayKDistinct(nums, k) {
    let left = 0;
    let right = 0;
    const distinct = new Set();
    let count = 0;

    while (right < nums.length) {
        while (distinct.size > k) {
            distinct.delete(nums[left]);
            left++;
        }
        if (distinct.size <= k) {
            for (let i = left; i <= right; i++) {
                count += right - i + 1;
            }
        }
        distinct.add(nums[right]);
        right++;
    }

    return count;
}
```

I hope this helps! Let me know if you have any questions or need further clarification.