---
id: "876441"
title: "Count Pairs whose sum is less than target"
slug: "count-pairs-whose-sum-is-less-than-target"
difficulty: "Easy"
companyTags: []
tags: ["Sorting", "two-pointer-algorithm", "Arrays"]
---

# Count Pairs whose sum is less than target
## Slug: count-pairs-whose-sum-is-less-than-target
## Difficulty: Easy
## Id: 876441
## Topic Tags: Sorting, two-pointer-algorithm, Arrays
## Company Tags: None

### Summary
Given an array of integers and a target value, find the number of pairs in the array whose sum is less than the target. The problem requires sorting the array, then using a two-pointer algorithm to efficiently count the desired pairs.

### Detailed Explanation
To solve this problem, we first sort the given array of integers. Then, we initialize two pointers, one at the start and another at the end of the array. We iterate through the array by moving the pointers towards each other based on the sum of the values they are pointing to. If the sum is less than or equal to the target, we increment a counter for each such pair found.

Here's a step-by-step breakdown of the solution:
1.  Sort the given array in ascending order.
2.  Initialize two pointers, `start` and `end`, at the start and end of the array respectively.
3.  Iterate through the array by moving the pointers towards each other based on the sum of the values they are pointing to.
4.  If the sum is less than or equal to the target, increment a counter for each such pair found.

Time complexity: O(n log n) due to sorting
Space complexity: O(1)

### Optimized Solutions

#### Java
```java
import java.util.Arrays;

public class Main {
    public static int countPairs(int[] arr, int target) {
        Arrays.sort(arr);
        int start = 0;
        int end = arr.length - 1;
        int count = 0;
        
        while (start < end) {
            if (arr[start] + arr[end] <= target) {
                count++;
                start++;
                end--;
            } else if (arr[start] + arr[end] > target) {
                end--;
            }
        }
        
        return count;
    }
}
```

#### Python
```python
def count_pairs(arr, target):
    arr.sort()
    start = 0
    end = len(arr) - 1
    count = 0
    
    while start < end:
        if arr[start] + arr[end] <= target:
            count += 1
            start += 1
            end -= 1
        elif arr[start] + arr[end] > target:
            end -= 1
    return count
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int countPairs(std::vector<int>& arr, int target) {
    std::sort(arr.begin(), arr.end());
    int start = 0;
    int end = arr.size() - 1;
    int count = 0;
    
    while (start < end) {
        if (arr[start] + arr[end] <= target) {
            count++;
            start++;
            end--;
        } else if (arr[start] + arr[end] > target) {
            end--;
        }
    }
    
    return count;
}

int main() {
    std::vector<int> arr = {1, 2, 3, 4, 5};
    int target = 7;
    std::cout << "Count of pairs whose sum is less than or equal to the target: " << countPairs(arr, target) << std::endl;
    return 0;
}
```

#### JavaScript
```javascript
function countPairs(arr, target) {
    arr.sort((a, b) => a - b);
    let start = 0;
    let end = arr.length - 1;
    let count = 0;
    
    while (start < end) {
        if (arr[start] + arr[end] <= target) {
            count++;
            start++;
            end--;
        } else if (arr[start] + arr[end] > target) {
            end--;
        }
    }
    
    return count;
}

console.log("Count of pairs whose sum is less than or equal to the target: " + countPairs([1, 2, 3, 4, 5], 7));
```

Note that these optimized solutions all have a time complexity of O(n log n) due to sorting and a space complexity of O(1), as required by the problem.