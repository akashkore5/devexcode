---
id: "711088"
title: "Shortest Distance in a Binary Maze"
slug: "shortest-path-in-a-binary-maze-1655453161"
difficulty: "Medium"
companyTags: []
tags: ["Matrix", "Graph", "BFS", "Data Structures", "Algorithms"]
---

**Shortest Distance in a Binary Maze**
=====================================================

## Summary
In this problem, we are given a binary maze represented as an adjacency matrix. The goal is to find the shortest distance between two cells in the maze. This problem involves graph traversal and optimization techniques.

## Detailed Explanation
To solve this problem, we can use Breadth-First Search (BFS) algorithm. BFS is particularly well-suited for finding the shortest path in a graph because it explores all the nodes at a given depth before moving on to the next level.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty queue and add the starting cell to it.
2. While the queue is not empty:
   - Dequeue the front cell and mark it as visited.
   - For each unvisited neighbor of the dequeued cell, calculate its distance from the starting cell and enqueue it if the calculated distance is less than the current shortest distance to that neighbor.
3. Once the queue is empty, return the shortest distance found for the target cell.

The time complexity of this algorithm is O(V + E), where V is the number of cells in the maze and E is the number of edges (neighbor relationships). The space complexity is also O(V) because we need to store the visited status of each cell.

## Optimized Solutions
Here are optimized solutions for the problem:

### Java
```java
import java.util.*;

public class ShortestDistanceInBinaryMaze {
    public static int shortestDistance(int[][] maze, int startRow, int startCol, int targetRow, int targetCol) {
        if (maze == null || maze.length == 0 || maze[0].length == 0)
            return -1;

        int rows = maze.length;
        int cols = maze[0].length;
        boolean[][] visited = new boolean[rows][cols];
        int[] directions = {-1, 0, 1, 0, 0, 1}; // up, left, down, right
        int queueSize = 0;
        int[] queue = new int[4 * (rows + cols)];
        int startCellIndex = startRow * cols + startCol;
        int targetCellIndex = targetRow * cols + targetCol;

        visited[startRow][startCol] = true;
        int level = 0, index = 0;
        queue[index++] = startCellIndex;
        queueSize++;

        while (queueSize > 0) {
            for (int i = 0; i < queueSize; i++) {
                int cellIndex = queue[i];
                if (cellIndex == targetCellIndex)
                    return level;

                int row = cellIndex / cols;
                int col = cellIndex % cols;

                for (int j = 0; j < 4; j++) {
                    int newRow = row + directions[j * 2];
                    int newCol = col + directions[j * 2 + 1];

                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols
                            && !visited[newRow][newCol] && maze[newRow][newCol] == 1) {
                        visited[newRow][newCol] = true;
                        queue[index++] = newRow * cols + newCol;
                        queueSize++;
                    }
                }

            }
            level++;
        }

        return -1; // target cell not found
    }
}
```

### Python
```python
def shortest_distance(maze, start_row, start_col, target_row, target_col):
    if not maze or len(maze) == 0 or len(maze[0]) == 0:
        return -1

    rows = len(maze)
    cols = len(maze[0])
    visited = [[False for _ in range(cols)] for _ in range(rows)]
    directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]  # right, left, up, down
    queue = []
    start_cell_index = start_row * cols + start_col
    target_cell_index = target_row * cols + target_col

    visited[start_row][start_col] = True
    level = 0
    while queue:
        for _ in range(len(queue)):
            cell_index = queue.pop(0)
            if cell_index == target_cell_index:
                return level

            row, col = divmod(cell_index, cols)

            for direction in directions:
                new_row, new_col = row + direction[0], col + direction[1]

                if (0 <= new_row < rows and 0 <= new_col < cols
                        and not visited[new_row][new_col] and maze[new_row][new_col]):
                    visited[new_row][new_col] = True
                    queue.append(new_row * cols + new_col)
        level += 1

    return -1  # target cell not found
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <utility>

using namespace std;

int shortestDistance(vector<vector<int>>& maze, int startRow, int startCol, int targetRow, int targetCol) {
    if (maze.empty() || maze[0].empty())
        return -1;

    int rows = maze.size();
    int cols = maze[0].size();
    vector<vector<bool>> visited(rows, vector<bool>(cols));
    vector<pair<int, int>> directions({{0, 1}, {0, -1}, {-1, 0}, {1, 0}}); // right, left, up, down
    queue<pair<int, int>> queue;
    pair<int, int> startCell = {startRow, startCol};
    pair<int, int> targetCell = {targetRow, targetCol};

    visited[startRow][startCol] = true;
    int level = 0;
    while (!queue.empty()) {
        for (int i = 0; i < queue.size(); ++i) {
            auto cell = queue.front();
            queue.pop();
            if (cell == targetCell)
                return level;

            int row = get<0>(cell);
            int col = get<1>(cell);

            for (auto& direction : directions) {
                int newRow = row + direction.first;
                int newCol = col + direction.second;

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols
                        && !visited[newRow][newCol] && maze[newRow][newCol]) {
                    visited[newRow][newCol] = true;
                    queue.push({newRow, newCol});
                }
            }

        }
        level++;
    }

    return -1; // target cell not found
}

```

### JavaScript
```javascript
function shortestDistance(maze, startRow, startCol, targetRow, targetCol) {
  if (!maze || maze.length === 0 || maze[0].length === 0)
    return -1;

  let rows = maze.length;
  let cols = maze[0].length;
  let visited = new Array(rows).fill(0).map(() => new Array(cols).fill(false));
  let directions = [[0, 1], [0, -1], [-1, 0], [1, 0]]; // right, left, up, down
  let queue = [];
  let startCellIndex = startRow * cols + startCol;
  let targetCellIndex = targetRow * cols + targetCol;

  visited[startRow][startCol] = true;
  let level = 0;
  while (queue.length > 0) {
    for (let i = 0; i < queue.length; ++i) {
      let cellIndex = queue.shift();
      if (cellIndex === targetCellIndex)
        return level;

      let row = Math.floor(cellIndex / cols);
      let col = cellIndex % cols;

      for (let direction of directions) {
        let newRow = row + direction[0];
        let newCol = col + direction[1];

        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols
            && !visited[newRow][newCol] && maze[newRow][newCol]) {
          visited[newRow][newCol] = true;
          queue.push(newRow * cols + newCol);
        }
      }

    }
    level++;
  }

  return -1; // target cell not found
}
```

This algorithm is used to find the shortest distance from a start point to a target point in a maze. The maze is represented as a 2D array where `0` represents an obstacle and `1` represents a passable path.