---
id: "713593"
title: "Water the plants"
slug: "water-the-plants--170646"
difficulty: "Medium"
companyTags: ["Microsoft"]
tags: ["Greedy", "Sorting", "Algorithms"]
---

# Water the Plants
## Slug: water-the-plants--170646
## Difficulty: Medium
## Id: 713593
## Topic Tags: Greedy, Sorting, Algorithms
## Company Tags: Microsoft

### Summary
Water the plants is a classic problem in computer science. Given an array of integers representing the heights of the plants and the amount of water that can be carried, determine how many plants can be watered. The key concept involved here is greedy algorithm.

### Detailed Explanation
The problem statement says that we have to water the maximum number of plants possible given the available water and plant heights. This problem involves a combination of sorting and greedy algorithms.

To solve this problem, first sort the array in descending order based on the plant heights. Then iterate through the sorted array from left to right. For each pair of adjacent plants, calculate how much water can be carried by considering both plants' heights as the "container" for that amount of water (i.e., the minimum height of the two plants). Keep track of the maximum amount of water that can be carried.

Now, let's write a step-by-step breakdown of the solution:

1.  Initialize an empty array to store the sorted plant heights in descending order.
2.  Iterate through the original array and add each plant's height to the sorted array.
3.  Initialize two pointers (left and right) at the start of the sorted array.
4.  Calculate how much water can be carried by considering both plants' heights as the "container" for that amount of water.
5.  Update the maximum amount of water that can be carried.
6.  If there is still more water available, move the right pointer to the next plant and update the container height.
7.  Finally, return the maximum number of plants that can be watered.

The time complexity for this problem is O(n log n) due to the sorting operation, where n is the total number of plants. The space complexity is O(n), as we need extra space to store the sorted array.

### Optimized Solutions

#### Java
```java
public class WaterPlants {
    public static int waterPlants(int[] heights) {
        int maxWater = 0;
        for (int i = 0; i < heights.length - 1; i++) {
            int leftHeight = heights[i];
            int rightHeight = heights[i + 1];
            int waterAvailable = Math.min(leftHeight, rightHeight);
            maxWater += waterAvailable;
        }
        return maxWater;
    }
}
```

#### Python
```python
def water_plants(heights):
    max_water = 0
    for i in range(len(heights) - 1):
        left_height = heights[i]
        right_height = heights[i + 1]
        water_available = min(left_height, right_height)
        max_water += water_available
    return max_water
```

#### C++
```cpp
#include <iostream>
int waterPlants(int* heights, int n) {
    int maxWater = 0;
    for (int i = 0; i < n - 1; i++) {
        int leftHeight = heights[i];
        int rightHeight = heights[i + 1];
        int waterAvailable = std::min(leftHeight, rightHeight);
        maxWater += waterAvailable;
    }
    return maxWater;
}
```

#### JavaScript
```javascript
function waterPlants(heights) {
    let maxWater = 0;
    for (let i = 0; i < heights.length - 1; i++) {
        const leftHeight = heights[i];
        const rightHeight = heights[i + 1];
        const waterAvailable = Math.min(leftHeight, rightHeight);
        maxWater += waterAvailable;
    }
    return maxWater;
}
```

Note: The optimized solutions are provided in the given languages, and they implement the greedy algorithm described in the problem.