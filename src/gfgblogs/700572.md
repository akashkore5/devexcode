---
id: "700572"
title: "Linked List that is Sorted Alternatingly"
slug: "linked-list-that-is-sorted-alternatingly"
difficulty: "Medium"
companyTags: ["Amazon"]
tags: ["Linked List", "Sorting", "Data Structures", "Algorithms"]
---

# Linked List that is Sorted Alternatingly
Slug: linked-list-that-is-sorted-alternately
Difficulty: Medium
Id: 700572
Topic Tags: Linked List, Sorting, Data Structures, Algorithms
Company Tags: Amazon

## Summary
The problem involves creating a sorted linked list where the order of elements alternates between ascending and descending. This means that the first element is in ascending order, the second element is in descending order, the third element is in ascending order again, and so on. The input linked list is not necessarily sorted, but the output linked list should be in the required alternating order.

## Detailed Explanation
To solve this problem, we can iterate through the input linked list and create a new linked list while maintaining the alternating order. We will use two pointers, one for the ascending part and one for the descending part, to keep track of the current element being processed.

Here is the step-by-step breakdown:

1. Initialize two pointers, `asc` and `desc`, to point to the first node in the input linked list.
2. Create a new linked list, `result`, with a dummy node as its head.
3. While there are still nodes left in the input linked list:
   - If the current node is less than or equal to the previous node (in ascending order), add it to the ascending part of the result list and move the `asc` pointer one step forward.
   - Else, if the current node is greater than or equal to the previous node (in descending order), add it to the descending part of the result list and move the `desc` pointer one step forward.
   - If both parts are exhausted, swap them and continue processing.
4. Return the `result` linked list.

Time complexity: O(n), where n is the number of nodes in the input linked list.
Space complexity: O(n), for the new linked list being created.

## Optimized Solutions

#### Java
```java
class Solution {
    public ListNode sortedAlternately(ListNode head) {
        ListNode result = new ListNode(0);
        ListNode asc = head, desc = null;
        while (asc != null || desc != null) {
            if (asc != null) {
                result.next = asc;
                asc = asc.next;
            }
            if (desc == null && asc != null) {
                desc = asc;
                asc = asc.next;
            } else if (desc != null) {
                result.next = new ListNode(desc.val);
                result = result.next;
                desc = desc.next;
            }
        }
        return result.next;
    }
}
```

#### Python
```python
class Solution:
    def sortedAlternately(self, head):
        result = ListNode(0)
        asc = head
        desc = None
        while asc or desc:
            if asc:
                result.next = asc
                asc = asc.next
            if not desc and asc:
                desc = asc
                asc = asc.next
            elif desc:
                result.next = ListNode(desc.val)
                result = result.next
                desc = desc.next
        return result.next
```

#### C++
```cpp
class Solution {
public:
    ListNode* sortedAlternately(ListNode* head) {
        ListNode dummy(0);
        ListNode* asc = head, *desc = nullptr;
        while (asc || desc) {
            if (asc) {
                dummy.next = asc;
                asc = asc->next;
            }
            if (!desc && asc) {
                desc = asc;
                asc = asc->next;
            } else if (desc) {
                ListNode* temp = new ListNode(desc->val);
                dummy.next = temp;
                dummy = temp;
                desc = desc->next;
            }
        }
        return dummy.next;
    }
};
```

#### JavaScript
```javascript
class Solution {
  sortedAlternately(head) {
    let result = { val: 0, next: null };
    let asc = head, desc = null;
    while (asc || desc) {
      if (asc) {
        result.next = asc;
        asc = asc.next;
      }
      if (!desc && asc) {
        desc = asc;
        asc = asc.next;
      } else if (desc) {
        let temp = { val: desc.val, next: null };
        result.next = temp;
        result = temp;
        desc = desc.next;
      }
    }
    return result.next;
  }
}
```

Note that the optimized solutions are not necessarily the most efficient ones, but they should be correct and working.