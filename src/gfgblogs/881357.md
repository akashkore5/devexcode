---
id: "881357"
title: "Queue Push & Pop"
slug: "queue-designer--104629"
difficulty: "Basic"
companyTags: []
tags: ["Queue", "Data Structures"]
---

**Queue Push & Pop**
==================

### Summary
Implement a queue data structure with push and pop operations. The queue should have a fixed capacity, and when it's full, new elements can be added only if the oldest element is removed first.

### Detailed Explanation
The problem requires us to implement a queue data structure that has two primary operations: `push` and `pop`. A queue is a First-In-First-Out (FIFO) data structure, meaning that the first element added to the queue will be the first one to be removed. Our queue also has a fixed capacity, which means that when it's full, we can only add new elements if the oldest element is removed first.

To solve this problem, we can use an array-based implementation of a queue. Here's a step-by-step breakdown of our solution:

1. Initialize the queue with a fixed capacity `size`.
2. The `push` operation adds an element to the end of the queue.
3. If the queue is full (i.e., its size is equal to the capacity), we need to remove the oldest element from the front of the queue before adding the new element.
4. The `pop` operation removes the oldest element from the front of the queue.

Here's a simple ASCII art diagram illustrating our queue:
```
  | E1 | E2 | ... | Ek-1 | Ek |
+---+
  ^  (front)
  |
  +---+
  Queue
```
In this diagram, `E1` to `Ek-1` represent the elements in the queue, and `Ek` is the oldest element at the front of the queue. The `^` symbol indicates the front of the queue.

The time complexity of our solution is O(1) for both push and pop operations, since we only need to check if the queue is full or not. The space complexity is O(size), where `size` is the capacity of the queue.

### Optimized Solutions

#### Java
```java
class Queue {
    private int size;
    private int front;
    private int rear;
    private Object[] elements;

    public Queue(int capacity) {
        size = 0;
        front = 0;
        rear = 0;
        elements = new Object[capacity];
    }

    public void push(Object element) {
        if (size == elements.length) {
            // Remove oldest element from the front
            elements[front] = null;
            front = (front + 1) % elements.length;
        }
        elements[rear] = element;
        rear = (rear + 1) % elements.length;
        size++;
    }

    public Object pop() {
        if (size == 0) {
            return null; // Queue is empty
        }
        Object element = elements[front];
        front = (front + 1) % elements.length;
        size--;
        return element;
    }
}
```

#### Python
```python
class Queue:
    def __init__(self, capacity):
        self.size = 0
        self.front = 0
        self.rear = 0
        self.elements = [None] * capacity

    def push(self, element):
        if self.size == len(self.elements):
            # Remove oldest element from the front
            self.elements[self.front] = None
            self.front = (self.front + 1) % len(self.elements)
        self.elements[self.rear] = element
        self.rear = (self.rear + 1) % len(self.elements)
        self.size += 1

    def pop(self):
        if self.size == 0:
            return None  # Queue is empty
        element = self.elements[self.front]
        self.front = (self.front + 1) % len(self.elements)
        self.size -= 1
        return element
```

#### C++
```cpp
class Queue {
public:
    int size;
    int front;
    int rear;
    Object* elements;

    Queue(int capacity) {
        size = 0;
        front = 0;
        rear = 0;
        elements = new Object[capacity];
    }

    void push(Object element) {
        if (size == elements.length) {
            // Remove oldest element from the front
            elements[front] = nullptr;
            front = (front + 1) % elements.length;
        }
        elements[rear] = element;
        rear = (rear + 1) % elements.length;
        size++;
    }

    Object pop() {
        if (size == 0) {
            return nullptr; // Queue is empty
        }
        Object element = elements[front];
        front = (front + 1) % elements.length;
        size--;
        return element;
    }
};
```

#### JavaScript
```javascript
class Queue {
    constructor(capacity) {
        this.size = 0;
        this.front = 0;
        this.rear = 0;
        this.elements = new Array(capacity).fill(null);
    }

    push(element) {
        if (this.size === this.elements.length) {
            // Remove oldest element from the front
            this.elements[this.front] = null;
            this.front = (this.front + 1) % this.elements.length;
        }
        this.elements[this.rear] = element;
        this.rear = (this.rear + 1) % this.elements.length;
        this.size++;
    }

    pop() {
        if (this.size === 0) {
            return null; // Queue is empty
        }
        const element = this.elements[this.front];
        this.front = (this.front + 1) % this.elements.length;
        this.size--;
        return element;
    }
}
```

Note that these optimized solutions maintain the same time and space complexity as our original solution.