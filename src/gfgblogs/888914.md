---
id: "888914"
title: "Minimum Spanning Tree - Kruskal's Algorithm"
slug: "minimum-spanning-tree-kruskals-algorithm"
difficulty: "Medium"
companyTags: ["Cisco", "Amazon", "Microsoft", "Samsung", "Flipkart"]
tags: ["Greedy", "Disjoint Set", "Graph", "Data Structures", "Algorithms"]
---

Minimum Spanning Tree - Kruskal's Algorithm
=====================================================

## Summary
Kruskal's algorithm is a greedy algorithm used to find the minimum spanning tree (MST) of a connected weighted graph. The MST is a subgraph that connects all vertices in the original graph with the minimum possible total edge weight. This problem involves implementing this algorithm using a disjoint set data structure to efficiently manage the edges and their connectivity.

## Detailed Explanation
Kruskal's algorithm works by sorting all the edges in the graph by their weights, then iteratively adding the smallest-weighted edge that does not form a cycle with the already included edges. The algorithm terminates when the MST is formed, which is represented as a tree data structure.

Here is a step-by-step breakdown of the solution:

1.  Initialize an empty disjoint set `DS` and a priority queue `pq` to store all the edges in the graph.
2.  Sort the edges in the `pq` based on their weights.
3.  While the `pq` is not empty, do the following:
    *   Extract the smallest-weighted edge from the `pq`.
    *   If the two vertices connected by this edge are not in the same set in `DS`, merge the sets and add the edge to the MST.
4.  The final MST is represented as a tree data structure.

Time Complexity Analysis
------------------------

*   Sorting edges: O(E log E) where E is the number of edges.
*   Iterative process: O(E + V) where V is the number of vertices, since each edge and vertex are processed once.
Total time complexity: O(E log E).

Space Complexity Analysis
-------------------------

*   Disjoint set `DS`: O(V) to store all the vertices.
*   Priority queue `pq`: O(E) to store all the edges.
Total space complexity: O(V + E).

## Optimized Solutions

### Java
```java
public class Kruskal {
    public static List<Edge> kruskalMST(Graph graph) {
        List<Edge> mst = new ArrayList<>();
        UnionFind uf = new UnionFind(graph.V());
        
        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> a.weight - b.weight);
        for (Edge edge : graph.edges()) {
            pq.add(edge);
        }
        
        while (!pq.isEmpty()) {
            Edge edge = pq.poll();
            int u = edge.u;
            int v = edge.v;
            
            if (uf.find(u) != uf.find(v)) {
                mst.add(edge);
                uf.union(u, v);
            }
        }
        
        return mst;
    }
    
    static class UnionFind {
        int[] parent;
        int[] rank;
        
        public UnionFind(int V) {
            parent = new int[V];
            rank = new int[V];
            
            for (int i = 0; i < V; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }
        
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            
            if (rootX != rootY) {
                if (rank[rootX] > rank[rootY]) {
                    parent[rootY] = rootX;
                } else if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else {
                    parent[rootY] = rootX;
                    rank[rootX]++;
                }
            }
        }
    }
    
    static class Edge implements Comparable<Edge> {
        int u;
        int v;
        int weight;
        
        public Edge(int u, int v, int weight) {
            this.u = u;
            this.v = v;
            this.weight = weight;
        }
        
        @Override
        public int compareTo(Edge o) {
            return Integer.compare(this.weight, o.weight);
        }
    }
}
```

### Python
```python
class UnionFind:
    def __init__(self, V):
        self.parent = [i for i in range(V)]
        self.rank = [0] * V

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)

        if rootX != rootY:
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1

class Edge:
    def __init__(self, u, v, weight):
        self.u = u
        self.v = v
        self.weight = weight

    def __lt__(self, other):
        return self.weight < other.weight

def kruskalMST(graph):
    mst = []
    uf = UnionFind(len(graph))
    
    pq = sorted(list(graph), key=lambda x: x[2])
    
    for edge in pq:
        u, v, _ = edge
        if uf.find(u) != uf.find(v):
            mst.append(edge)
            uf.union(u, v)

    return mst

# Example usage
graph = [[0, 1, 4], [0, 2, 8], [1, 2, 7], [1, 3, 9], [2, 3, 10]]
print(kruskalMST(graph))
```

### C++
```cpp
class UnionFind {
public:
    int parent[100];
    int rank[100];

    UnionFind(int V) {
        for (int i = 0; i < V; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
};

class Edge {
public:
    int u, v;
    int weight;

    Edge(int u, int v, int weight) {
        this->u = u;
        this->v = v;
        this->weight = weight;
    }
};

vector<Edge> kruskalMST(vector<pair<int, pair<int, int>>>& graph) {
    vector<Edge> mst;
    UnionFind uf(graph.size());

    priority_queue<Edge*, vector<Edge*>, function<bool(const Edge*, const Edge*)>> pq([&](const Edge* a, const Edge* b) { return a->weight < b->weight; });

    for (const auto& edge : graph) {
        pq.push(new Edge(edge.second.first, edge.second.second, edge.first));
    }

    while (!pq.empty()) {
        Edge* edge = pq.top();
        pq.pop();

        int x = edge->u;
        int y = edge->v;

        if (uf.find(x) != uf.find(y)) {
            mst.push_back(*edge);
            uf.union(x, y);
        }
    }

    return mst;
}
```

### Java
```java
class UnionFind {
    int[] parent;
    int[] rank;

    public UnionFind(int V) {
        parent = new int[V];
        rank = new int[V];

        for (int i = 0; i < V; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
}

class Edge implements Comparable<Edge> {
    int u, v;
    int weight;

    public Edge(int u, int v, int weight) {
        this.u = u;
        this.v = v;
        this.weight = weight;
    }

    @Override
    public int compareTo(Edge o) {
        return Integer.compare(this.weight, o.weight);
    }
}

public class KruskalMST {
    public static List<Edge> kruskalMST(List<Edge> graph) {
        List<Edge> mst = new ArrayList<>();
        UnionFind uf = new UnionFind(graph.size());

        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(Edge::getWeight));

        for (Edge edge : graph) {
            pq.offer(edge);
        }

        while (!pq.isEmpty()) {
            Edge edge = pq.poll();

            int x = edge.u;
            int y = edge.v;

            if (uf.find(x) != uf.find(y)) {
                mst.add(edge);
                uf.union(x, y);
            }
        }

        return mst;
    }
}
```

This implementation of the Kruskal's algorithm is designed to work with a graph represented as an adjacency list or matrix. The time complexity of this algorithm is O(E log E), where E is the number of edges in the graph, since we are using a priority queue to sort the edges by their weights.