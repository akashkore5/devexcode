---
id: "703368"
title: "Longest Common Increasing Subsequence"
slug: "longest-common-increasing-subsequence1437"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Dynamic Programming", "Data Structures", "Algorithms"]
---

# Longest Common Increasing Subsequence
## Slug: longest-common-increasing-subsequence1437
## Difficulty: Medium
## Id: 703368
## Topic Tags: Arrays, Dynamic Programming, Data Structures, Algorithms
## Company Tags: None

## Summary
Given two sequences of integers `A` and `B`, find the length of the longest common increasing subsequence. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. The problem requires us to identify the longest such subsequence that is also increasing, i.e., each element is greater than its predecessor.

## Detailed Explanation
To solve this problem, we will use dynamic programming. We initialize a 2D array `dp` where `dp[i][j]` represents the length of the longest common increasing subsequence between the first `i` elements of `A` and the first `j` elements of `B`. We fill up the `dp` array by iterating over all possible subsequences of `A` and `B`.

Here's a step-by-step breakdown of the solution:

1. Initialize `dp[0][0] = 0`, as there is no common increasing subsequence between an empty sequence and another.
2. For each element `a` in `A` and each element `b` in `B`, check if `a <= b`. If this condition is met, it means that the current elements of both sequences are in increasing order. In this case, we update `dp[i][j] = dp[i-1][j-1] + 1`, as we found a common increasing subsequence.
3. Move diagonally upwards and leftwards from each cell in `dp` to fill up the entire array.

Here's an ASCII art diagram illustrating the dynamic programming approach:
```
   A | 0 | 1 | 2 | ... | n
  ---+---+---+---+----+---
    B | 0 | 1 | 2 | ... | m
```

Time complexity: O(n*m)
Space complexity: O(n*m)

## Optimized Solutions

### Java
```java
public int longestCommonIncreasingSubsequence(int[] A, int[] B) {
    int[][] dp = new int[A.length+1][B.length+1];
    for (int i = 0; i <= A.length; i++) {
        for (int j = 0; j <= B.length; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 0;
            } else if (A[i-1] <= B[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[A.length][B.length];
}
```

### Python
```python
def longest_common_increasing_subsequence(A, B):
    n, m = len(A), len(B)
    dp = [[0] * (m+1) for _ in range(n+1)]
    
    for i in range(1, n+1):
        for j in range(1, m+1):
            if A[i-1] <= B[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[n][m]
```

### C++
```cpp
int longestCommonIncreasingSubsequence(vector<int> A, vector<int> B) {
    int n = A.size(), m = B.size();
    vector<vector<int>> dp(n+1, vector<int>(m+1));
    
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 0;
            } else if (A[i-1] <= B[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[n][m];
}
```

### JavaScript
```javascript
function longestCommonIncreasingSubsequence(A, B) {
    let n = A.length, m = B.length;
    let dp = new Array(n+1).fill(0).map(() => new Array(m+1).fill(0));
    
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (A[i-1] <= B[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[n][m];
}
```

Note: The above solutions assume that the input sequences `A` and `B` are non-empty. If this is not the case, you may need to add additional checks at the beginning of the function.