---
id: "700826"
title: "Need Some Change - Java"
slug: "need-some-change-java"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

Here is the detailed Markdown blog post for the GeeksforGeeks problem:

# Need Some Change - Java
## Summary
The problem "Need Some Change" requires you to determine how much change a cashier needs to make to give back to a customer in a specific situation. The casher has a certain amount of money and a set of coins (quarters, dimes, nickels, pennies) with their respective values. Your task is to find the minimum number of coins needed to make up the difference between the casher's total amount and the customer's change.

## Detailed Explanation
To solve this problem, we can use an array-based approach. Let's say the casher has `totalAmount` and the customer needs `changeAmount`. We'll create an array `coins` with the values of quarters, dimes, nickels, and pennies (25, 10, 5, 1 cents respectively). The goal is to find the minimum number of coins needed to make up the difference between `totalAmount` and `changeAmount`.

Here's a step-by-step breakdown:

1. Calculate the difference between `totalAmount` and `changeAmount`. Let's call this `amountToMakeUp`.
2. Initialize an array `minCoins` with a size equal to the number of coin types (4 in our case). This array will store the minimum number of coins needed for each amount from 0 to `amountToMakeUp`.
3. Iterate through the `coins` array and update the `minCoins` array as follows:
	* For each coin type, calculate how many coins of that type are needed to make up the current `amountToMakeUp`. This can be done by integer dividing `amountToMakeUp` by the coin value.
	* Add this number to the corresponding index in the `minCoins` array. If the result exceeds the previous minimum for that amount, update it.
4. Return the value at the last index of the `minCoins` array, which represents the minimum number of coins needed to make up the entire difference.

Time complexity: O(n), where n is the maximum coin value (25).
Space complexity: O(1), as we only use a constant amount of space for the arrays and variables.

## Optimized Solutions

### Java
```
java
public int needSomeChange(int totalAmount, int[] coins) {
    int amountToMakeUp = Math.abs(totalAmount);
    int[] minCoins = new int[coins.length];
    Arrays.fill(minCoins, Integer.MAX_VALUE);

    for (int coin : coins) {
        for (int i = 0; i <= amountToMakeUp / coin; i++) {
            int remainingAmount = amountToMakeUp - i * coin;
            if (remainingAmount < minCoins[coins.length - 1]) {
                minCoins[coins.length - 1] = i + 1;
            }
        }
    }

    return minCoins[minCoins.length - 1];
}
```

### Python
```
python
def need_some_change(total_amount, coins):
    amount_to_make_up = abs(total_amount)
    min_coins = [float('inf')] * len(coins)

    for coin in coins:
        for i in range((amount_to_make_up // coin) + 1):
            remaining_amount = amount_to_make_up - i * coin
            if remaining_amount < min_coins[-1]:
                min_coins[-1] = i + 1

    return min_coins[-1]
```

### C++
```
cpp
int needSomeChange(int totalAmount, int* coins, int coinsSize) {
    int amountToMakeUp = abs(totalAmount);
    int* minCoins = new int[coinsSize];
    memset(minCoins, 0xFF, sizeof(int) * coinsSize);

    for (int i = 0; i < coinsSize; i++) {
        for (int j = 0; j <= amountToMakeUp / coins[i]; j++) {
            int remainingAmount = amountToMakeUp - j * coins[i];
            if (remainingAmount < minCoins[coinsSize - 1]) {
                minCoins[coinsSize - 1] = j + 1;
            }
        }
    }

    int result = minCoins[coinsSize - 1];
    delete[] minCoins;
    return result;
}
```

### JavaScript
```
javascript
function needSomeChange(totalAmount, coins) {
    let amountToMakeUp = Math.abs(totalAmount);
    const minCoins = new Array(coins.length).fill(Infinity);

    for (const coin of coins) {
        for (let i = 0; i <= amountToMakeUp / coin; i++) {
            let remainingAmount = amountToMakeUp - i * coin;
            if (remainingAmount < minCoins[minCoins.length - 1]) {
                minCoins[minCoins.length - 1] = i + 1;
            }
        }
    }

    return minCoins[minCoins.length - 1];
}
```

Note: The optimized solutions are provided in different programming languages as per the problem tags.