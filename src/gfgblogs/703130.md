---
id: "703130"
title: "Maximum length Bitonic Subarray"
slug: "maximum-length-bitonic-subarray5730"
difficulty: "Medium"
companyTags: ["Microsoft"]
tags: ["Arrays", "Data Structures"]
---

Here is a detailed Markdown blog post for the GeeksforGeeks problem "Maximum length Bitonic Subarray":

# Maximum length Bitonic Subarray

## Summary

Given an array, we need to find the maximum length bitonic subarray. A bitonic sequence is a sequence that first increases and then decreases. This problem requires us to identify the longest such subsequence in the given array.

## Detailed Explanation

To solve this problem, we can start by identifying all possible bitonic subsequences in the given array. We can do this by iterating through the array and marking each element as either increasing or decreasing based on its position relative to the previous elements.

Once we have identified all the bitonic subsequences, we need to find the longest one among them. This can be done by comparing the lengths of all the bitonic subsequences found so far and returning the length of the longest one.

Here is a step-by-step breakdown of the solution:

1. Initialize an empty array `bitonic_subarrays` to store all possible bitonic subsequences.
2. Iterate through the given array from left to right, marking each element as either increasing or decreasing based on its position relative to the previous elements. For example, if the current element is greater than the previous one, mark it as increasing; otherwise, mark it as decreasing.
3. Whenever you encounter an element that changes from increasing to decreasing (or vice versa), it means you have found a new bitonic subarray. Store this subarray in `bitonic_subarrays`.
4. Once you have processed the entire array, iterate through `bitonic_subarrays` and find the longest one by comparing their lengths.
5. Return the length of the longest bitonic subarray found.

Here is an ASCII art diagram to illustrate the above steps:
```
 0 1 2 3 4 5 6
I I D D D D I
----------------
| Increasing | Decreasing |
|-----------|
| Bitonic Subarray | Bitonic Subarray |
|-----------|
```

Time complexity: O(n), where n is the length of the given array.

Space complexity: O(n), as we need to store all possible bitonic subsequences in `bitonic_subarrays`.

## Optimized Solutions

### Java
```java
public int maximumLengthBitonicSubarray(int[] arr) {
    int max_length = 0;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] > arr[i - 1]) {
            // Found an increasing subarray, check if it's bitonic
            int length = 1;
            while (i + length < arr.length && arr[i + length] > arr[i + length - 1]) {
                length++;
            }
            // Check if the subarray is decreasing after the increase
            int decreasing_length = 0;
            while (i + length + decreasing_length < arr.length && arr[i + length + decreasing_length] < arr[i + length + decreasing_length - 1]) {
                decreasing_length++;
            }
            max_length = Math.max(max_length, length + decreasing_length);
        }
    }
    return max_length;
}
```

### Python
```python
def maximum_length_bitonic_subarray(arr):
    max_length = 0
    for i in range(len(arr)):
        if arr[i] > arr[i - 1]:
            # Found an increasing subarray, check if it's bitonic
            length = 1
            while i + length < len(arr) and arr[i + length] > arr[i + length - 1]:
                length += 1
            # Check if the subarray is decreasing after the increase
            decreasing_length = 0
            while i + length + decreasing_length < len(arr) and arr[i + length + decreasing_length] < arr[i + length + decreasing_length - 1]:
                decreasing_length += 1
            max_length = max(max_length, length + decreasing_length)
    return max_length
```

### C++
```cpp
int maximumLengthBitonicSubarray(int* arr, int n) {
    int maxLength = 0;
    for (int i = 0; i < n; i++) {
        if (arr[i] > arr[i - 1]) {
            // Found an increasing subarray, check if it's bitonic
            int length = 1;
            while (i + length < n && arr[i + length] > arr[i + length - 1]) {
                length++;
            }
            // Check if the subarray is decreasing after the increase
            int decreasingLength = 0;
            while (i + length + decreasingLength < n && arr[i + length + decreasingLength] < arr[i + length + decreasingLength - 1]) {
                decreasingLength++;
            }
            maxLength = std::max(maxLength, length + decreasingLength);
        }
    }
    return maxLength;
}
```

### JavaScript
```javascript
function maximumLengthBitonicSubarray(arr) {
    let max_length = 0;
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] > arr[i - 1]) {
            // Found an increasing subarray, check if it's bitonic
            let length = 1;
            while (i + length < arr.length && arr[i + length] > arr[i + length - 1]) {
                length++;
            }
            // Check if the subarray is decreasing after the increase
            let decreasingLength = 0;
            while (i + length + decreasingLength < arr.length && arr[i + length + decreasingLength] < arr[i + length + decreasingLength - 1]) {
                decreasingLength++;
            }
            max_length = Math.max(max_length, length + decreasingLength);
        }
    }
    return max_length;
}
```

Note that the above solutions assume that the input array is non-empty.