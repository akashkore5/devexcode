---
id: "875887"
title: "Minimum increment by k operations to make all equal"
slug: "minimum-increment-by-k-operations-to-make-all-equal"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Algorithms"]
---

**Minimum increment by k operations to make all equal**
=====================================================

### Summary
Given an array of distinct integers, find the minimum number of operations needed to make all elements equal. In each operation, you can either increment or decrement the value of a single element by 1.

### Detailed Explanation
To solve this problem, we need to consider the following key concepts:

* The given array contains distinct integers.
* We have two types of operations: increment and decrement.
* Our goal is to make all elements equal by performing these operations.

Here's a step-by-step breakdown of the solution:

1. First, sort the array in ascending order. This is because we want to minimize the number of operations required to make all elements equal.
2. Initialize a variable `result` to store the minimum number of operations needed. Set it to 0 initially.
3. Iterate through the sorted array and calculate the absolute difference between each element and the median of the array (which is the middle value when the array is sorted). This represents the amount of increment/decrement required for each element to become equal.
4. Add up all these differences to get the total number of operations needed. This will give us the minimum number of operations required to make all elements equal.

Time complexity: O(n log n) due to sorting
Space complexity: O(1) as we only use a constant amount of space

### Optimized Solutions
#### Java
```java
public int minOperations(int[] arr, int k) {
    Arrays.sort(arr);
    int result = 0;
    for (int i : arr) {
        result += Math.abs(i - median(arr));
    }
    return result;
}

private double median(int[] arr) {
    int n = arr.length;
    if (n % 2 == 0) {
        return (arr[n / 2 - 1] + arr[n / 2]) / 2.0;
    } else {
        return arr[n / 2];
    }
}
```

#### Python
```python
def min_operations(arr, k):
    arr.sort()
    result = 0
    for i in arr:
        result += abs(i - median(arr))
    return result

def median(arr):
    n = len(arr)
    if n % 2 == 0:
        return (arr[n // 2 - 1] + arr[n // 2]) / 2.0
    else:
        return arr[n // 2]
```

#### C++
```cpp
int minOperations(int* arr, int n, int k) {
    sort(arr, arr + n);
    int result = 0;
    for (int i = 0; i < n; i++) {
        result += abs(arr[i] - median(arr));
    }
    return result;

double median(int* arr, int n) {
    if (n % 2 == 0) {
        return (arr[n / 2 - 1] + arr[n / 2]) / 2.0;
    } else {
        return arr[n / 2];
    }
}
```

#### JavaScript
```javascript
function minOperations(arr, k) {
    arr.sort((a, b) => a - b);
    let result = 0;
    for (let i of arr) {
        result += Math.abs(i - median(arr));
    }
    return result;

function median(arr) {
    let n = arr.length;
    if (n % 2 == 0) {
        return (arr[n / 2 - 1] + arr[n / 2]) / 2.0;
    } else {
        return arr[n / 2];
    }
}
```
Note that the `median` function is implemented separately for each language, as the JavaScript `Math.floor()` function does not work with floating-point numbers.