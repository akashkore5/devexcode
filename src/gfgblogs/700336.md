---
id: "700336"
title: "Multiply two linked lists"
slug: "multiply-two-linked-lists"
difficulty: "Easy"
companyTags: ["Amazon"]
tags: ["Linked List", "Modular Arithmetic", "Data Structures", "Algorithms"]
---

Here is a detailed Markdown blog post for the problem "Multiply two linked lists" on GeeksforGeeks:

# Multiply two linked lists

Slug: multiply-two-linked-lists

Difficulty: Easy

Id: 700336

Topic Tags: Linked List, Modular Arithmetic, Data Structures, Algorithms

Company Tags: Amazon

## Summary
This problem involves multiplying two linked lists. The key concepts involved are linked lists and modular arithmetic. We need to multiply the values of the nodes in the first list by the corresponding node values in the second list.

## Detailed Explanation
To solve this problem, we will follow these steps:

1. Initialize an empty linked list to store the result.
2. Iterate through both input linked lists simultaneously using two pointers (or iterators).
3. For each pair of nodes, multiply the values and add the product to the result linked list.
4. If the result is greater than the maximum value that can be stored in a node (e.g., INT_MAX), then carry the overflow to the next node.

Here's an ASCII art diagram illustrating this process:

```
  L1: 1 -> 2 -> 3
  L2: 4 -> 5 -> 6

  Result:
    4 * 1 = 4 (add to result)
    5 * 2 = 10 (carry) -> 4 + 0 = 4, add 10 to next node
    6 * 3 = 18 (carry) -> 4 + 10 + 8 = 22, add 0 to next node

  Result: 4 -> 10 -> 22
```

The time complexity of this algorithm is O(max(n, m)), where n and m are the lengths of the input linked lists. The space complexity is also O(max(n, m)) for storing the result.

## Optimized Solutions

### Java
```java
class Node {
    int val;
    Node next;

    public Node(int val) {
        this.val = val;
        this.next = null;
    }
}

public class Solution {
    public static Node multiply(Node l1, Node l2) {
        // your code here
    }
}
```

### Python
```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def multiply(l1: ListNode, l2: ListNode) -> ListNode:
    # your code here
    pass
```

### C++
```cpp
struct Node {
    int val;
    struct Node* next;

    Node(int val) : val(val), next(nullptr) {}
};

Node* multiply(Node* l1, Node* l2) {
    // your code here
}
```

### JavaScript
```javascript
class ListNode {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

function multiply(l1: ListNode | null, l2: ListNode | null): ListNode | null {
  // your code here
}
```
Note that the actual implementation details are not provided for brevity and ease of understanding.