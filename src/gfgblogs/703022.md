---
id: "703022"
title: "Smallest subarray with all occurrences of a most frequent element"
slug: "smallest-subarray-with-all-occurrences-of-a-most-frequent-element2258"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Hash", "Data Structures"]
---

**Smallest subarray with all occurrences of a most frequent element**
==================================================================

### Summary
Given an array of integers, find the smallest contiguous subarray that contains all occurrences of the most frequent element. The problem involves arrays and hash data structures.

### Detailed Explanation
The approach to solve this problem is to first find the most frequent element in the given array. Then, we will calculate its frequency. After that, we need to find the smallest subarray where all occurrences of this most frequent element are present. We can achieve this by iterating over the array and keeping track of the start index of the current subarray.

Here's a step-by-step breakdown:

1.  Calculate the frequency of each element in the given array.
2.  Find the most frequent element (MFE) and its frequency (F).
3.  Initialize two pointers, `start` and `end`, to the beginning of the array.
4.  Iterate over the array:
    *   If the current element is not equal to MFE, increment `start` until we find MFE or reach the end of the array.
    *   If the current element is equal to MFE, check if its frequency (`f`) is less than F. If yes, update `end` and decrement `f`.
5.  The subarray `[start, end]` will be the smallest contiguous subarray that contains all occurrences of the most frequent element.

Time complexity: O(n), where n is the size of the array.
Space complexity: O(min(n, m)), where m is the frequency of the most frequent element.

### Optimized Solutions

#### Java
```java
public int[] smallestSubarray(int[] arr) {
    Map<Integer, Integer> freqMap = new HashMap<>();
    for (int num : arr) {
        freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
    }
    int maxFreq = 0;
    int mfe = -1;
    for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
        if (entry.getValue() > maxFreq) {
            maxFreq = entry.getValue();
            mfe = entry.getKey();
        }
    }
    int start = 0;
    int end = 0;
    int minLen = Integer.MAX_VALUE;
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == mfe) {
            while (i > start && arr[i-1] != mfe) {
                start++;
            }
            end = i;
        }
        if (end - start + 1 > minLen) {
            break;
        }
    }
    return Arrays.copyOfRange(arr, start, end+1);
}
```

#### Python
```python
def smallest_subarray(arr):
    freq_map = {}
    for num in arr:
        freq_map[num] = freq_map.get(num, 0) + 1
    max_freq = 0
    mfe = -1
    for entry in freq_map.items():
        if entry[1] > max_freq:
            max_freq = entry[1]
            mfe = entry[0]
    start = 0
    end = 0
    min_len = float('inf')
    for i in range(len(arr)):
        if arr[i] == mfe:
            while i > start and arr[i-1] != mfe:
                start += 1
            end = i
        if end - start + 1 > min_len:
            break
    return arr[start:end+1]
```

#### C++
```cpp
#include <iostream>
#include <map>

int* smallestSubarray(int* arr, int size) {
    std::map<int, int> freqMap;
    for (int i = 0; i < size; i++) {
        if (freqMap.find(arr[i]) == freqMap.end()) {
            freqMap[arr[i]] = 1;
        } else {
            freqMap[arr[i]]++;
        }
    }
    int maxFreq = 0;
    int mfe = -1;
    for (auto it = freqMap.begin(); it != freqMap.end(); it++) {
        if (it->second > maxFreq) {
            maxFreq = it->second;
            mfe = it->first;
        }
    }
    int start = 0;
    int end = 0;
    int minLen = INT_MAX;
    for (int i = 0; i < size; i++) {
        if (arr[i] == mfe) {
            while (i > start && arr[i-1] != mfe) {
                start++;
            }
            end = i;
        }
        if (end - start + 1 > minLen) {
            break;
        }
    }
    int* result = new int[end-start+2];
    for (int i = start; i <= end; i++) {
        result[i-start+1] = arr[i];
    }
    return result;
}
```

#### JavaScript
```javascript
function smallestSubarray(arr) {
    const freqMap = {};
    for (let num of arr) {
        if (!freqMap[num]) {
            freqMap[num] = 1;
        } else {
            freqMap[num]++;
        }
    }
    let maxFreq = 0;
    let mfe = -1;
    for (const [key, value] of Object.entries(freqMap)) {
        if (value > maxFreq) {
            maxFreq = value;
            mfe = parseInt(key);
        }
    }
    let start = 0;
    let end = 0;
    let minLen = Infinity;
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === mfe) {
            while (i > start && arr[i-1] !== mfe) {
                start++;
            }
            end = i;
        }
        if (end - start + 1 > minLen) {
            break;
        }
    }
    return arr.slice(start, end+1);
}
```

Note: The above solutions assume that the input array is non-empty.