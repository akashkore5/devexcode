---
id: "700461"
title: "Longest Palindrome in Linked List"
slug: "length-of-longest-palindrome-in-linked-list"
difficulty: "Medium"
companyTags: ["Accolite", "Microsoft"]
tags: ["Linked List", "palindrome", "Data Structures"]
---

# Length of Longest Palindrome in Linked List
Slug: length-of-longest-palindrome-in-linked-list
Difficulty: Medium
Id: 700461
Topic Tags: Linked List, palindrome, Data Structures
Company Tags: Accolite, Microsoft

## Summary
Given a linked list, find the length of the longest palindromic subsequence that can be formed by traversing the linked list. A palindrome is a sequence that reads the same backward as forward.

## Detailed Explanation
The problem involves identifying the longest palindromic subsequence in a linked list. To solve this, we will first traverse the linked list to build a string representation of it. Then, we will use dynamic programming to find the length of the longest palindrome that can be formed by selecting characters from the string.

Here's a step-by-step breakdown of the solution:

1. Traverse the linked list and build a string representation of it.
2. Initialize a 2D array `dp` with dimensions `(n x n)`, where `n` is the length of the string.
3. Fill the `dp` array in a bottom-up manner:
   - For each character at index `i` in the string, check if the character at index `j` (where `j = n-1-i`) matches it.
   - If they match, set `dp[i][n-1-i]` to `dp[i+1][n-2-i] + 2`, as we have found a palindrome of length 2 centered at the current character.
   - If they don't match, set `dp[i][n-1-i]` to the maximum of `dp[i+1][n-1-i]` and `dp[i][n-2-i]`.
4. The length of the longest palindromic subsequence is stored in the top-right corner of the `dp` array, i.e., `dp[0][n-1]`.

Time complexity: O(n^2), where n is the length of the linked list.
Space complexity: O(n^2), as we need to store the `dp` array.

## Optimized Solutions

### Java
```java
public class Main {
    public static int longestPalindromeLength(LinkedListNode node) {
        StringBuilder sb = new StringBuilder();
        while (node != null) {
            sb.append(node.data);
            node = node.next;
        }
        String str = sb.toString();
        int n = str.length();
        boolean[][] dp = new boolean[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                if (str.charAt(i) == str.charAt(n-1-j)) {
                    dp[i][j] = (i - j < 2 || dp[i-1][j+1]) ? true : false;
                } else {
                    dp[i][j] = dp[i-1][j] || dp[i][j+1];
                }
            }
        }
        int length = 0;
        for (int i = 0; i < n; i++) {
            if (dp[i][0]) {
                length = i + 1;
                break;
            }
        }
        return length;
    }

    public static void main(String[] args) {
        // Example usage:
        LinkedListNode node = new LinkedListNode(1);
        node.next = new LinkedListNode(2);
        node.next.next = new LinkedListNode(3);
        node.next.next.next = new LinkedListNode(4);
        node.next.next.next.next = new LinkedListNode(5);
        node.next.next.next.next.next = new LinkedListNode(6);
        System.out.println(longestPalindromeLength(node)); // Output: 2
    }
}

class LinkedListNode {
    int data;
    LinkedListNode next;

    public LinkedListNode(int data) {
        this.data = data;
        this.next = null;
    }
}
```

### Python
```python
def longest_palindrome_length(head):
    s = ''
    while head:
        s += str(head.data)
        head = head.next
    n = len(s)
    dp = [[False] * n for _ in range(n)]
    for i in range(n):
        for j in range(i+1):
            if s[i] == s[n-1-j]:
                dp[i][j] = (i - j < 2 or dp[i-1][j+1]) and True
            else:
                dp[i][j] = dp[i-1][j] or dp[i][j+1]
    length = 0
    for i in range(n):
        if dp[i][0]:
            length = i + 1
            break
    return length

# Example usage:
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)
head.next.next.next.next.next = Node(6)
print(longest_palindrome_length(head))  # Output: 2

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
```

### C++
```cpp
#include <iostream>
#include <string>

using namespace std;

int longestPalindromeLength(struct Node* head) {
    string s;
    while (head != NULL) {
        s += to_string(head->data);
        head = head->next;
    }
    int n = s.length();
    bool dp[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= i; j++) {
            if (s[i] == s[n-1-j]) {
                dp[i][j] = (i - j < 2 || dp[i-1][j+1]) ? true : false;
            } else {
                dp[i][j] = dp[i-1][j] || dp[i][j+1];
            }
        }
    }
    int length = 0;
    for (int i = 0; i < n; i++) {
        if (dp[i][0]) {
            length = i + 1;
            break;
        }
    }
    return length;
}

int main() {
    // Example usage:
    struct Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);
    head->next->next->next->next->next = new Node(6);
    cout << longestPalindromeLength(head) << endl; // Output: 2
}

class Node {
public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = NULL;
    }
};
```

### JavaScript
```javascript
function longestPalindromeLength(head) {
    let s = '';
    while (head !== null) {
        s += head.data.toString();
        head = head.next;
    }
    const n = s.length;
    const dp = Array(n).fill(0).map(() => Array(n).fill(false));
    for (let i = 0; i < n; i++) {
        for (let j = 0; j <= i; j++) {
            if (s[i] === s[n-1-j]) {
                dp[i][j] = (i - j < 2 || dp[i-1][j+1]) ? true : false;
            } else {
                dp[i][j] = dp[i-1][j] || dp[i][j+1];
            }
        }
    }
    let length = 0;
    for (let i = 0; i < n; i++) {
        if (dp[i][0]) {
            length = i + 1;
            break;
        }
    }
    return length;
}

// Example usage:
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

let head = new Node(1);
head.next = new Node(2);
head.next.next = new Node(3);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(5);
head.next.next.next.next.next = new Node(6);
console.log(longestPalindromeLength(head)); // Output: 2
```

Note that the JavaScript implementation uses a `Node` class to represent individual nodes in the linked list, whereas the other implementations use built-in data structures (e.g., arrays or strings).