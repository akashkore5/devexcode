---
id: "711970"
title: "Cheapest Flights Within K Stops"
slug: "cheapest-flights-within-k-stops"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "Shortest Path", "BFS", "Data Structures", "Algorithms", "Queue"]
---

Here is the detailed Markdown blog post for the "Cheapest Flights Within K Stops" problem:

**Cheapest Flights Within K Stops**
=============================

### Summary

Given a set of flights with prices and k, find the cheapest flight within k stops from a starting city. The graph represents flights between cities, where each edge has a weight (price). We need to find the shortest path in this graph that passes through at most k intermediate cities.

### Detailed Explanation

To solve this problem, we can use Breadth-First Search (BFS) algorithm. BFS is suitable for this problem because it explores all nodes at the present depth before moving on to nodes at the next depth level, which means it will find the shortest path within k stops.

Here's a step-by-step breakdown of the solution:

1. Initialize a queue with the starting city.
2. Create a visited set to keep track of visited cities.
3. While the queue is not empty:
    * Dequeue a city from the queue.
    * If the city has not been visited before, mark it as visited and enqueue all its unvisited neighbors.
4. Keep track of the cheapest flight within k stops.

Time complexity: O(E + V), where E is the number of edges and V is the number of vertices (cities).
Space complexity: O(V) for storing visited cities in a set.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class CheapestFlights {
    public int cheapestFlight(int[][] flights, int src, int dest, int k) {
        Map<Integer, List<int[]>> graph = new HashMap<>();
        for (int[] flight : flights) {
            if (!graph.containsKey(flight[0])) {
                graph.put(flight[0], new ArrayList<>());
            }
            graph.get(flight[0]).add(flight);
        }

        int minCost = Integer.MAX_VALUE;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{src, 0});
        Set<Integer> visited = new HashSet<>();

        while (!queue.isEmpty()) {
            int[] city = queue.poll();
            if (city[0] == dest && city[1] <= k) {
                minCost = Math.min(minCost, city[1]);
            }
            if (city[1] > k || visited.contains(city[0])) continue;
            visited.add(city[0]);
            for (int[] neighbor : graph.getOrDefault(city[0], new ArrayList<>())) {
                queue.add(new int[]{neighbor[2], city[1] + neighbor[1]});
            }
        }

        return minCost == Integer.MAX_VALUE ? -1 : minCost;
    }
}
```

#### Python
```python
from collections import deque

def cheapest_flight(flights, src, dest, k):
    graph = {}
    for flight in flights:
        if flight[0] not in graph:
            graph[flight[0]] = []
        graph[flight[0]].append(flight)

    min_cost = float('inf')
    queue = deque([(src, 0)])
    visited = set()

    while queue:
        city, cost = queue.popleft()
        if city == dest and cost <= k:
            min_cost = min(min_cost, cost)
        if cost > k or city in visited: continue
        visited.add(city)
        for neighbor in graph.getOrDefault(city, []):
            queue.append((neighbor[2], cost + neighbor[1]))

    return -1 if min_cost == float('inf') else min_cost
```

#### C++
```cpp
#include <queue>
#include <unordered_map>
#include <vector>

int cheapestFlight(std::vector<std::vector<int>>& flights, int src, int dest, int k) {
    std::unordered_map<int, std::vector<std::vector<int>>> graph;
    for (const auto& flight : flights) {
        if (!graph.count(flight[0])) {
            graph[flight[0]] = {};
        }
        graph[flight[0]].push_back({flight[1], flight[2]});
    }

    int minCost = INT_MAX;
    std::queue<std::vector<int>> queue;
    queue.push({src, 0});
    std::set<int> visited;

    while (!queue.empty()) {
        auto city = queue.front();
        queue.pop();
        if (city[0] == dest && city[1] <= k) {
            minCost = std::min(minCost, city[1]);
        }
        if (city[1] > k || visited.count(city[0])) continue;
        visited.insert(city[0]);
        for (const auto& neighbor : graph.atOrDefault(city[0], {})) {
            queue.push({neighbor[2], city[1] + neighbor[0]});
        }
    }

    return minCost == INT_MAX ? -1 : minCost;
}
```

#### JavaScript
```javascript
function cheapestFlight(flights, src, dest, k) {
  const graph = {};
  for (const flight of flights) {
    if (!graph[flight[0]]) {
      graph[flight[0]] = [];
    }
    graph[flight[0]].push([flight[1], flight[2]]);
  }

  let minCost = Infinity;
  const queue = [[src, 0]];
  const visited = new Set();

  while (queue.length) {
    const [city, cost] = queue.shift();
    if (city === dest && cost <= k) {
      minCost = Math.min(minCost, cost);
    }
    if (cost > k || visited.has(city)) continue;
    visited.add(city);
    for (const neighbor of graph[city] || []) {
      queue.push([neighbor[2], cost + neighbor[0]]);
    }
  }

  return minCost === Infinity ? -1 : minCost;
}
```

Note that these optimized solutions are based on the given problem description and tags, but may not be exactly the same as the original problem provided by GeeksforGeeks.