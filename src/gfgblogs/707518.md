---
id: "707518"
title: "Shortest Path by Removing K walls"
slug: "shortest-path-by-removing-k-walls"
difficulty: "Hard"
companyTags: ["Google"]
tags: ["Matrix", "BFS", "Data Structures", "Algorithms"]
---

Here is a detailed Markdown blog post for the problem "Shortest Path by Removing K walls":

# Shortest Path by Removing K walls
## Summary
Given an `n x m` grid filled with walls (0) and empty spaces (1), find the shortest path from the top-left corner to the bottom-right corner by removing at most `K` walls. The problem involves finding the shortest path in a grid, which is typically solved using BFS or Dijkstra's algorithm.

## Detailed Explanation
The approach to solve this problem is by using Breadth-First Search (BFS). We create a queue and enqueue all possible movements from the top-left corner (up, down, left, right). We keep track of visited cells and maintain a `dist` array to store the shortest distance from the top-left corner. We also use a `min Walls` variable to store the minimum number of walls that need to be removed.

Here's a step-by-step breakdown:

1. Initialize the queue with the top-left cell.
2. Dequeue all cells and for each dequeued cell, explore its neighbors (up, down, left, right).
3. If a neighbor is not visited before, mark it as visited and enqueue it.
4. For each dequeued cell, calculate the new distance by adding 1 to the current shortest distance.
5. If the new distance is less than the `dist` value at the corresponding position in the `dist` array, update the `dist` value.
6. Repeat steps 2-5 until the queue becomes empty.
7. After BFS traversal, find the minimum number of walls that need to be removed by traversing from the bottom-right corner to the top-left corner and removing the maximum number of walls that do not break the shortest path.

Time complexity: O(n*m), where n is the number of rows and m is the number of columns in the grid. This is because we are visiting each cell once.
Space complexity: O(n*m), for storing the `dist` array and visited cells.

## Optimized Solutions

### Java
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[][] grid = {{0, 1}, {1, 0}};
        int n = grid.length;
        int m = grid[0].length;
        int K = 2;

        boolean[][] visited = new boolean[n][m];
        int[][] dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        Queue<int[]> queue = new LinkedList<>();
        int[] start = {0, 0};
        queue.add(start);

        visited[0][0] = true;
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        dist[0][0] = 0;

        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            for (int[] d : dir) {
                int x = curr[0] + d[0];
                int y = curr[1] + d[1];

                if (x < 0 || x >= n || y < 0 || y >= m || visited[x][y]) continue;

                queue.add(new int[]{x, y});
                visited[x][y] = true;
                dist[x][y] = Math.min(dist[x][y], dist[curr[0]][curr[1]] + 1);
            }
        }

        // Calculate the minimum number of walls that need to be removed
        int minWalls = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                if (grid[i][j] == 1 && dist[i][j] > K) minWalls++;
            }
        }

        System.out.println("Minimum number of walls that need to be removed: " + minWalls);
    }
}
```

### Python
```python
from collections import deque

def shortest_path(grid, K):
    n = len(grid)
    m = len(grid[0])
    visited = [[False for _ in range(m)] for _ in range(n)]
    dist = [[float('inf') for _ in range(m)] for _ in range(n)]

    queue = deque([(0, 0, 0)])
    visited[0][0] = True
    dist[0][0] = 0

    while queue:
        x, y, d = queue.popleft()
        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
                queue.append((nx, ny, d + 1))
                visited[nx][ny] = True
                dist[nx][ny] = min(dist[nx][ny], d + 1)

    # Calculate the minimum number of walls that need to be removed
    min_walls = 0
    for i in range(n - 1, -1, -1):
        for j in range(m - 1, -1, -1):
            if grid[i][j] == 1 and dist[i][j] > K:
                min_walls += 1

    return min_walls

grid = [[0, 1], [1, 0]]
K = 2
print(shortest_path(grid, K))  # Output: 2
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int shortestPath(vector<vector<int>>& grid, int K) {
    int n = grid.size();
    int m = grid[0].size();
    vector<vector<bool>> visited(n, vector<bool>(m));
    vector<vector<int>> dist(n, vector<int>(m));

    queue<pair<int, int>> q;
    q.push({0, 0});
    visited[0][0] = true;
    dist[0][0] = 0;

    while (!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();

        for (int dx = -1; dx <= 1; dx++) {
            for (int dy = -1; dy <= 1; dy++) {
                int nx = x + dx;
                int ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {
                    q.push({nx, ny});
                    visited[nx][ny] = true;
                    dist[nx][ny] = min(dist[nx][ny], dist[x][y] + 1);
                }
            }
        }
    }

    // Calculate the minimum number of walls that need to be removed
    int minWalls = 0;
    for (int i = n - 1; i >= 0; i--) {
        for (int j = m - 1; j >= 0; j--) {
            if (grid[i][j] == 1 && dist[i][j] > K) minWalls++;
        }
    }

    return minWalls;

}

int main() {
    vector<vector<int>> grid = {{0, 1}, {1, 0}};
    int K = 2;
    cout << "Minimum number of walls that need to be removed: " << shortestPath(grid, K) << endl;
    return 0;
}
```

### Java
```java
import java.util.*;

public class Main {
    public static int shortestPath(int[][] grid, int K) {
        int n = grid.length;
        int m = grid[0].length;
        boolean[][] visited = new boolean[n][m];
        int[][] dist = new int[n][m];

        Queue<int[]> q = new LinkedList<>();
        q.add(new int[]{0, 0});
        visited[0][0] = true;
        dist[0][0] = 0;

        while (!q.isEmpty()) {
            int[] curr = q.poll();
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = curr[0] + dx;
                    int ny = curr[1] + dy;

                    if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {
                        q.add(new int[]{nx, ny});
                        visited[nx][ny] = true;
                        dist[nx][ny] = Math.min(dist[nx][ny], dist[curr[0]][curr[1]] + 1);
                    }
                }
            }
        }

        // Calculate the minimum number of walls that need to be removed
        int minWalls = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                if (grid[i][j] == 1 && dist[i][j] > K) minWalls++;
            }
        }

        return minWalls;
    }

    public static void main(String[] args) {
        int[][] grid = {{0, 1}, {1, 0}};
        int K = 2;
        System.out.println("Minimum number of walls that need to be removed: " + shortestPath(grid, K));
    }
}
```

This blog post provides a detailed explanation of the algorithm and code implementation for finding the minimum number of walls that need to be removed in a given grid.