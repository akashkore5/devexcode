---
id: "712174"
title: "Frog Jump"
slug: "geek-jump"
difficulty: "Medium"
companyTags: []
tags: ["Dynamic Programming", "Arrays", "Data Structures"]
---

**Frog Jump**
================

### Slug: geek-jump
### Difficulty: Medium
### Id: 712174
### Topic Tags: Dynamic Programming, Arrays, Data Structures
### Company Tags: None

## Summary
The Frog Jump problem is a classic dynamic programming challenge that requires you to find the minimum number of jumps required for a frog to reach a target position on a log. The log has multiple positions, and each position can be jumped from by the frog with a certain distance. The goal is to minimize the total number of jumps while ensuring the frog reaches the target position.

## Detailed Explanation

To solve this problem, we'll use dynamic programming to build up a table that represents the minimum number of jumps required for the frog to reach each position on the log. We'll start by initializing an array `dp` of size `n`, where `n` is the total length of the log.

The base case for our dynamic programming approach is when the target position is reached (`target == i`). In this case, the minimum number of jumps required is 0, since we've already reached the target.

For other positions `i`, we'll consider the minimum number of jumps required to reach each of the possible jumping positions from `i`. We'll iterate over these jumping positions and calculate the minimum number of jumps required to reach each position. This will be the sum of the minimum number of jumps required to reach the current position plus 1 (for the current jump).

Here's a step-by-step breakdown of the solution:

1. Initialize an array `dp` of size `n`.
2. Set `dp[0] = 0`, since we've already reached the starting position.
3. Iterate over each position `i` on the log:
	* If `target == i`, set `dp[i] = 0`, since we've already reached the target.
	* Otherwise, iterate over each possible jumping position from `i`.
	* For each jumping position `j`, calculate the minimum number of jumps required to reach `j`. This is the sum of the minimum number of jumps required to reach the current position (`dp[i-1]`) plus 1 (for the current jump).
	* Update `dp[j]` with the minimum value between its current value and the calculated value.
4. Return `dp[target]`, which represents the minimum number of jumps required for the frog to reach the target position.

Time complexity: O(n), where n is the total length of the log.
Space complexity: O(n), since we need to store the dynamic programming table.

## Optimized Solutions

### Java
```java
public int minJumps(int[] logs) {
    int n = logs.length;
    boolean[] visited = new boolean[n];
    Queue<Integer> queue = new LinkedList<>();
    int target = 0; // find the target position
    for (int i = 0; i < n; i++) {
        if (logs[i] == target) {
            target = i + 1;
        }
    }

    queue.offer(0);
    visited[0] = true;

    int jumps = 0;
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            int pos = queue.poll();
            if (pos == target) {
                return jumps;
            }
            for (int j = 1; j <= logs[pos]; j++) {
                int nextPos = pos + j;
                if (!visited[nextPos]) {
                    visited[nextPos] = true;
                    queue.offer(nextPos);
                }
            }
        }
        jumps++;
    }

    return -1; // target not reachable
}
```

### Python
```python
def min_jumps(logs):
    n = len(logs)
    visited = [False] * n
    queue = []
    target = 0
    for i in range(n):
        if logs[i] == target:
            target = i + 1

    queue.append(0)
    visited[0] = True

    jumps = 0
    while queue:
        size = len(queue)
        for _ in range(size):
            pos = queue.pop(0)
            if pos == target:
                return jumps
            for j in range(1, logs[pos] + 1):
                next_pos = pos + j
                if not visited[next_pos]:
                    visited[next_pos] = True
                    queue.append(next_pos)
        jumps += 1

    return -1  # target not reachable
```

### C++
```cpp
int minJumps(vector<int>& logs) {
    int n = logs.size();
    vector<bool> visited(n, false);
    queue<int> q;
    int target = 0; // find the target position
    for (int i = 0; i < n; i++) {
        if (logs[i] == target) {
            target = i + 1;
        }
    }

    q.push(0);
    visited[0] = true;

    int jumps = 0;
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int pos = q.front();
            q.pop();
            if (pos == target) {
                return jumps;
            }
            for (int j = 1; j <= logs[pos]; j++) {
                int nextPos = pos + j;
                if (!visited[nextPos]) {
                    visited[nextPos] = true;
                    q.push(nextPos);
                }
            }
        }
        jumps++;
    }

    return -1; // target not reachable
}
```

### JavaScript
```javascript
function minJumps(logs) {
  let n = logs.length;
  let visited = new Array(n).fill(false);
  let queue = [];
  let target = 0;
  for (let i = 0; i < n; i++) {
    if (logs[i] === target) {
      target = i + 1;
    }
  }

  queue.push(0);
  visited[0] = true;

  let jumps = 0;
  while (queue.length > 0) {
    let size = queue.length;
    for (let i = 0; i < size; i++) {
      let pos = queue.shift();
      if (pos === target) {
        return jumps;
      }
      for (let j = 1; j <= logs[pos]; j++) {
        let nextPos = pos + j;
        if (!visited[nextPos]) {
          visited[nextPos] = true;
          queue.push(nextPos);
        }
      }
    }
    jumps++;
  }

  return -1; // target not reachable
}
```