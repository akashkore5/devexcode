---
id: "712323"
title: "Task Scheduler"
slug: "task-scheduler"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Hash", "Greedy", "Data Structures", "Algorithms"]
---

**Task Scheduler**
==================

**Slug:** task-scheduler
**Difficulty:** Medium
**Id:** 712323
**Topic Tags:** Arrays, Hash, Greedy, Data Structures, Algorithms

## Summary
The Task Scheduler problem involves scheduling tasks based on their priority and deadline. You are given a list of tasks with their corresponding priorities and deadlines. The goal is to schedule these tasks in a way that maximizes the overall priority while meeting the deadlines.

## Detailed Explanation

To solve this problem, we can use a greedy approach. First, sort the tasks by their deadlines. Then, iterate over the sorted tasks and assign them to the earliest possible time slot that meets their deadline. If multiple tasks have the same deadline, prioritize the one with the highest priority.

Here's a step-by-step breakdown of the solution:

1. Sort the tasks by their deadlines.
2. Initialize an empty schedule array.
3. Iterate over the sorted tasks:
   * For each task, find the earliest possible time slot that meets its deadline. If no such time slot exists, skip this task.
   * Assign the task to the found time slot and increment the time slot's priority by the task's priority.
4. Return the schedule array.

Here's an example:

Suppose we have the following tasks:

| Task ID | Priority | Deadline |
| --- | --- | --- |
| 1     | 3       | 2        |
| 2     | 2       | 1        |
| 3     | 4       | 3        |
| 4     | 1       | 4        |

We can sort the tasks by their deadlines as follows:

| Task ID | Priority | Deadline |
| --- | --- | --- |
| 4     | 1       | 4        |
| 3     | 4       | 3        |
| 2     | 2       | 1        |
| 1     | 3       | 2        |

Now, we can assign the tasks to time slots:

* Time slot 0: Priority 1 (Task 4)
* Time slot 1: Priority 2 + 3 = 5 (Tasks 2 and 1)
* Time slot 2: Priority 4 (Task 3)

The final schedule is:

| Time Slot | Priority |
| --- | --- |
| 0     | 1       |
| 1     | 5       |
| 2     | 4       |

Time complexity: O(n log n) due to the sorting step.
Space complexity: O(1) since we only use a constant amount of space to store the schedule.

## Optimized Solutions
### Java
```
java
public class TaskScheduler {
    public static int[] scheduler(int[][] tasks) {
        Arrays.sort(tasks, (a, b) -> a[2] - b[2]);
        List<Integer> schedule = new ArrayList<>();
        for (int[] task : tasks) {
            int timeSlot = 0;
            while (timeSlot < task[2]) {
                if (schedule.isEmpty() || schedule.get(timeSlot) + task[1] <= task[2]) {
                    schedule.add(timeSlot, task[1]);
                    break;
                }
                timeSlot++;
            }
        }
        return schedule.stream().mapToInt(Integer::intValue).toArray();
    }
}
```
### Python
```
python
def scheduler(tasks):
    tasks.sort(key=lambda x: x[2])
    schedule = []
    for task in tasks:
        time_slot = 0
        while time_slot < task[2]:
            if not schedule or schedule[time_slot] + task[1] <= task[2]:
                schedule.append(task[1])
                break
            time_slot += 1
    return [int(x) for x in schedule]
```
### C++
```
cpp
#include <algorithm>
#include <vector>

std::vector<int> scheduler(std::vector<std::vector<int>>& tasks) {
    std::sort(tasks.begin(), tasks.end(), [](const auto& a, const auto& b) {
        return a[2] < b[2];
    });
    std::vector<int> schedule;
    for (const auto& task : tasks) {
        int time_slot = 0;
        while (time_slot < task[2]) {
            if (schedule.empty() || schedule[time_slot] + task[1] <= task[2]) {
                schedule.push_back(task[1]);
                break;
            }
            time_slot++;
        }
    }
    return schedule;
}
```
### JavaScript
```
javascript
function scheduler(tasks) {
  tasks.sort((a, b) => a[2] - b[2]);
  const schedule = [];
  for (const task of tasks) {
    let timeSlot = 0;
    while (timeSlot < task[2]) {
      if (!schedule.length || schedule[timeSlot] + task[1] <= task[2]) {
        schedule.push(task[1]);
        break;
      }
      timeSlot++;
    }
  }
  return schedule.map(x => parseInt(x));
}
```