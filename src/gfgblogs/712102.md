---
id: "712102"
title: "Sum of Beauty of All Substrings"
slug: "sum-of-beauty-of-all-substrings-1662962118"
difficulty: "Medium"
companyTags: []
tags: ["Strings", "Data Structures"]
---

Here is a detailed Markdown blog post for the GeeksforGeeks problem "Sum of Beauty of All Substrings":

**712102: Sum of Beauty of All Substrings**

## Summary
Given a string `s`, we need to find the sum of beauty of all substrings. The beauty of a substring is the product of its length and the frequency of each character in that substring.

## Detailed Explanation

To solve this problem, we can start by considering the definition of beauty for a given substring. The beauty is calculated as the product of the length of the substring and the frequency of each unique character in the substring.

We can use a dictionary to store the frequency of characters in the current window (substring). Initialize an empty dictionary `freq` to store the frequency of characters. Then, iterate over the string `s`. For each character `c`, increment its count in the `freq` dictionary.

Next, calculate the beauty for each substring by multiplying the length of the substring with the sum of frequencies of all unique characters in that substring. To achieve this, we can use a variable `sum_freq` to keep track of the sum of frequencies and then multiply it with the length of the current substring.

Finally, add up the beauty values for all substrings using a variable `total_beauty`. This will give us the total sum of beauty for all substrings.

Here is a step-by-step breakdown:

1. Initialize an empty dictionary `freq` to store the frequency of characters.
2. Iterate over the string `s`.
3. For each character `c`, increment its count in the `freq` dictionary.
4. Calculate the beauty for each substring by multiplying the length of the substring with the sum of frequencies of all unique characters in that substring.
5. Add up the beauty values for all substrings using a variable `total_beauty`.

Time complexity: O(n), where n is the length of the string `s`. We are iterating over the string once.

Space complexity: O(min(n, 26)), as we need to store the frequency of characters in the dictionary. If the frequency of any character exceeds the size of the alphabet (26), we can consider increasing the space complexity to O(n).

## Optimized Solutions

### Java
```java
public class Main {
    public static void main(String[] args) {
        String s = "abc";
        int totalBeauty = 0;
        for (int i = 0; i < s.length(); i++) {
            for (int j = i; j < s.length(); j++) {
                String substring = s.substring(i, j + 1);
                int beauty = substring.length() * getFrequency(substring).stream().mapToInt(Integer::intValue).sum();
                totalBeauty += beauty;
            }
        }
        System.out.println(totalBeauty);
    }

    public static HashMap<Character, Integer> getFrequency(String str) {
        HashMap<Character, Integer> freqMap = new HashMap<>();
        for (char c : str.toCharArray()) {
            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
        }
        return freqMap;
    }
}
```

### Python
```python
def total_beauty(s):
    total = 0
    for i in range(len(s)):
        for j in range(i, len(s)):
            substring = s[i:j+1]
            beauty = len(substring) * sum(get_freq(substring).values())
            total += beauty
    return total

def get_freq(substring):
    freq = {}
    for c in substring:
        freq[c] = freq.get(c, 0) + 1
    return freq

print(total_beauty("abc"))
```

### C++
```cpp
#include <iostream>
#include <unordered_map>
#include <string>

int totalBeauty(std::string s) {
    int total = 0;
    for (int i = 0; i < s.length(); i++) {
        for (int j = i; j < s.length(); j++) {
            std::string substring = s.substr(i, j - i + 1);
            int beauty = substring.length() * getFrequency(substring).size();
            total += beauty;
        }
    }
    return total;

}

std::unordered_map<char, int> getFrequency(std::string str) {
    std::unordered_map<char, int> freqMap;
    for (char c : str) {
        freqMap[c] = freqMap.get(c, 0) + 1;
    }
    return freqMap;

}
int main() {
    std::cout << totalBeauty("abc") << std::endl;
    return 0;
}
```

### JavaScript
```javascript
function getFrequency(str) {
    let freq = {};
    for (let c of str) {
        freq[c] = freq.get(c, 0) + 1;
    }
    return freq;
}

function totalBeauty(s) {
    let total = 0;
    for (let i = 0; i < s.length; i++) {
        for (let j = i; j < s.length; j++) {
            let substring = s.slice(i, j + 1);
            let beauty = substring.length * Object.values(getFrequency(substring)).reduce((a, b) => a + b);
            total += beauty;
        }
    }
    return total;

}

console.log(totalBeauty("abc"));
```

Note: The optimized solutions are provided for each programming language.