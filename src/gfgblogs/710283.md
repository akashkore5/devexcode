---
id: "710283"
title: "Geek in a Maze"
slug: "geek-in-a-maze--170637"
difficulty: "Hard"
companyTags: []
tags: ["Graph", "Data Structures"]
---

Here is a detailed Markdown blog post for the "Geek in a Maze" problem:

**Geek in a Maze**
==================

### Summary
The "Geek in a Maze" problem involves finding the shortest path from a starting point to an exit in a maze. The maze is represented as a graph, where each cell is connected to its neighbors (horizontally, vertically, and diagonally). The goal is to find the shortest path that allows the geek to escape the maze.

### Detailed Explanation
The problem can be solved using Breadth-First Search (BFS) algorithm. BFS is an efficient algorithm for finding the shortest path in a graph or tree data structure.

Here's a step-by-step breakdown of the solution:

1. Create a queue and enqueue the starting point.
2. Mark the starting point as visited.
3. While the queue is not empty, do the following:
	* Dequeue the next cell from the queue.
	* If this cell is the exit, return the path from the starting point to this cell (using backtracking).
	* For each unvisited neighbor of this cell, mark it as visited and enqueue it.
4. If the queue becomes empty without finding the exit, there is no possible escape route.

Here's a diagram illustrating the BFS traversal:
```
  +-----+-----+
  |     |     |
  | S  ->| E    |
  |     |     |
  +-----+-----+
   ^         ^
   |         |
   |  visited  |
   |         |
   v         v
  +-----+-----+
  |     |     |
  | *  ->|*    |
  |     |     |
  +-----+-----+
```
In this diagram, `S` is the starting point, `E` is the exit, and `*` represents visited cells.

Time complexity: O(V + E), where V is the number of vertices (cells) in the maze and E is the number of edges (connections between cells).
Space complexity: O(V), since we need to keep track of visited cells.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class GeekInAMaze {
    public static int[] findShortestPath(int[][] maze, int startRow, int startCol, int exitRow, int exitCol) {
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[maze.length][maze[0].length];
        queue.add(new int[]{startRow, startCol});
        visited[startRow][startCol] = true;

        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            if (cell[0] == exitRow && cell[1] == exitCol) {
                return backtrack(cell);
            }

            for (int[] neighbor : getNeighbors(maze, cell)) {
                if (!visited[neighbor[0]][neighbor[1]]) {
                    queue.add(neighbor);
                    visited[neighbor[0]][neighbor[1]] = true;
                }
            }
        }

        return null; // no escape route found
    }

    private static int[] backtrack(int[] cell) {
        List<int[]> path = new ArrayList<>();
        while (cell != null) {
            path.add(cell);
            cell = getPreviousCell(maze, cell);
        }
        return path.toArray(new int[0]);
    }

    private static int[][] getNeighbors(int[][] maze, int[] cell) {
        List<int[]> neighbors = new ArrayList<>();

        // check horizontal and vertical neighbors
        for (int i = -1; i <= 1; i++) {
            for (int j = -1; j <= 1; j++) {
                if (i == 0 && j == 0) continue;
                int newRow = cell[0] + i;
                int newCol = cell[1] + j;

                // check if neighbor is within maze boundaries and is not a wall
                if (newRow >= 0 && newRow < maze.length && newCol >= 0 && newCol < maze[0].length && maze[newRow][newCol] == 0) {
                    neighbors.add(new int[]{newRow, newCol});
                }
            }
        }

        return neighbors.toArray(new int[0][]);
    }

    private static int[] getPreviousCell(int[][] maze, int[] cell) {
        // implement this method to find the previous cell in the path
        // ...
    }
}
```

#### Python
```python
from collections import deque

def find_shortest_path(maze, start_row, start_col, exit_row, exit_col):
    queue = deque()
    visited = [[False for _ in range(len(maze[0]))] for _ in range(len(maze))]
    queue.append((start_row, start_col))
    visited[start_row][start_col] = True

    while queue:
        cell = queue.popleft()
        if cell == (exit_row, exit_col):
            return backtrack(cell)

        for neighbor in get_neighbors(maze, cell):
            if not visited[neighbor[0]][neighbor[1]]:
                queue.append(neighbor)
                visited[neighbor[0]][neighbor[1]] = True

    return None  # no escape route found

def backtrack(cell):
    path = []
    while cell:
        path.append(cell)
        cell = get_previous_cell(maze, cell)
    return [x for x in reversed(path)]

def get_neighbors(maze, cell):
    neighbors = []

    # check horizontal and vertical neighbors
    for i in range(-1, 2):
        for j in range(-1, 2):
            if i == 0 and j == 0:
                continue
            new_row = cell[0] + i
            new_col = cell[1] + j

            # check if neighbor is within maze boundaries and is not a wall
            if (0 <= new_row < len(maze) and 0 <= new_col < len(maze[0]) and maze[new_row][new_col] == 0):
                neighbors.append((new_row, new_col))

    return neighbors

def get_previous_cell(maze, cell):
    # implement this method to find the previous cell in the path
    # ...
```

#### C++
```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

struct Cell {
    int row;
    int col;
};

int findShortestPath(vector<vector<int>>& maze, int startRow, int startCol, int exitRow, int exitCol) {
    queue<Cell> queue;
    vector<vector<bool>> visited(maze.size(), vector<bool>(maze[0].size()));
    queue.push({startRow, startCol});
    visited[startRow][startCol] = true;

    while (!queue.empty()) {
        Cell cell = queue.front();
        queue.pop();
        if (cell.row == exitRow && cell.col == exitCol) {
            return backtrack(cell);
        }

        for (Cell neighbor : getNeighbors(maze, cell)) {
            if (!visited[neighbor.row][neighbor.col]) {
                queue.push(neighbor);
                visited[neighbor.row][neighbor.col] = true;
            }
        }
    }

    return -1; // no escape route found
}

int backtrack(Cell cell) {
    vector<Cell> path;
    while (cell != {0, 0}) {
        path.push_back(cell);
        cell = getPreviousCell(maze, cell);
    }
    return path.size();
}

vector<Cell> getNeighbors(vector<vector<int>>& maze, Cell cell) {
    vector<Cell> neighbors;

    // check horizontal and vertical neighbors
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            if (i == 0 && j == 0) continue;
            int newRow = cell.row + i;
            int newCol = cell.col + j;

            // check if neighbor is within maze boundaries and is not a wall
            if (newRow >= 0 && newRow < maze.size() && newCol >= 0 && newCol < maze[0].size() && maze[newRow][newCol] == 0) {
                neighbors.push_back({newRow, newCol});
            }
        }
    }

    return neighbors;
}

Cell getPreviousCell(vector<vector<int>>& maze, Cell cell) {
    // implement this method to find the previous cell in the path
    // ...
}
```

#### JavaScript
```javascript
function findShortestPath(maze, startRow, startCol, exitRow, exitCol) {
  const queue = [];
  const visited = new Array(maze.length).fill().map(() => new Array(maze[0].length).fill(false));
  queue.push({ row: startRow, col: startCol });
  visited[startRow][startCol] = true;

  while (queue.length > 0) {
    const cell = queue.shift();
    if (cell.row === exitRow && cell.col === exitCol) {
      return backtrack(cell);
    }

    for (const neighbor of getNeighbors(maze, cell)) {
      if (!visited[neighbor.row][neighbor.col]) {
        queue.push(neighbor);
        visited[neighbor.row][neighbor.col] = true;
      }
    }
  }

  return null; // no escape route found
}

function backtrack(cell) {
  const path = [];
  while (cell !== { row: 0, col: 0 }) {
    path.unshift(cell);
    cell = getPreviousCell(maze, cell);
  }
  return path;
}

function getNeighbors(maze, cell) {
  const neighbors = [];

  // check horizontal and vertical neighbors
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) continue;
      const newRow = cell.row + i;
      const newCol = cell.col + j;

      // check if neighbor is within maze boundaries and is not a wall
      if (newRow >= 0 && newRow < maze.length && newCol >= 0 && newCol < maze[0].length && maze[newRow][newCol] === 0) {
        neighbors.push({ row: newRow, col: newCol });
      }
    }
  }

  return neighbors;
}

function getPreviousCell(maze, cell) {
  // implement this method to find the previous cell in the path
  // ...
}
```

Note that these implementations are not complete and may require additional logic to correctly implement the algorithm.