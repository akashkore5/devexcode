---
id: "700138"
title: "Reorder List"
slug: "reorder-list"
difficulty: "Hard"
companyTags: ["Amazon", "Microsoft", "OYO Rooms", "Intuit"]
tags: ["Linked List", "Data Structures"]
---

Here is a detailed Markdown blog post for the "Reorder List" problem:

# Reorder List
## Summary
Given a singly linked list, reorder its nodes such that all even indices are placed to the right of odd indices. For example, if the input list is 1 -> 2 -> 3 -> 4 -> 5, the output should be 1 -> 3 -> 5 -> 2 -> 4.

This problem involves manipulating a linked list and requires an understanding of basic data structures and algorithms.

## Detailed Explanation
The key to solving this problem is to maintain two pointers: one for even indices and another for odd indices. We iterate through the linked list, moving the pointers accordingly. Whenever we encounter an even-indexed node, we move the even pointer ahead by one step. Similarly, whenever we encounter an odd-indexed node, we move the odd pointer ahead by one step.

Here's a step-by-step breakdown of the solution:

1. Initialize two pointers: `even` and `odd`. Set `even` to the head of the linked list and set `odd` to the next node.
2. Iterate through the linked list until `odd` reaches the end.
3. When we encounter an even-indexed node (i.e., `even` is pointing to it), move `even` ahead by one step.
4. When we encounter an odd-indexed node (i.e., `odd` is pointing to it), swap the nodes at `even` and `odd`. Move both pointers ahead by one step.
5. Repeat steps 2-4 until `odd` reaches the end.

Time complexity: O(n), where n is the number of nodes in the linked list. We only iterate through the linked list once, so the time complexity is linear.
Space complexity: O(1), since we only use a constant amount of space to store the two pointers and no extra data structures are required.

## Optimized Solutions
### Java
```java
public ListNode reorderList(ListNode head) {
    if (head == null || head.next == null) return head;

    // Find the middle of the linked list
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // Reverse the second half of the linked list
    ListNode mid = slow.next;
    slow.next = null;

    // Merge the two halves in alternating order
    ListNode dummy = new ListNode(0);
    ListNode curr = dummy;
    while (head != null || mid != null) {
        if (head == null) head = mid;
        else if (mid == null) mid = head;
        curr.next = head;
        head = head.next;
        curr = curr.next;

        curr.next = mid;
        mid = mid.next;
        curr = curr.next;
    }

    return dummy.next;
}
```
### Python
```python
def reorder_list(head):
    if not head or not head.next: return head

    # Find the middle of the linked list
    slow = head
    fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    # Reverse the second half of the linked list
    mid = slow.next
    slow.next = None

    # Merge the two halves in alternating order
    dummy = ListNode(0)
    curr = dummy
    while head or mid:
        if not head: head = mid
        else if not mid: mid = head
        curr.next = head
        head = head.next
        curr = curr.next

        curr.next = mid
        mid = mid.next
        curr = curr.next

    return dummy.next
```
### C++
```cpp
ListNode* reorderList(ListNode* head) {
    if (head == nullptr || head->next == nullptr) return head;

    // Find the middle of the linked list
    ListNode* slow = head;
    ListNode* fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // Reverse the second half of the linked list
    ListNode* mid = slow->next;
    slow->next = nullptr;

    // Merge the two halves in alternating order
    ListNode dummy(0);
    ListNode* curr = &dummy;
    while (head || mid) {
        if (!head) head = mid;
        else if (!mid) mid = head;
        curr->next = head;
        head = head->next;
        curr = curr->next;

        curr->next = mid;
        mid = mid->next;
        curr = curr->next;
    }

    return dummy.next;
}
```
### JavaScript
```javascript
function reorderList(head) {
    if (!head || !head.next) return head;

    // Find the middle of the linked list
    let slow = head;
    let fast = head;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // Reverse the second half of the linked list
    let mid = slow.next;
    slow.next = null;

    // Merge the two halves in alternating order
    const dummy = { next: null };
    let curr = dummy;
    while (head || mid) {
        if (!head) head = mid;
        else if (!mid) mid = head;
        curr.next = head;
        head = head.next;
        curr = curr.next;

        curr.next = mid;
        mid = mid.next;
        curr = curr.next;
    }

    return dummy.next;
}
```
Note: The above solutions are optimized and assume that the input linked list is singly linked.