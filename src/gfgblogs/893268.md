---
id: "893268"
title: "Minimum Weight Cycle"
slug: "minimum-weight-cycle"
difficulty: "Hard"
companyTags: []
tags: []
---

Here is the detailed Markdown blog post for the Minimum Weight Cycle problem:

**Minimum Weight Cycle**
================================

## Summary
The Minimum Weight Cycle problem involves finding the minimum weight cycle in a graph. A cycle is a path that starts and ends at the same vertex, while the weight of a cycle is the sum of its edge weights. The goal is to find the cycle with the minimum total weight.

## Detailed Explanation
To solve this problem, we'll use a dynamic programming approach. We'll create a 2D array `dp` where `dp[i][j]` represents the minimum weight of the path from vertex `i` to vertex `j`. We'll also maintain an array `prev` to keep track of the previous vertex in the optimal cycle.

Here's the step-by-step breakdown:

1. Initialize `dp` and `prev` arrays with infinite values.
2. For each vertex `i`, calculate the minimum weight of the path from `i` to itself, which is simply the weight of the edge incident on `i`.
3. For each pair of vertices `(i, j)`, update `dp[i][j]` as the minimum weight of the path from `i` to `j`. If `dp[i][j]` is less than the current minimum weight, update it and set `prev[j] = i`.
4. To find the minimum weight cycle, iterate through the vertices and keep track of the vertex with the minimum weight in the cycle.
5. Use `prev` array to construct the minimum weight cycle.

Here's an ASCII art diagram illustrating the dynamic programming approach:
```
  +--------+
  |   i    |
  +--------+
       |
       v
  +--------+
  |  dp[i][j] |
  |  (min weight)|
  +--------+
       ^
       |
  +--------+
  |  prev[j] = i |
  +--------+
```
Time complexity: O(|E| \* |V|), where `|E|` is the number of edges and `|V|` is the number of vertices. Space complexity: O(|V|^2).

## Optimized Solutions
### Java

```java
public class MinimumWeightCycle {
    public static int minWeightCycle(int[][] graph) {
        int n = graph.length;
        int[] dp = new int[n];
        int[] prev = new int[n];

        for (int i = 0; i < n; i++) {
            dp[i] = Integer.MAX_VALUE;
            prev[i] = -1;
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] != 0) {
                    if (dp[j] > dp[i] + graph[i][j]) {
                        dp[j] = dp[i] + graph[i][j];
                        prev[j] = i;
                    }
                }
            }
        }

        int minWeight = Integer.MAX_VALUE;
        int startVertex = -1;

        for (int i = 0; i < n; i++) {
            if (dp[i] < minWeight) {
                minWeight = dp[i];
                startVertex = i;
            }
        }

        return minWeight;
    }
}
```

### Python

```python
def min_weight_cycle(graph):
    n = len(graph)
    dp = [float('inf')] * n
    prev = [-1] * n

    for i in range(n):
        dp[i] = float('inf')
        prev[i] = -1

    for i in range(n):
        for j in range(n):
            if graph[i][j] != 0:
                if dp[j] > dp[i] + graph[i][j]:
                    dp[j] = dp[i] + graph[i][j]
                    prev[j] = i

    min_weight = float('inf')
    start_vertex = -1

    for i in range(n):
        if dp[i] < min_weight:
            min_weight = dp[i]
            start_vertex = i

    return min_weight
```

### C++

```cpp
#include <iostream>
using namespace std;

int minWeightCycle(int graph[][6]) {
    int n = 6;
    int dp[n];
    int prev[n];

    for (int i = 0; i < n; i++) {
        dp[i] = INT_MAX;
        prev[i] = -1;
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (graph[i][j] != 0) {
                if (dp[j] > dp[i] + graph[i][j]) {
                    dp[j] = dp[i] + graph[i][j];
                    prev[j] = i;
                }
            }
        }
    }

    int minWeight = INT_MAX;
    int startVertex = -1;

    for (int i = 0; i < n; i++) {
        if (dp[i] < minWeight) {
            minWeight = dp[i];
            startVertex = i;
        }
    }

    return minWeight;
}

int main() {
    int graph[][6] = {{0, 2, 0, 6, 0, 7},
                       {2, 0, 3, 8, 5, 0},
                       {0, 3, 0, 10, 0, 15},
                       {6, 8, 10, 0, 12, 0},
                       {0, 5, 0, 12, 0, 9},
                       {7, 0, 15, 0, 9, 0}};
    cout << "Minimum weight cycle: " << minWeightCycle(graph) << endl;
    return 0;
}
```

### JavaScript

```javascript
function minWeightCycle(graph) {
    const n = graph.length;
    const dp = new Array(n).fill(Number.MAX_VALUE);
    const prev = new Array(n).fill(-1);

    for (let i = 0; i < n; i++) {
        dp[i] = Number.MAX_VALUE;
        prev[i] = -1;
    }

    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (graph[i][j] !== 0) {
                if (dp[j] > dp[i] + graph[i][j]) {
                    dp[j] = dp[i] + graph[i][j];
                    prev[j] = i;
                }
            }
        }
    }

    let minWeight = Number.MAX_VALUE;
    let startVertex = -1;

    for (let i = 0; i < n; i++) {
        if (dp[i] < minWeight) {
            minWeight = dp[i];
            startVertex = i;
        }
    }

    return minWeight;
}
```

Note that the optimized solutions are provided in different programming languages, but the approach remains the same.