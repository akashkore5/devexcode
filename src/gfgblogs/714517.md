---
id: "714517"
title: "Tree Transformation"
slug: "tree-transformation--170648"
difficulty: "Medium"
companyTags: []
tags: ["Tree", "Data Structures"]
---

**Tree Transformation**
====================================

### Summary

The Tree Transformation problem involves transforming a tree into another tree based on specific rules. The task is to write an algorithm that takes a given tree as input and returns the transformed tree. This problem requires understanding of tree traversal techniques, node manipulation, and data structure operations.

### Detailed Explanation

Given a tree T, we need to transform it into another tree T' by applying certain operations. These operations include:

* For each node in T, if its value is even, change it to the next multiple of 4.
* If the value is odd, change it to the next multiple of 3.

We can solve this problem using a depth-first search (DFS) algorithm. Here's a step-by-step breakdown of the solution:

1. Start at the root node and perform DFS traversal.
2. For each node, check if its value is even or odd.
3. If the value is even, calculate the next multiple of 4 and update the node's value.
4. If the value is odd, calculate the next multiple of 3 and update the node's value.
5. Recursively traverse the left subtree and then the right subtree.
6. Repeat steps 2-5 until all nodes have been processed.

Time complexity: O(N), where N is the number of nodes in the tree.
Space complexity: O(H), where H is the height of the tree (in a balanced binary tree, H = logN).

### Optimized Solutions

#### Java
```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

public class TreeTransformer {
    public static TreeNode transformTree(TreeNode root) {
        if (root == null) return null;

        int newVal = (root.val % 2 == 0) ? root.val + (4 - root.val % 4) : root.val + (3 - root.val % 3);
        root.val = newVal;

        root.left = transformTree(root.left);
        root.right = transformTree(root.right);

        return root;
    }
}
```

#### Python
```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def transform_tree(root):
    if not root: return None

    new_val = (root.val % 2 == 0) * (4 - root.val % 4) + (root.val % 3 == 1)
    root.val = new_val

    root.left = transform_tree(root.left)
    root.right = transform_tree(root.right)

    return root
```

#### C++
```cpp
struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;

    TreeNode(int val) : val(val), left(nullptr), right(nullptr) {}
};

TreeNode* transformTree(TreeNode* root) {
    if (root == nullptr) return nullptr;

    int newVal = (root->val % 2 == 0) ? root->val + (4 - root->val % 4) : root->val + (3 - root->val % 3);
    root->val = newVal;

    root->left = transformTree(root->left);
    root->right = transformTree(root->right);

    return root;
}
```

#### JavaScript
```javascript
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function transformTree(root) {
    if (!root) return null;

    let newVal = (root.val % 2 === 0) ? root.val + (4 - root.val % 4) : root.val + (3 - root.val % 3);
    root.val = newVal;

    root.left = transformTree(root.left);
    root.right = transformTree(root.right);

    return root;
}
```