---
id: "714324"
title: "Palindrome with minimum sum"
slug: "palindrome-with-minimum-sum--170648"
difficulty: "Medium"
companyTags: []
tags: ["Strings", "Data Structures"]
---

**Palindrome with Minimum Sum**
=====================================================

## Summary
Given a string, find all palindromic subsequences and return the one with the minimum sum of characters. A palindrome is a sequence that reads the same backward as forward.

This problem involves manipulating strings to find palindromes, which requires understanding of character sequences and their properties. The key concepts involved are strings, subsequences, and palindromes.

## Detailed Explanation
To solve this problem, we can start by generating all possible subsequences of the given string. Then, for each subsequence, check if it's a palindrome by comparing characters from both ends towards the center. If it is a palindrome, calculate its sum and keep track of the minimum sum found so far.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty list `palindromes` to store all palindromic subsequences.
2. Generate all possible subsequences of the given string using a recursive function or a dynamic programming approach.
3. For each subsequence, check if it's a palindrome by comparing characters from both ends towards the center. If it is a palindrome, calculate its sum and add it to the `palindromes` list.
4. Initialize a variable `min_sum` to store the minimum sum of palindromic subsequences found so far.
5. Iterate through the `palindromes` list and update `min_sum` if a smaller sum is found.
6. Return the palindrome with the minimum sum.

Here's an ASCII art diagram illustrating the process:

```
  +---------------+
  |  Given String  |
  +---------------+
           |
           v
  +---------------+
  |  Generate Subsequences  |
  |  (Recursive/Dynamic)    |
  +---------------+
           |
           v
  +---------------+
  |  Check for Palindromes  |
  |  (Compare characters)   |
  +---------------+
           |
           v
  +---------------+
  |  Calculate Sum and Store  |
  |  (Palindromic Subsequences)|
  +---------------+
           |
           v
  +---------------+
  |  Find Minimum Sum      |
  |  (Iterate through list)  |
  +---------------+
           |
           v
  +---------------+
  |  Return Palindrome with Min Sum  |
  +---------------+
```

Time complexity: O(n^2), where n is the length of the given string. This is because we generate all possible subsequences, which has a time complexity of O(n^2). Then, for each subsequence, we check if it's a palindrome in linear time.

Space complexity: O(n), where n is the length of the given string. This is because we store all palindromic subsequences in a list.

## Optimized Solutions
Here are optimized solutions in various programming languages:

### Java
```java
public class Palindrome {
    public static int minSumPalindrome(String s) {
        int minSum = Integer.MAX_VALUE;
        for (int i = 0; i < s.length(); i++) {
            for (int j = i + 1; j <= s.length(); j++) {
                String sub = s.substring(i, j);
                if (isPalindrome(sub)) {
                    int sum = getSum(sub);
                    if (sum < minSum) {
                        minSum = sum;
                    }
                }
            }
        }
        return minSum;
    }

    private static boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    private static int getSum(String s) {
        int sum = 0;
        for (char c : s.toCharArray()) {
            sum += c;
        }
        return sum;
    }
}
```

### Python
```python
def min_sum_palindrome(s):
    min_sum = float('inf')
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            sub = s[i:j]
            if is_palindrome(sub):
                sum_ = sum(ord(c) for c in sub)
                if sum_ < min_sum:
                    min_sum = sum_
    return min_sum

def is_palindrome(s):
    left = 0
    right = len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True
```

### C++
```cpp
#include <iostream>
#include <string>

int minSumPalindrome(const std::string& s) {
    int minSum = INT_MAX;
    for (int i = 0; i < s.length(); i++) {
        for (int j = i + 1; j <= s.length(); j++) {
            std::string sub = s.substr(i, j - i);
            if (isPalindrome(sub)) {
                int sum = 0;
                for (char c : sub) {
                    sum += c;
                }
                if (sum < minSum) {
                    minSum = sum;
                }
            }
        }
    }
    return minSum;
}

bool isPalindrome(const std::string& s) {
    int left = 0, right = s.length() - 1;
    while (left < right) {
        if (s[left] != s[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

### JavaScript
```javascript
function minSumPalindrome(s) {
    let minSum = Infinity;
    for (let i = 0; i < s.length; i++) {
        for (let j = i + 1; j <= s.length; j++) {
            const sub = s.slice(i, j);
            if (isPalindrome(sub)) {
                let sum = 0;
                for (const c of sub) {
                    sum += c.charCodeAt(0);
                }
                if (sum < minSum) {
                    minSum = sum;
                }
            }
        }
    }
    return minSum;

function isPalindrome(s) {
    let left = 0, right = s.length - 1;
    while (left < right) {
        if (s.charAt(left) !== s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

Note that these optimized solutions have the same time and space complexity as the original solution. However, they use more concise code and are easier to read and maintain.