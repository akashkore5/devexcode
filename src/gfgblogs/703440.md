---
id: "703440"
title: "Subarray Inversions"
slug: "subarray-inversions0512"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

Here is the detailed Markdown blog post for the "Subarray Inversions" problem:

**Subarray Inversions**
=====================

**Slug:** subarray-inversions0512
**Difficulty:** Medium
**Id:** 703440
**Topic Tags:** Arrays, Data Structures
**Company Tags:** None

## Summary
The Subarray Inversions problem involves finding the number of inversions in a given array. An inversion occurs when an element is smaller than the next element in the array. The goal is to write an efficient algorithm that counts the total number of inversions in a given array.

## Detailed Explanation
To solve this problem, we will use a simple and efficient approach called the Merge Sort algorithm. We will modify the merge function to count the number of inversions while merging two sorted subarrays.

Here's a step-by-step breakdown of the solution:

1.  Start by splitting the input array into two halves until each half contains only one element.
2.  Merge the two halves, counting the number of inversions as you go.
3.  Continue this process until the entire array is merged and the inversion count is calculated.

Here's a simple ASCII art diagram to illustrate the merge process:

```
    [1, 3, 5] (left)
          |
          |
    [2, 4, 6] (right)

    Merged:
    [1, 2, 3, 4, 5, 6]
```

Time complexity: O(n log n) where n is the number of elements in the array.
Space complexity: O(n) for the recursive function calls.

## Optimized Solutions

### Java
```java
public class SubarrayInversions {
    public static int countInversions(int[] arr) {
        if (arr.length <= 1) {
            return 0;
        }
        
        int[] left = Arrays.copyOfRange(arr, 0, arr.length / 2);
        int[] right = Arrays.copyOfRange(arr, arr.length / 2, arr.length);
        
        int invCount = countInversions(left) + countInversions(right);
        
        int i = 0;
        int j = 0;
        int k = 0;
        
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
                arr[k++] = left[i++];
            } else {
                arr[k++] = right[j++];
                invCount += left.length - i;
            }
        }
        
        System.arraycopy(left, i, arr, k, left.length - i);
        System.arraycopy(right, j, arr, k + (left.length - i), right.length - j);
        
        return invCount;
    }
}
```

### Python
```python
def count_inversions(arr):
    if len(arr) <= 1:
        return 0
    
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    
    inv_count = count_inversions(left) + count_inversions(right)
    
    i = j = k = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            inv_count += len(left) - i
            j += 1
        k += 1
    
    while i < len(left):
        arr[k] = left[i]
        i += 1
        k += 1
    
    while j < len(right):
        arr[k] = right[j]
        j += 1
        k += 1
    
    return inv_count
```

### C++
```cpp
#include <algorithm>
#include <iostream>

int countInversions(int* arr, int start, int end) {
    if (start >= end) {
        return 0;
    }
    
    int mid = start + (end - start) / 2;
    
    int leftInvCount = countInversions(arr, start, mid);
    int rightInvCount = countInversions(arr, mid + 1, end);
    
    int invCount = leftInvCount + rightInvCount;
    
    int i = start;
    int j = mid + 1;
    int k = start;
    
    while (i <= mid && j <= end) {
        if (arr[i] <= arr[j]) {
            arr[k++] = arr[i++];
        } else {
            arr[k++] = arr[j++];
            invCount += mid - i + 1;
        }
    }
    
    while (i <= mid) {
        arr[k++] = arr[i++];
    }
    
    while (j <= end) {
        arr[k++] = arr[j++];
    }
    
    return invCount;
}

int main() {
    int arr[] = {1, 3, 5, 2, 4, 6};
    std::cout << "Number of inversions: " << countInversions(arr, 0, sizeof(arr) / sizeof(arr[0]) - 1) << std::endl;
    return 0;
}
```

### JavaScript
```javascript
function countInversions(arr) {
    if (arr.length <= 1) {
        return 0;
    }
    
    let mid = Math.floor(arr.length / 2);
    let left = arr.slice(0, mid);
    let right = arr.slice(mid);
    
    let invCount = countInversions(left) + countInversions(right);
    
    let i = j = k = 0;
    
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            arr[k++] = left[i++];
        } else {
            arr[k++] = right[j++];
            invCount += left.length - i;
        }
    }
    
    while (i < left.length) {
        arr[k++] = left[i++];
    }
    
    while (j < right.length) {
        arr[k++] = right[j++];
    }
    
    return invCount;
}
```

Note: The above code is for illustration purposes only.