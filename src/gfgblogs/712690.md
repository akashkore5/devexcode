---
id: "712690"
title: "Floor in BST"
slug: "floor-in-bst"
difficulty: "Medium"
companyTags: []
tags: ["Binary Search Tree", "Data Structures"]
---

Here is a detailed Markdown blog post for the "Floor in BST" problem:

# Floor in BST
## Summary
Given a Binary Search Tree (BST) and a target value, find the floor of the target value. The floor of a number in a sorted array or tree is the largest number less than or equal to the given number. This problem involves working with binary search trees, which are fundamental data structures in computer science.

## Detailed Explanation
To solve this problem, we need to traverse the BST and keep track of the largest value smaller than our target value. We can do this using an in-order traversal of the tree, where we visit each node in ascending order.

Here's a step-by-step breakdown of the solution:

1. Initialize a variable `floor` to negative infinity.
2. Traverse the BST in-order (left-root-right).
3. For each node in the tree:
   - If the node's value is less than our target, update `floor` to be the current node's value.
4. Return `floor`.

Here's an ASCII art diagram of the traversal:

    4
   / \
  2   6
     / \
    5   7

In this example, if we're searching for the floor of 5, our traversal would be: 2 -> 4 -> 5. The largest value smaller than or equal to 5 is 4, so that's our answer.

Time complexity: O(h), where h is the height of the tree. This is because we need to traverse the entire tree in the worst case.
Space complexity: O(1), since we're not using any extra space that scales with the input size.

## Optimized Solutions
### Java
```java
public int findFloor(Node root, int target) {
    int floor = Integer.MIN_VALUE;
    inOrderTraversal(root, target, floor);
    return floor;
}

private void inOrderTraversal(Node node, int target, int floor) {
    if (node == null) return;

    inOrderTraversal(node.left, target, floor);

    if (node.val <= target) {
        floor = node.val;
    }

    inOrderTraversal(node.right, target, floor);
}
```

### Python
```python
def find_floor(root, target):
    floor = float('-inf')
    in_order_traversal(root, target, floor)
    return floor

def in_order_traversal(node, target, floor):
    if node is None:
        return

    in_order_traversal(node.left, target, floor)

    if node.val <= target:
        floor = node.val

    in_order_traversal(node.right, target, floor)
```

### C++
```cpp
int findFloor(Node* root, int target) {
    int floor = INT_MIN;
    inOrderTraversal(root, target, &floor);
    return floor;
}

void inOrderTraversal(Node* node, int target, int* floor) {
    if (node == NULL) return;

    inOrderTraversal(node->left, target, floor);

    if (node->val <= target) {
        *floor = node->val;
    }

    inOrderTraversal(node->right, target, floor);
}
```

### JavaScript
```javascript
function findFloor(root, target) {
    let floor = -Infinity;
    inOrderTraversal(root, target, floor);
    return floor;

  function inOrderTraversal(node, target, floor) {
    if (node === null) return;

    inOrderTraversal(node.left, target, floor);

    if (node.val <= target) {
      floor = node.val;
    }

    inOrderTraversal(node.right, target, floor);
  }
```

I hope this helps! Let me know if you have any questions or need further clarification.