---
id: "700454"
title: "Root to leaf paths sum"
slug: "root-to-leaf-paths-sum"
difficulty: "Medium"
companyTags: ["Amazon", "Microsoft", "OYO Rooms", "Google"]
tags: ["Tree", "Data Structures"]
---

Here is the detailed Markdown blog post for the problem "Root to leaf paths sum":

# Root to Leaf Paths Sum
## Summary
Given a binary tree, find all the root-to-leaf paths where the sum of node values is equal to a given target sum. The problem requires traversing the tree and calculating the sum of node values along each path from the root to a leaf.

## Detailed Explanation

To solve this problem, we can use a recursive approach. We start by visiting the root node and recursively traverse the left and right subtrees. For each subtree, we calculate the sum of node values and compare it with the target sum. If the sum is equal to the target sum, we have found a root-to-leaf path that meets the condition.

Here's a step-by-step breakdown of the solution:

1. Define a recursive function `sumPaths` that takes three parameters: the current node, the target sum, and a boolean flag indicating whether we are currently on a leaf path.
2. Initialize the sum of the current path to 0.
3. If the current node is a leaf node (i.e., it has no children), check if the sum of the current path is equal to the target sum. If it is, return the path.
4. Recursively call `sumPaths` on the left and right subtrees with the updated sum and the same leaf flag.
5. Update the sum of the current path by adding the value of the current node.

Here's an ASCII art diagram illustrating the recursive traversal:

```
       1
     /   \
    2     3
   / \   /
  4   5 6
```

Time complexity: O(N), where N is the number of nodes in the tree. This is because we visit each node once.

Space complexity: O(H), where H is the height of the tree. This is because of the recursive call stack.

## Optimized Solutions

### Java
```java
class Solution {
    public List<String> pathSum(TreeNode root, int sum) {
        List<String> result = new ArrayList<>();
        sumPaths(root, sum, "", result);
        return result;
    }

    private void sumPaths(TreeNode node, int sum, String path, List<String> result) {
        if (node == null) return;

        sum += node.val;
        path += node.val + "->";

        if (node.left == null && node.right == null) {
            if (sum == 0) result.add(path.substring(0, path.length() - 2));
        } else {
            sumPaths(node.left, sum, path, result);
            sumPaths(node.right, sum, path, result);
        }
    }
}
```

### Python
```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[str]:
        result = []
        self.sumPaths(root, sum, "", result)
        return result

    def sumPaths(self, node: TreeNode, sum: int, path: str, result: List[str]) -> None:
        if not node:
            return

        sum += node.val
        path += str(node.val) + "->"

        if not node.left and not node.right:
            if sum == 0:
                result.append(path[:-2])
        else:
            self.sumPaths(node.left, sum, path, result)
            self.sumPaths(node.right, sum, path, result)
```

### C++
```cpp
class Solution {
public:
    vector<string> pathSum(TreeNode* root, int sum) {
        vector<string> result;
        sumPaths(root, sum, "", result);
        return result;
    }

    void sumPaths(TreeNode* node, int sum, string path, vector<string>& result) {
        if (!node) return;

        sum += node->val;
        path += to_string(node->val) + "->";

        if (!node->left && !node->right) {
            if (sum == 0) result.push_back(path.substr(0, path.length() - 2));
        } else {
            sumPaths(node->left, sum, path, result);
            sumPaths(node->right, sum, path, result);
        }
    }
};
```

### JavaScript
```javascript
class Solution {
  pathSum(root, sum) {
    const result = [];
    this.sumPaths(root, sum, "", result);
    return result;
  }

  sumPaths(node, sum, path, result) {
    if (!node) return;

    sum += node.val;
    path += `${node.val}->`;

    if (!node.left && !node.right) {
      if (sum === 0) result.push(path.slice(0, -2));
    } else {
      this.sumPaths(node.left, sum, path, result);
      this.sumPaths(node.right, sum, path, result);
    }
  }
}
```

Note: The `TreeNode` class is assumed to be defined elsewhere in the code.