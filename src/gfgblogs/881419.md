---
id: "881419"
title: "Operations on Queue"
slug: "operations-on-queue--114617"
difficulty: "Basic"
companyTags: ["Amazon"]
tags: ["Queue", "Data Structures"]
---

**Operations on Queue**
=====================================

**Slug:** operations-on-queue--114617
**Difficulty:** Basic
**Id:** 881419
**Topic Tags:** Queue, Data Structures
**Company Tags:** Amazon

## Summary
This problem is about implementing various queue operations such as enqueue, dequeue, and display. The key concepts involved are basic queue operations and data structures.

## Detailed Explanation
The goal of this problem is to create a class `Queue` that implements the following methods:
- `enqueue(int item)`: adds an element at the end of the queue.
- `dequeue()`: removes the element from the front of the queue.
- `display()`: prints the elements in the queue.

Here's a step-by-step breakdown of the solution:

1. Create a class `Queue` with a fixed-size array to store the elements.
2. Initialize an empty queue by setting its size to 0 and its front index to -1.
3. The `enqueue(int item)` method adds an element at the end of the queue:
   - If the queue is not full, add the element to the end of the array and increment the rear index.
   - If the queue is full, print a message indicating that the queue is full and return.
4. The `dequeue()` method removes the element from the front of the queue:
   - If the queue is not empty, remove the element at the front of the array and decrement the front index.
   - If the queue is empty, print a message indicating that the queue is empty and return.
5. The `display()` method prints the elements in the queue:
   - Iterate through the array from the front to the rear index and print each element.

Time complexity analysis:

* Enqueue operation: O(1) if the queue is not full, O(n) if the queue is full (where n is the size of the queue).
* Dequeue operation: O(1) if the queue is not empty, O(n) if the queue is empty.
* Display operation: O(n), where n is the number of elements in the queue.

Space complexity analysis:

* The space complexity is O(n), where n is the maximum size of the queue.

## Optimized Solutions

#### Java
```java
public class Queue {
    private int[] array;
    private int front, rear;

    public Queue(int size) {
        array = new int[size];
        front = rear = 0;
    }

    public void enqueue(int item) {
        if (rear < array.length - 1) {
            array[rear++] = item;
        } else {
            System.out.println("Queue is full");
        }
    }

    public int dequeue() {
        if (front != rear) {
            return array[front++];
        } else {
            System.out.println("Queue is empty");
            return -1;
        }
    }

    public void display() {
        for (int i = front; i < rear; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}
```

#### Python
```python
class Queue:
    def __init__(self, size):
        self.array = [0] * size
        self.front = self.rear = 0

    def enqueue(self, item):
        if self.rear < len(self.array) - 1:
            self.array[self.rear] = item
            self.rear += 1
        else:
            print("Queue is full")

    def dequeue(self):
        if self.front != self.rear:
            result = self.array[self.front]
            self.front += 1
            return result
        else:
            print("Queue is empty")
            return None

    def display(self):
        for i in range(self.front, self.rear):
            print(self.array[i], end=" ")
        print()
```

#### C++
```cpp
class Queue {
public:
    int* array;
    int front, rear;

    Queue(int size) {
        array = new int[size];
        front = rear = 0;
    }

    void enqueue(int item) {
        if (rear < size - 1) {
            array[rear++] = item;
        } else {
            cout << "Queue is full";
        }
    }

    int dequeue() {
        if (front != rear) {
            return array[front++];
        } else {
            cout << "Queue is empty";
            return -1;
        }
    }

    void display() {
        for (int i = front; i < rear; i++) {
            cout << array[i] << " ";
        }
        cout << endl;
    }
};
```

#### JavaScript
```javascript
class Queue {
  constructor(size) {
    this.array = new Array(size).fill(0);
    this.front = this.rear = 0;
  }

  enqueue(item) {
    if (this.rear < this.array.length - 1) {
      this.array[this.rear++] = item;
    } else {
      console.log("Queue is full");
    }
  }

  dequeue() {
    if (this.front !== this.rear) {
      const result = this.array[this.front];
      this.front++;
      return result;
    } else {
      console.log("Queue is empty");
      return null;
    }
  }

  display() {
    for (let i = this.front; i < this.rear; i++) {
      console.log(this.array[i], " ");
    }
    console.log();
  }
}
```
Note: The above code assumes that the queue size is fixed and does not handle dynamic resizing.