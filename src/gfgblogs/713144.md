---
id: "713144"
title: "Transform to Sum Tree"
slug: "transform-to-sum-tree--170645"
difficulty: "Easy"
companyTags: ["Amazon", "Microsoft", "Samsung", "FactSet", "Walmart"]
tags: ["Tree", "Data Structures"]
---

**Transform to Sum Tree**
=====================

## Summary
Given a binary tree, transform it into a sum tree where each node's value is equal to the sum of all values in its subtree. This problem requires understanding of tree traversal and manipulation.

## Detailed Explanation
The given binary tree can be transformed into a sum tree by performing a level order traversal (BFS) and updating the node values accordingly. The idea is to keep track of the sum of all nodes at each level and assign it to the root node of that level. This process continues until all levels are processed.

Here's a step-by-step breakdown:

1. Initialize an empty queue `q` and add the root node of the binary tree.
2. While `q` is not empty, do the following:
   - Dequeue a node and calculate its sum by recursively summing up all nodes in its subtree.
   - Assign this sum to the current node.
   - Add the children of the current node to the queue if they exist.
3. Return the transformed binary tree.

Time complexity: O(n), where n is the number of nodes in the binary tree, since we visit each node once.
Space complexity: O(w), where w is the maximum width of the binary tree, due to the level order traversal.

## Optimized Solutions
### Java
```java
class Node {
    int val;
    Node left, right;

    public Node(int v) {
        val = v;
    }
}

public class TransformToSumTree {
    public static Node transform(Node root) {
        if (root == null) return null;

        Queue<Node> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            int sum = 0;
            int levelSize = q.size();
            for (int i = 0; i < levelSize; i++) {
                Node node = q.poll();
                sum += node.val;
                if (node.left != null) q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            root.val = sum;
        }

        return root;
    }
}
```
### Python
```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def transformToSumTree(root):
    if not root: return None

    queue = [root]
    while queue:
        level_sum = 0
        level_size = len(queue)
        for _ in range(level_size):
            node = queue.pop(0)
            level_sum += node.val
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        root.val = level_sum

    return root
```
### C++
```cpp
class Node {
public:
    int val;
    Node* left, *right;

    Node(int v) : val(v), left(nullptr), right(nullptr) {}
};

Node* transform(Node* root) {
    if (root == nullptr) return nullptr;

    queue<Node*> q;
    q.push(root);

    while (!q.empty()) {
        int sum = 0;
        int levelSize = q.size();
        for (int i = 0; i < levelSize; i++) {
            Node* node = q.front();
            q.pop();
            sum += node->val;
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        root->val = sum;
    }

    return root;
}
```
### JavaScript
```javascript
class Node {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

function transformToSumTree(root) {
  if (!root) return null;

  const queue = [root];
  while (queue.length > 0) {
    let sum = 0;
    let levelSize = queue.length;
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      sum += node.val;
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
    root.val = sum;
  }

  return root;
}
```