---
id: "707516"
title: "Course Schedule"
slug: "course-schedule"
difficulty: "Medium"
companyTags: ["Google"]
tags: ["DFS", "Graph", "BFS", "Data Structures", "Algorithms"]
---

**Course Schedule**
==================

**Slug**: course-schedule
**Difficulty**: Medium
**Id**: 707516
**Topic Tags**: DFS, Graph, BFS, Data Structures, Algorithms
**Company Tags**: Google

## Summary
The Course Schedule problem is a graph-based algorithmic problem where you are given a set of courses and their prerequisites. Your task is to determine if it's possible to schedule all the courses in a valid order. This problem involves graph traversal techniques such as DFS and BFS.

## Detailed Explanation

Given a set of courses with their prerequisites, we need to find out whether it's possible to schedule all the courses in a valid order or not. A course can only be scheduled after its prerequisite has been completed. We can model this situation using a directed graph where each course is a node and the edges represent the dependencies between the courses.

One way to approach this problem is by using DFS or BFS algorithms to traverse the graph. The idea is to start from an arbitrary course (or node) and try to schedule all its prerequisites first. If we can successfully schedule all the prerequisites, then we can move on to the next level of courses that have these prerequisites as their prerequisites.

Here's a step-by-step breakdown of the solution:

1. Create a graph using adjacency list representation where each node represents a course and the edges represent the dependencies between the courses.
2. Initialize an empty stack or queue to store the courses that have been scheduled successfully.
3. Start from an arbitrary course (or node) in the graph.
4. If the current course has prerequisites, try to schedule all its prerequisites first using DFS or BFS algorithm.
5. Once all the prerequisites of the current course have been scheduled successfully, add it to the stack or queue.
6. Repeat steps 3-5 until all courses have been scheduled or a cycle is detected (i.e., a course that has already been scheduled becomes a prerequisite for another course).
7. If all courses have been scheduled successfully without detecting any cycles, then it's possible to schedule all the courses in a valid order.

Time complexity: O(V + E) where V is the number of vertices (courses) and E is the number of edges (prerequisites).

Space complexity: O(V) for storing the graph and the stack or queue used for scheduling.

## Optimized Solutions

### Java
```java
import java.util.*;

class Course {
    int id;
    List<Course> prerequisites = new ArrayList<>();
}

public class Solution {
    public boolean isPossible(int numCourses, int[][] prerequisites) {
        int V = numCourses;
        Graph graph = new Graph(V);
        
        for (int i = 0; i < prerequisites.length; i++) {
            Course course = graph.getCourse(prerequisites[i][0]);
            course.prerequisites.add(graph.getCourse(prerequisites[i][1]));
        }
        
        boolean[] visited = new boolean[V];
        for (int i = 0; i < V; i++) {
            if (!dfs(i, visited, graph)) return false;
        }
        return true;
    }

    private boolean dfs(int node, boolean[] visited, Graph graph) {
        if (visited[node]) return false;
        visited[node] = true;
        
        for (Course course : graph.getCourse(node).prerequisites) {
            if (!dfs(course.id, visited, graph)) return false;
        }
        return true;
    }

    class Graph {
        Map<Integer, Course> courses = new HashMap<>();
        
        public Graph(int V) {
            for (int i = 0; i < V; i++) {
                courses.put(i, new Course());
            }
        }
        
        public Course getCourse(int id) {
            return courses.get(id);
        }
    }
}
```

### Python
```python
class Course:
    def __init__(self, id):
        self.id = id
        self.prerequisites = []

def is_possible(num_courses, prerequisites):
    V = num_courses
    graph = {i: Course(i) for i in range(V)}

    for prerequisite in prerequisites:
        course1 = graph[prerequisite[0]]
        course2 = graph[prerequisite[1]]
        course1.prerequisites.append(course2)

    visited = [False] * V

    for node in range(V):
        if not dfs(node, visited, graph):
            return False
    return True

def dfs(node, visited, graph):
    if visited[node]:
        return False
    visited[node] = True

    for prerequisite in graph[node].prerequisites:
        if not dfs(prerequisite.id, visited, graph):
            return False
    return True
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <map>

using namespace std;

class Course {
public:
    int id;
    vector<Course*> prerequisites;
};

bool isPossible(int numCourses, vector<vector<int>>& prerequisites) {
    int V = numCourses;
    map<int, Course*> courses;
    
    for (int i = 0; i < V; i++) {
        courses[i] = new Course();
        courses[i]->id = i;
    }
    
    for (auto& prerequisite : prerequisites) {
        Course* course1 = courses[prerequisite[0]];
        Course* course2 = courses[prerequisite[1]];
        course1->prerequisites.push_back(course2);
    }
    
    bool visited[V] = {false};
    
    for (int i = 0; i < V; i++) {
        if (!dfs(i, visited, courses)) return false;
    }
    return true;
}

bool dfs(int node, bool visited[], map<int, Course*>& courses) {
    if (visited[node]) return false;
    visited[node] = true;

    for (auto& prerequisite : courses[node]->prerequisites) {
        if (!dfs(prerequisite->id, visited, courses)) return false;
    }
    return true;
}
```

### JavaScript
```javascript
class Course {
  constructor(id) {
    this.id = id;
    this.prerequisites = [];
  }
}

function isPossible(numCourses, prerequisites) {
  let graph = {};
  
  for (let i = 0; i < numCourses; i++) {
    graph[i] = new Course(i);
  }
  
  for (let prerequisite of prerequisites) {
    let course1 = graph[prerequisite[0]];
    let course2 = graph[prerequisite[1]];
    course1.prerequisites.push(course2);
  }
  
  let visited = Array(numCourses).fill(false);
  
  for (let i = 0; i < numCourses; i++) {
    if (!dfs(i, visited, graph)) return false;
  }
  return true;
}

function dfs(node, visited, graph) {
  if (visited[node]) return false;
  visited[node] = true;

  for (let prerequisite of graph[node].prerequisites) {
    if (!dfs(prerequisite.id, visited, graph)) return false;
  }
  return true;
}
```

Note that these solutions use a recursive DFS approach to traverse the graph.