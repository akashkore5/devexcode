---
id: "712527"
title: "Convert Min Heap to Max Heap"
slug: "convert-min-heap-to-max-heap-1666385109"
difficulty: "Medium"
companyTags: []
tags: []
---

# Convert Min Heap to Max Heap

## Summary
This problem involves converting a min heap into a max heap. A min heap is a complete binary tree where each node is smaller than its children, and a max heap is a complete binary tree where each node is larger than its children. The conversion process should maintain the heap property of the resulting max heap.

## Detailed Explanation
To convert a min heap to a max heap, we can use a similar approach as the min heap construction algorithm. The key idea is to swap each node with its largest child, starting from the last non-leaf node and moving towards the root. This process ensures that the nodes are rearranged in a way that maintains the max heap property.

Here's a step-by-step breakdown of the solution:

1. Start from the last non-leaf node (i.e., the parent of the leaf nodes) and move towards the root.
2. For each node, find its largest child. If the node has only one child or no children, it is already a max heap node, so skip to the next step.
3. Compare the current node with its largest child. If the child is larger, swap them. Otherwise, continue to the next node.
4. Repeat steps 1-3 until you reach the root node.

The time complexity of this algorithm is O(n), where n is the number of nodes in the heap. This is because we visit each node once and perform a constant amount of work for each node. The space complexity is O(1), as we only use a small amount of extra memory to store temporary variables.

## Optimized Solutions

### Java
```java
public class MinToMaxHeap {
    public static void convertMinToMaxHeap(int[] arr) {
        int n = arr.length;
        for (int i = (n / 2) - 1; i >= 0; i--) {
            int maxIndex = findLargestChild(arr, i);
            if (maxIndex != -1) {
                swap(arr, i, maxIndex);
            }
        }
    }

    private static int findLargestChild(int[] arr, int parentIndex) {
        int leftChildIndex = 2 * parentIndex + 1;
        int rightChildIndex = 2 * parentIndex + 2;
        if (leftChildIndex >= arr.length || rightChildIndex >= arr.length) {
            return -1; // no child
        } else if (arr[leftChildIndex] > arr[rightChildIndex]) {
            return leftChildIndex;
        } else {
            return rightChildIndex;
        }
    }

    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### Python
```python
class MinToMaxHeap:
    def convert_min_to_max_heap(self, arr):
        n = len(arr)
        for i in range((n // 2) - 1, -1, -1):
            max_index = self.find_largest_child(arr, i)
            if max_index != -1:
                self.swap(arr, i, max_index)

    def find_largest_child(self, arr, parent_index):
        left_child_index = 2 * parent_index + 1
        right_child_index = 2 * parent_index + 2
        if left_child_index >= len(arr) or right_child_index >= len(arr):
            return -1  # no child
        elif arr[left_child_index] > arr[right_child_index]:
            return left_child_index
        else:
            return right_child_index

    def swap(self, arr, i, j):
        temp = arr[i]
        arr[i] = arr[j]
        arr[j] = temp
```

### C++
```cpp
#include <iostream>
#include <vector>

class MinToMaxHeap {
public:
    void convertMinToMaxHeap(std::vector<int>& arr) {
        int n = arr.size();
        for (int i = (n / 2) - 1; i >= 0; i--) {
            int maxIndex = findLargestChild(arr, i);
            if (maxIndex != -1) {
                swap(arr, i, maxIndex);
            }
        }
    }

private:
    int findLargestChild(const std::vector<int>& arr, int parentIndex) {
        int leftChildIndex = 2 * parentIndex + 1;
        int rightChildIndex = 2 * parentIndex + 2;
        if (leftChildIndex >= arr.size() || rightChildIndex >= arr.size()) {
            return -1; // no child
        } else if (arr[leftChildIndex] > arr[rightChildIndex]) {
            return leftChildIndex;
        } else {
            return rightChildIndex;
        }
    }

    void swap(std::vector<int>& arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
};
```

### JavaScript
```javascript
class MinToMaxHeap {
  convertMinToMaxHeap(arr) {
    let n = arr.length;
    for (let i = Math.floor((n / 2) - 1); i >= 0; i--) {
      let maxIndex = this.findLargestChild(arr, i);
      if (maxIndex !== -1) {
        this.swap(arr, i, maxIndex);
      }
    }
  }

  findLargestChild(arr, parentIndex) {
    let leftChildIndex = 2 * parentIndex + 1;
    let rightChildIndex = 2 * parentIndex + 2;
    if (leftChildIndex >= arr.length || rightChildIndex >= arr.length) {
      return -1; // no child
    } else if (arr[leftChildIndex] > arr[rightChildIndex]) {
      return leftChildIndex;
    } else {
      return rightChildIndex;
    }
  }

  swap(arr, i, j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
  }
}
```