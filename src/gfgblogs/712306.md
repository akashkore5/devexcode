---
id: "712306"
title: "Postfix to Infix Conversion"
slug: "postfix-to-infix-conversion"
difficulty: "Medium"
companyTags: []
tags: []
---

**Postfix to Infix Conversion**
======================================================

### Summary
The problem involves converting a given postfix expression into its equivalent infix notation. Postfix expressions are written in reverse Polish notation, where operators follow their operands. The task is to write an algorithm that takes a postfix expression as input and outputs the corresponding infix expression.

### Detailed Explanation
To solve this problem, we can use a stack-based approach. We'll iterate through the postfix expression from left to right, and for each token (operand or operator), we'll apply the following rules:

1. If the token is an operand, add it to the output string as is.
2. If the token is an operator, pop operands from the stack until you find the matching operator at the top of the stack. Then, add the popped operands and the current operator to the output string.

Here's a step-by-step breakdown:

1. Initialize an empty stack `S` and an empty output string `result`.
2. Iterate through the postfix expression:
   - For each token (operand or operator):
     - If it's an operand, add it to `result`.
     - If it's an operator, pop operands from `S` until you find the matching operator at the top of `S`. Then, add the popped operands and the current operator to `result`.
3. Return the final value of `result`.

Here's an example:

Postfix expression: `A B + C D *`
Output: `( A + (B * C) * D )`

### Optimized Solutions
#### Java
```java
public class PostfixToInfix {
    public static String convert(String postfix) {
        Stack<String> stack = new Stack<>();
        StringBuilder result = new StringBuilder();

        for (String token : postfix.split(" ")) {
            if (token.matches("[a-zA-Z]+")) { // operand
                result.append(token).append(" ");
            } else { // operator
                while (!stack.isEmpty() && !isMatchingOperator(stack.peek(), token)) {
                    result.append(stack.pop()).append(" ");
                }
                stack.push(token);
            }
        }

        while (!stack.isEmpty()) {
            result.append(stack.pop()).append(" ");
        }

        return result.toString().trim();
    }

    private static boolean isMatchingOperator(String op1, String op2) {
        // implement your matching logic here
        // for example:
        return op1.equals("(") && op2.equals(")");
    }
}
```
#### Python
```python
class PostfixToInfix:
    def convert(self, postfix):
        stack = []
        result = ""

        for token in postfix.split():
            if token.isalpha():  # operand
                result += token + " "
            else:  # operator
                while stack and not self.is_matching_operator(stack[-1], token):
                    result += stack.pop() + " "
                stack.append(token)

        while stack:
            result += stack.pop() + " "

        return result.strip()

    def is_matching_operator(self, op1, op2):
        # implement your matching logic here
        # for example:
        return op1 == "(" and op2 == ")"
```
#### C++
```cpp
class PostfixToInfix {
public:
    std::string convert(const std::string& postfix) {
        std::stack<std::string> stack;
        std::string result = "";

        for (const auto& token : split(postfix, " ")) {
            if (token.find_first_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") != std::string::npos) { // operand
                result += token + " ";
            } else { // operator
                while (!stack.empty() && !is_matching_operator(stack.top(), token)) {
                    result += stack.pop() + " ";
                }
                stack.push(token);
            }
        }

        while (!stack.empty()) {
            result += stack.pop() + " ";
        }

        return result.substr(0, result.size() - 1); // remove trailing space
    }

    std::string split(const std::string& str, const std::string& delimiter) {
        size_t pos = 0;
        std::vector<std::string> tokens;
        while ((pos = str.find(delimiter)) != std::string::npos) {
            tokens.push_back(str.substr(0, pos));
            str.erase(0, pos + delimiter.size());
        }
        tokens.push_back(str);
        return join(tokens, " ");
    }

    bool is_matching_operator(const std::string& op1, const std::string& op2) {
        // implement your matching logic here
        // for example:
        return op1 == "(" && op2 == ")";
    }
};
```
#### JavaScript
```javascript
class PostfixToInfix {
  convert(postfix) {
    const stack = [];
    let result = "";

    postfix.split(" ").forEach(token => {
      if (token.match(/[a-zA-Z]/)) { // operand
        result += token + " ";
      } else { // operator
        while (stack.length && !this.isMatchingOperator(stack.pop(), token)) {
          result += stack.pop() + " ";
        }
        stack.push(token);
      }
    });

    while (stack.length) {
      result += stack.pop() + " ";
    }

    return result.trim();
  }

  isMatchingOperator(op1, op2) {
    // implement your matching logic here
    // for example:
    return op1 === "(" && op2 === ")";
  }
}
```