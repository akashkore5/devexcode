---
id: "714220"
title: "Smaller Sum"
slug: "smaller-sum--170647"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Binary Search", "Data Structures", "Algorithms"]
---

**Smaller Sum**
================

**Slug:** smaller-sum--170647
**Difficulty:** Medium
**Id:** 714220
**Topic Tags:** Arrays, Binary Search, Data Structures, Algorithms
**Company Tags:** None

## Summary
The Smaller Sum problem involves finding the smallest possible sum of elements in an array where each element is either added or subtracted from a target value. The problem requires a combination of binary search and dynamic programming concepts to find the optimal solution.

## Detailed Explanation
To solve this problem, we can start by sorting the array in ascending order. Then, we perform a binary search on the sorted array to find the closest element to the target value that is less than or equal to it. This element will be added to or subtracted from the target value depending on whether it's greater or less than the target.

Here's a step-by-step breakdown of the solution:

1. Sort the array in ascending order.
2. Perform a binary search on the sorted array to find the closest element that is less than or equal to the target value.
3. If the found element is less than the target, add it to the target and subtract its value from the sum.
4. If the found element is greater than the target, subtract it from the target and add its value to the sum.
5. Repeat steps 2-4 until the binary search finds an element that is equal to or less than the target.

The time complexity of this solution is O(n log n) due to the sorting step, where n is the size of the array. The space complexity is O(1) since we only use a constant amount of space to store the variables.

## Optimized Solutions

### Java
```java
public int smallerSum(int[] nums, int target) {
    Arrays.sort(nums);
    int left = 0;
    int right = nums.length - 1;
    int sum = Integer.MAX_VALUE;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int val = nums[mid];
        if (val <= target) {
            int newSum = Math.abs(target - val);
            if (newSum < sum) {
                sum = newSum;
            }
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return sum;
}
```

### Python
```python
def smaller_sum(nums, target):
    nums.sort()
    left = 0
    right = len(nums) - 1
    sum_val = float('inf')

    while left <= right:
        mid = (left + right) // 2
        val = nums[mid]
        if val <= target:
            new_sum = abs(target - val)
            if new_sum < sum_val:
                sum_val = new_sum
            left = mid + 1
        else:
            right = mid - 1

    return sum_val
```

### C++
```cpp
int smallerSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    int left = 0;
    int right = nums.size() - 1;
    int sum = INT_MAX;

    while (left <= right) {
        int mid = left + (right - left) / 2;
        int val = nums[mid];
        if (val <= target) {
            int newSum = abs(target - val);
            if (newSum < sum) {
                sum = newSum;
            }
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return sum;
}
```

### JavaScript
```javascript
function smallerSum(nums, target) {
    nums.sort((a, b) => a - b);
    let left = 0;
    let right = nums.length - 1;
    let sum = Infinity;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        let val = nums[mid];
        if (val <= target) {
            let newSum = Math.abs(target - val);
            if (newSum < sum) {
                sum = newSum;
            }
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return sum;
}
```

Note that the optimized solutions are provided in different programming languages, as per the requirements.