---
id: "879202"
title: "Hashing for pair - 2"
slug: "hashing-for-pair-2--114603"
difficulty: "Easy"
companyTags: []
tags: ["Hash", "Data Structures"]
---

**Hashing for pair - 2**
======================

### Summary
Given two arrays `arr1` and `arr2`, find all pairs `(x, y)` where `x` is from `arr1` and `y` is from `arr2` such that `x + y = target_sum`. The size of the arrays can be large, so a hash-based solution is required.

### Detailed Explanation
We can solve this problem using a hash table (HashMap in Java or Python dictionary) to store the elements of `arr1` as keys and their indices as values. Then, for each element `y` in `arr2`, we check if the target sum minus `y` exists in the hash table. If it does, then `(target_sum - y, y)` is a valid pair.

Here's a step-by-step breakdown of the solution:

1. Create an empty hash table.
2. Iterate through `arr1`. For each element `x`, add `x` as a key and its index in the array as the value to the hash table.
3. Iterate through `arr2`. For each element `y`, check if the target sum minus `y` exists as a key in the hash table.
4. If it does, then `(target_sum - y, y)` is a valid pair. Add it to the result list.

Time complexity: O(n + m), where n and m are the sizes of `arr1` and `arr2`, respectively. Space complexity: O(n), as we need to store all elements of `arr1`.

### Optimized Solutions
Here are optimized solutions in various languages:

#### Java
```java
import java.util.HashMap;
import java.util.Map;

public class HashingForPair {
    public static void findPairs(int[] arr1, int[] arr2, int targetSum) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < arr1.length; i++) {
            map.put(arr1[i], i);
        }
        for (int j = 0; j < arr2.length; j++) {
            if (map.containsKey(targetSum - arr2[j])) {
                System.out.println("Pair: (" + (targetSum - arr2[j]) + ", " + arr2[j] + ")");
            }
        }
    }
}
```

#### Python
```python
def find_pairs(arr1, arr2, target_sum):
    hash_table = {}
    for i in range(len(arr1)):
        hash_table[arr1[i]] = i
    for j in range(len(arr2)):
        if target_sum - arr2[j] in hash_table:
            print("Pair: ({}, {})".format(target_sum - arr2[j], arr2[j]))
```

#### C++
```cpp
#include <unordered_map>
#include <iostream>

void findPairs(int* arr1, int size1, int* arr2, int size2, int targetSum) {
    std::unordered_map<int, int> map;
    for (int i = 0; i < size1; i++) {
        map[arr1[i]] = i;
    }
    for (int j = 0; j < size2; j++) {
        if (map.find(targetSum - arr2[j]) != map.end()) {
            std::cout << "Pair: (" << targetSum - arr2[j] << ", " << arr2[j] << ")" << std::endl;
        }
    }
}
```

#### JavaScript
```javascript
function findPairs(arr1, arr2, targetSum) {
    const hashTable = {};
    for (let i = 0; i < arr1.length; i++) {
        hashTable[arr1[i]] = i;
    }
    for (let j = 0; j < arr2.length; j++) {
        if (Object.prototype.hasOwnProperty.call(hashTable, targetSum - arr2[j])) {
            console.log(`Pair: (${targetSum - arr2[j]}, ${arr2[j]})`);
        }
    }
}
```

Note that the above solutions assume that the input arrays do not contain duplicate elements. If duplicates are possible, you may need to modify the solution accordingly.