---
id: "713592"
title: "Walls Coloring"
slug: "walls-coloring--170646"
difficulty: "Medium"
companyTags: []
tags: ["Dynamic Programming"]
---

**Walls Coloring**
=====================================

## Summary
The Walls Coloring problem involves coloring a grid of walls with different colors such that no two adjacent walls have the same color. The goal is to find the minimum number of colors needed to solve this problem. This problem can be approached using dynamic programming.

## Detailed Explanation
To solve this problem, we can use dynamic programming. We initialize a 2D array `dp` where `dp[i][j]` represents the minimum number of colors needed to color the walls from row 0 to i and column 0 to j. 

We start by initializing all values in `dp` as 1 (since we need at least one color for each wall). Then, for each cell in `dp`, we consider two cases: 
- If the current cell is not colored yet, we calculate the minimum number of colors needed by trying all possible colors and choosing the one that results in the minimum number of colors.
- If the current cell is already colored with a certain color, we don't need to recalculate because it's already taken into account while calculating its parent cells.

We iterate over each cell in `dp` and update its value based on the above approach. The final answer will be stored in the bottom-right corner of `dp`.

Time complexity: O(m*n), where m is the number of rows and n is the number of columns.
Space complexity: O(m*n).

Here's an ASCII art diagram representing the grid:
```
 1 | 2 | 3 
 ---------
4 | 5 | 6
 ---------
7 | 8 | 9
```

## Optimized Solutions

### Java
```java
public class Main {
    public static int minColors(int[][] walls) {
        int m = walls.length;
        int n = walls[0].length;
        int[][] dp = new int[m][n];
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    int minColors = 2;
                    for (int k = 1; k <= walls[i][j]; k++) {
                        if ((k != dp[(i-1)][j]) && (k != dp[i][(j-1)])) {
                            minColors = Math.min(minColors, 1 + dp[(i-1)][j] == k ? 0 : 1);
                        }
                    }
                    dp[i][j] = minColors;
                }
            }
        }
        
        return dp[m-1][n-1];
    }

    public static void main(String[] args) {
        int[][] walls = {{2, 3}, {4, 5}};
        System.out.println(minColors(walls));
    }
}
```

### Python
```python
def min_colors(walls):
    m, n = len(walls), len(walls[0])
    dp = [[1]*n for _ in range(m)]
    
    for i in range(1, m):
        for j in range(1, n):
            min_colors = 2
            for k in range(1, walls[i][j]+1):
                if (k != dp[i-1][j] and k != dp[i][j-1]):
                    min_colors = min(min_colors, 1 + dp[(i-1)][j] == k or dp[i][(j-1)] == k)
            dp[i][j] = min_colors
    
    return dp[m-1][n-1]

print(min_colors([[2,3],[4,5]]))
```

### C++
```cpp
#include <iostream>
using namespace std;

int minColors(int** walls, int m, int n) {
    int** dp = new int*[m];
    for (int i = 0; i < m; i++) {
        dp[i] = new int[n];
    }
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0) {
                dp[i][j] = 1;
            } else {
                int minColors = 2;
                for (int k = 1; k <= walls[i][j]; k++) {
                    if ((k != dp[(i-1)][j]) && (k != dp[i][(j-1)])) {
                        minColors = min(minColors, 1 + (dp[(i-1)][j] == k ? 0 : 1));
                    }
                }
                dp[i][j] = minColors;
            }
        }
    }
    
    return dp[m-1][n-1];
}

int main() {
    int** walls = new int*[2];
    for (int i = 0; i < 2; i++) {
        walls[i] = new int[2];
    }
    walls[0][0] = 2;
    walls[0][1] = 3;
    walls[1][0] = 4;
    walls[1][1] = 5;
    
    cout << minColors(walls, 2, 2) << endl;
    
    return 0;
}
```

### JavaScript
```javascript
function minColors(walls) {
    let m = walls.length;
    let n = walls[0].length;
    let dp = new Array(m).fill(0).map(() => new Array(n).fill(0));
    
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            let minColors = 2;
            for (let k = 1; k <= walls[i][j]; k++) {
                if (k !== dp[i-1][j] && k !== dp[i][j-1]) {
                    minColors = Math.min(minColors, 1 + (dp[i-1][j] === k ? 0 : 1));
                }
            }
            dp[i][j] = minColors;
        }
    }
    
    return dp[m-1][n-1];
}

console.log(minColors([[2,3],[4,5]]));
```