---
id: "703634"
title: "XOR Cipher"
slug: "xor-cipher3009"
difficulty: "Medium"
companyTags: []
tags: ["Strings", "Bit Magic", "Binary Representation", "Data Structures"]
---

Here is the Markdown blog post for the XOR Cipher problem:

**XOR Cipher**
================

**Slug:** xor-cipher3009
**Difficulty:** Medium
**Id:** 703634
**Topic Tags:** Strings, Bit Magic, Binary Representation, Data Structures

## Summary
The XOR Cipher problem involves encrypting and decrypting strings using the bitwise XOR operation. Given a string and its encrypted version, find the decryption key (i.e., the string to be XORed with) that can be used to decrypt other strings. The problem requires understanding of binary representation, bit manipulation, and string operations.

## Detailed Explanation
The approach to solve this problem involves using the properties of the XOR operation. Since XOR is its own inverse (i.e., `a ^ a = 0`), we can use this property to find the decryption key. Here's the step-by-step breakdown:

1. Initialize an empty string `key` to store the decryption key.
2. Iterate through each character in the given encrypted string `encrypted`.
3. For each character, XOR it with the corresponding character in the original string (assuming we have access to this information).
4. Add the resulting character to the `key` string.
5. Repeat steps 2-4 until all characters are processed.

The time complexity of this approach is O(n), where n is the length of the encrypted string, since we're iterating through each character once. The space complexity is also O(n) for storing the decryption key.

## Optimized Solutions

### Java
```java
public String xorCipher(String encrypted) {
    StringBuilder key = new StringBuilder();
    for (int i = 0; i < encrypted.length(); i++) {
        key.append((char) (encrypted.charAt(i) ^ originalString.charAt(i)));
    }
    return key.toString();
}
```

### Python
```python
def xor_cipher(encrypted):
    key = ""
    for i in range(len(encrypted)):
        key += chr(ord(encrypted[i]) ^ ord(original_string[i]))
    return key
```

### C++
```cpp
string xorCipher(string encrypted) {
    string key;
    for (int i = 0; i < encrypted.length(); i++) {
        key += (char)(encrypted[i] ^ originalString[i]);
    }
    return key;
}
```

### JavaScript
```javascript
function xorCipher(encrypted) {
    let key = "";
    for (let i = 0; i < encrypted.length; i++) {
        key += String.fromCharCode(encrypted.charCodeAt(i) ^ originalString.charCodeAt(i));
    }
    return key;
}
```
Note that these optimized solutions assume access to the original string and use the same approach as described above.