---
id: "702813"
title: "Min Subsets with Consecutive Numbers"
slug: "min-subsets-with-consecutive-numbers0601"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Sorting", "Data Structures", "Algorithms"]
---

# Min Subsets with Consecutive Numbers

## Summary

Given a list of integers, find all subsets that contain consecutive numbers. The problem is to identify these subsets and return them as output.

## Detailed Explanation

The problem can be solved using a straightforward approach. First, sort the input array in ascending order. Then, iterate through the sorted array and maintain a set of consecutive numbers found so far. If the current number is one more than the last number in the set, add it to the set. Otherwise, start a new subset.

Here's a step-by-step breakdown:

1. Sort the input array `nums` in ascending order.
2. Initialize an empty list `result` to store the subsets of consecutive numbers.
3. Iterate through the sorted array:
    * If the current number is one more than the last number in the set, add it to the set.
    * Otherwise, start a new subset and add the current number to it.
4. Add each subset to the `result` list.
5. Return the `result` list.

Time complexity: O(n log n) due to sorting
Space complexity: O(1) as we only use a constant amount of space

Here's an ASCII art diagram representing the process:
```
  +---------------+
  |        nums     |
  |  [1, 2, 3, 5, 6]  |
  +---------------+
           |
           |
           v
  +---------------+
  |    sorted nums   |
  |  [1, 2, 3, 5, 6]  |
  +---------------+
           |
           |
           v
  +---------------+
  |     result      |
  |  [[1, 2], [2, 3], [3, 5], [5, 6]]  |
  +---------------+
```
## Optimized Solutions

### Java
```java
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static List<List<Integer>> minSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        int start = nums[0];
        List<Integer> subset = new ArrayList<>();

        for (int num : nums) {
            if (num == start + 1) {
                subset.add(num);
                start++;
            } else {
                result.add(subset);
                subset = new ArrayList<>();
                subset.add(num);
                start = num;
            }
        }

        result.add(subset);
        return result;
    }
}
```

### Python
```python
def min_subsets(nums):
    nums.sort()
    result = []
    start = nums[0]
    subset = []

    for num in nums:
        if num == start + 1:
            subset.append(num)
            start += 1
        else:
            result.append(subset)
            subset = [num]
            start = num

    result.append(subset)
    return result
```

### C++
```cpp
#include <iostream>
#include <vector>

std::vector<std::vector<int>> minSubsets(int* nums, int n) {
    std::vector<std::vector<int>> result;
    std::sort(nums, nums + n);
    int start = nums[0];
    std::vector<int> subset;

    for (int i = 0; i < n; ++i) {
        if (nums[i] == start + 1) {
            subset.push_back(nums[i]);
            start++;
        } else {
            result.push_back(subset);
            subset.clear();
            subset.push_back(nums[i]);
            start = nums[i];
        }
    }

    result.push_back(subset);
    return result;
}
```

### JavaScript
```javascript
function minSubsets(nums) {
    nums.sort((a, b) => a - b);
    const result = [];
    let start = nums[0];
    let subset = [];

    for (let num of nums) {
        if (num === start + 1) {
            subset.push(num);
            start++;
        } else {
            result.push(subset);
            subset = [num];
            start = num;
        }
    }

    result.push(subset);
    return result;
}
```