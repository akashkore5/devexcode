---
id: "714518"
title: "Construct a Full Binary Tree"
slug: "construct-a-full-binary-tree--170648"
difficulty: "Medium"
companyTags: []
tags: ["Traversal", "Tree", "Data Structures", "Algorithms"]
---

**Construct a Full Binary Tree**
=====================================================

## Summary
Constructing a full binary tree involves creating a tree where each node has at most two children (left and right). This problem requires us to create such a tree given a list of nodes, ensuring that each node has exactly one parent.

The key concepts involved are tree data structures and algorithms, specifically traversal and manipulation techniques.

## Detailed Explanation
To construct a full binary tree from the given list of nodes, we will use an in-order traversal technique. The idea is to insert the middle element from the sorted array as the root of the tree, then recursively create the left and right subtrees.

Here's a step-by-step breakdown of the solution:

1. Sort the array of nodes.
2. Find the middle element (i.e., the median) in the sorted array. This will be the root of our full binary tree.
3. Create a new node with the value of the middle element and add it to the tree as the root.
4. Recursively construct the left subtree by calling the function on the elements before the middle element, and the right subtree by calling the function on the elements after the middle element.
5. Repeat steps 2-4 until all nodes have been inserted into the tree.

Here's an ASCII art diagram to illustrate this process:

```
       3 (root)
     /        \
   1         4
  / \       / \
 0   2   5   6
```

Time complexity: O(n log n) due to sorting, where n is the number of nodes.
Space complexity: O(1), as we only use a constant amount of space.

## Optimized Solutions
### Java
```java
public class FullBinaryTree {
    public static Node construct(Node[] nodes) {
        Arrays.sort(nodes);
        return constructTree(nodes, 0, nodes.length - 1);
    }

    private static Node constructTree(Node[] nodes, int start, int end) {
        if (start > end) {
            return null;
        }
        int mid = start + (end - start) / 2;
        Node root = new Node(nodes[mid]);
        root.left = constructTree(nodes, start, mid - 1);
        root.right = constructTree(nodes, mid + 1, end);
        return root;
    }
}
```
### Python
```python
class FullBinaryTree:
    def construct(self, nodes):
        nodes.sort()
        return self.construct_tree(nodes, 0, len(nodes) - 1)

    def construct_tree(self, nodes, start, end):
        if start > end:
            return None
        mid = (start + end) // 2
        root = Node(nodes[mid])
        root.left = self.construct_tree(nodes, start, mid - 1)
        root.right = self.construct_tree(nodes, mid + 1, end)
        return root
```
### C++
```cpp
class FullBinaryTree {
public:
    Node* construct(Node nodes[], int n) {
        std::sort(nodes, nodes + n);
        return constructTree(nodes, 0, n - 1);
    }

private:
    Node* constructTree(Node nodes[], int start, int end) {
        if (start > end) {
            return nullptr;
        }
        int mid = start + (end - start) / 2;
        Node* root = new Node(nodes[mid]);
        root->left = constructTree(nodes, start, mid - 1);
        root->right = constructTree(nodes, mid + 1, end);
        return root;
    }
};
```
### JavaScript
```javascript
class FullBinaryTree {
  construct(nodes) {
    nodes.sort((a, b) => a - b);
    return this.constructTree(nodes, 0, nodes.length - 1);
  }

  constructTree(nodes, start, end) {
    if (start > end) {
      return null;
    }
    const mid = Math.floor((start + end) / 2);
    const root = new Node(nodes[mid]);
    root.left = this.constructTree(nodes, start, mid - 1);
    root.right = this.constructTree(nodes, mid + 1, end);
    return root;
  }
}
```