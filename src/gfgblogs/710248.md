---
id: "710248"
title: "Longest Path in a Directed Acyclic Graph"
slug: "longest-path-in-a-directed-acyclic-graph"
difficulty: "Hard"
companyTags: []
tags: []
---

Here is a detailed Markdown blog post for the problem "Longest Path in a Directed Acyclic Graph" on GeeksforGeeks:

**Longest Path in a Directed Acyclic Graph**
===============================

## Summary
The problem asks you to find the longest path in a directed acyclic graph (DAG). A DAG is a directed graph where there are no cycles. The longest path is defined as the path with the maximum number of edges.

A key concept involved in this problem is finding the longest path in a DAG, which requires a deep understanding of graph traversal and dynamic programming.

## Detailed Explanation
To solve this problem, we'll use dynamic programming to keep track of the longest path ending at each node. We'll start by initializing an array `dp` with the same size as the number of nodes in the graph. Each element in `dp` will store the maximum length of a path that ends at that node.

Next, we'll iterate over all nodes in the graph and for each node, we'll find the maximum length of a path that ends at its neighbors. We'll add 1 to this value because the current node is also part of the path. If the resulting value is greater than the current `dp` value for the node, we update `dp` with this new value.

Finally, we'll return the maximum value in the `dp` array, which represents the longest path in the graph.

Here's a step-by-step breakdown:

1. Initialize an array `dp` of size `n`, where `n` is the number of nodes in the graph.
2. For each node `u` in the graph:
   1. Find the maximum length of a path that ends at its neighbors.
   2. Add 1 to this value because the current node is also part of the path.
   3. If the resulting value is greater than the current `dp` value for the node, update `dp` with this new value.
3. Return the maximum value in the `dp` array.

Time complexity: O(n + m), where `n` is the number of nodes and `m` is the number of edges in the graph.

Space complexity: O(n), where `n` is the number of nodes in the graph.

## Optimized Solutions
Here are optimized solutions for this problem in various programming languages:

### Java
```java
public int longestPath(DAGNode[] nodes) {
    int n = nodes.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    
    for (DAGNode node : nodes) {
        for (int neighbor : node.getNeighbors()) {
            if (dp[neighbor] + 1 > dp[node.index]) {
                dp[node.index] = dp[neighbor] + 1;
            }
        }
    }
    
    return Arrays.stream(dp).max().getAsInt();
}
```

### Python
```python
def longest_path(nodes):
    n = len(nodes)
    dp = [1] * n
    
    for node in nodes:
        for neighbor in node.neighbors:
            if dp[neighbor] + 1 > dp[node.index]:
                dp[node.index] = dp[neighbor] + 1
    
    return max(dp)
```

### C++
```cpp
int longestPath(vector<DAGNode*> nodes) {
    int n = nodes.size();
    int* dp = new int[n];
    memset(dp, 1, sizeof(int) * n);
    
    for (DAGNode* node : nodes) {
        for (int neighbor : node->getNeighbors()) {
            if (dp[neighbor] + 1 > dp[node->index]) {
                dp[node->index] = dp[neighbor] + 1;
            }
        }
    }
    
    return *max_element(dp, dp + n);
}
```

### JavaScript
```javascript
function longestPath(nodes) {
    let n = nodes.length;
    let dp = new Array(n).fill(1);
    
    for (let node of nodes) {
        for (let neighbor of node.neighbors) {
            if (dp[neighbor] + 1 > dp[node.index]) {
                dp[node.index] = dp[neighbor] + 1;
            }
        }
    }
    
    return Math.max(...dp);
}
```

Note: The code snippets above assume that the `DAGNode` class has methods for getting its index and neighbors.