---
id: "700420"
title: "Max sum subarray by removing at most one element"
slug: "max-sum-subarray-by-removing-at-most-one-element"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Dynamic Programming", "Data Structures", "Algorithms"]
---

**Max sum subarray by removing at most one element**
=====================================================

### Summary
The problem is to find the maximum sum of a subarray that can be obtained by removing at most one element from the original array. This problem involves arrays, dynamic programming, and optimization techniques.

## Detailed Explanation
The approach to solve this problem is to use dynamic programming. We will create a 2D DP table where `dp[i][j]` represents the maximum sum of subarray ending at index `i` with the element at index `j` removed (or not removed).

Here's the step-by-step breakdown:

1. Initialize the DP table: `dp[0][0] = arr[0]`, and `dp[i][j] = 0` for all other indices.
2. Fill the DP table:
	* For each element `arr[i]` in the array, calculate the maximum sum of subarray ending at this index by considering two cases: removing or not removing the current element.
	* If we remove the current element, the maximum sum will be the same as the maximum sum of subarray ending at the previous index. Update `dp[i][1] = dp[i-1][0]`.
	* If we don't remove the current element, the maximum sum will be the current element plus the maximum sum of subarray ending at the previous index minus the current element. Update `dp[i][0] = arr[i] + max(dp[i-1][0], dp[i-1][1])`.
3. Find the maximum sum of subarray: The maximum sum of subarray is the maximum value in the last row of the DP table (`max(dp[n-1][0], dp[n-1][1])`), where `n` is the length of the array.

Time complexity: O(n), where n is the length of the array.
Space complexity: O(n), as we need to store the DP table.

### Optimized Solutions

#### Java
```java
public int maxSumSubarray(int[] arr) {
    int n = arr.length;
    int[][] dp = new int[n][2];
    
    dp[0][0] = arr[0];
    for (int i = 1; i < n; i++) {
        dp[i][0] = Math.max(arr[i], dp[i-1][0] + arr[i]);
        dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1]);
    }
    
    return Math.max(dp[n-1][0], dp[n-1][1]);
}
```

#### Python
```python
def max_sum_subarray(arr):
    n = len(arr)
    dp = [[0, 0] for _ in range(n)]
    
    dp[0][0] = arr[0]
    for i in range(1, n):
        dp[i][0] = max(arr[i], dp[i-1][0] + arr[i])
        dp[i][1] = max(dp[i-1][0], dp[i-1][1])
    
    return max(dp[-1][0], dp[-1][1])
```

#### C++
```cpp
int maxSumSubarray(int* arr, int n) {
    int** dp = new int*[n];
    for (int i = 0; i < n; i++) {
        dp[i] = new int[2];
    }
    
    dp[0][0] = arr[0];
    for (int i = 1; i < n; i++) {
        dp[i][0] = max(arr[i], dp[i-1][0] + arr[i]);
        dp[i][1] = max(dp[i-1][0], dp[i-1][1]);
    }
    
    int result = max(dp[n-1][0], dp[n-1][1]);
    
    for (int i = 0; i < n; i++) {
        delete[] dp[i];
    }
    delete[] dp;
    
    return result;
}
```

#### JavaScript
```javascript
function maxSumSubarray(arr) {
    let n = arr.length;
    let dp = new Array(n).fill(0).map(() => [0, 0]);
    
    dp[0][0] = arr[0];
    for (let i = 1; i < n; i++) {
        dp[i][0] = Math.max(arr[i], dp[i-1][0] + arr[i]);
        dp[i][1] = Math.max(dp[i-1][0], dp[i-1][1]);
    }
    
    return Math.max(dp[n-1][0], dp[n-1][1]);
}
```