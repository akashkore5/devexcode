---
id: "712234"
title: "Prefix to Infix Conversion"
slug: "prefix-to-infix-conversion"
difficulty: "Medium"
companyTags: []
tags: []
---

**Prefix to Infix Conversion**
=========================

### Summary

The Prefix to Infix Conversion problem involves transforming a mathematical expression written in prefix notation (also known as Polish notation) into infix notation. This problem requires understanding of the fundamental concepts of operator precedence, parentheses, and order of operations.

### Detailed Explanation

The input is a string representing a mathematical expression in prefix notation. The goal is to convert this expression into infix notation, which is more readable and understandable for humans. To achieve this, we need to follow certain rules:

1.  For every binary operator (like +, -, \*, /) encountered in the prefix notation, insert parentheses around the operator and its operands.
2.  The operands should be evaluated first according to their order of operations.

Here is a step-by-step breakdown of the solution:

1.  Initialize an empty string result to store the infix expression.
2.  Iterate through the input string from right to left (start with the last character).
3.  If the current operator is a binary operator, insert parentheses around it and its operands in the result string.
4.  For each operand encountered, evaluate it according to its order of operations and append it to the result string.
5.  Continue this process until all characters have been processed.

Time Complexity: O(n), where n is the length of the input string.
Space Complexity: O(n), as in the worst-case scenario we might need to store all characters in the result string.

### Optimized Solutions

#### Java
```java
public class PrefixToInfix {
    public static String convert(String prefix) {
        StringBuilder infix = new StringBuilder();
        for (int i = prefix.length() - 1; i >= 0; i--) {
            char c = prefix.charAt(i);
            if (isOperator(c)) {
                infix.insert(0, "(").insert(0, c).append(")");
            } else {
                infix.insert(0, c);
            }
        }
        return infix.toString();
    }

    private static boolean isOperator(char c) {
        String operators = "+-*/";
        return operators.indexOf(c) != -1;
    }
}
```

#### Python
```python
def prefix_to_infix(prefix):
    infix = ""
    for char in reversed(prefix):
        if char in "+-*/":
            infix = "(" + char + ")" + infix
        else:
            infix = char + infix
    return infix
```

#### C++
```cpp
#include <iostream>
#include <stack>
#include <string>

std::string prefixToInfix(const std::string& prefix) {
    std::stack<char> operators;
    std::string infix;

    for (int i = prefix.length() - 1; i >= 0; i--) {
        char c = prefix[i];

        if (isOperator(c)) {
            while (!operators.empty()) {
                infix += operators.top();
                operators.pop();
            }
            infix += c;
        } else {
            infix += c;
        }

        if (c == '(') {
            operators.push(c);
        } else if (c == ')') {
            while (operators.top() != '(') {
                infix += operators.top();
                operators.pop();
            }
            operators.pop(); // pop the '('
        }
    }

    while (!operators.empty()) {
        infix += operators.top();
        operators.pop();
    }

    return std::string(infix.rbegin(), infix.rend());
}

bool isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/';
}
```

#### JavaScript
```javascript
function prefixToInfix(prefix) {
  let infix = "";
  for (let i = prefix.length - 1; i >= 0; i--) {
    const char = prefix[i];
    if (isOperator(char)) {
      infix = "(" + char + ")" + infix;
    } else {
      infix = char + infix;
    }
  }
  return infix;
}

function isOperator(char) {
  return "+-*/".includes(char);
}
```

These optimized solutions provide a more efficient and readable way to convert prefix notation into infix notation.