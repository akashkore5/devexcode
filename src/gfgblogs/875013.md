---
id: "875013"
title: "Maximum score from at most K jumps"
slug: "maximum-score-from-at-most-k-jumps"
difficulty: "Medium"
companyTags: []
tags: ["Dynamic Programming", "Arrays", "Map"]
---

**Maximum score from at most K jumps**
==================================================

## Summary
The problem is to find the maximum score that can be obtained by making at most K jumps in a given array. The score for each jump is calculated based on the value at the starting and ending indices of the jump. This problem involves dynamic programming, arrays, and map data structures.

## Detailed Explanation
The approach to solve this problem is to use dynamic programming with memoization. We create a 2D DP table `dp` where `dp[i][j]` represents the maximum score that can be obtained by making at most j jumps starting from index i.

Here's the step-by-step breakdown of the solution:

1. Initialize the DP table with zeros: `dp = [[0 for _ in range(K + 1)] for _ in range(n + 1)]`
2. Fill the DP table using a bottom-up approach:
	* For each index i and jump count j, calculate the maximum score that can be obtained by making at most j jumps starting from index i.
	* If j is 0, set `dp[i][j] = arr[i]` because we cannot make any more jumps.
	* Otherwise, iterate over all possible ending indices for the current jump:
		+ For each ending index k, calculate the score for the current jump: `score = dp[k][j - 1] + (arr[k] - arr[i])`
		+ Update the DP table: `dp[i][j] = max(dp[i][j], score)`
3. The maximum score is stored in `dp[0][K]`, which represents the maximum score that can be obtained by making at most K jumps starting from index 0.

Time complexity: O(n \* K)
Space complexity: O(n \* K)

## Optimized Solutions
### Java
```java
public int maxScore(int[] arr, int K) {
    int n = arr.length;
    int[][] dp = new int[n][K + 1];
    for (int i = 0; i < n; i++) {
        dp[i][0] = arr[i];
    }
    for (int j = 1; j <= K; j++) {
        for (int i = j - 1; i >= 0; i--) {
            int score = dp[i + j][j - 1] + (arr[i + j] - arr[i]);
            dp[i][j] = Math.max(dp[i][j], score);
        }
    }
    return dp[0][K];
}
```

### Python
```python
def max_score(arr, K):
    n = len(arr)
    dp = [[0 for _ in range(K + 1)] for _ in range(n + 1)]
    for i in range(n):
        dp[i][0] = arr[i]
    for j in range(1, K + 1):
        for i in range(j - 1, -1, -1):
            score = dp[i + j][j - 1] + (arr[i + j] - arr[i])
            dp[i][j] = max(dp[i][j], score)
    return dp[0][K]
```

### C++
```cpp
int maxScore(int* arr, int n, int K) {
    int** dp = new int*[n];
    for (int i = 0; i < n; i++) {
        dp[i] = new int[K + 1];
    }
    for (int i = 0; i < n; i++) {
        dp[i][0] = arr[i];
    }
    for (int j = 1; j <= K; j++) {
        for (int i = j - 1; i >= 0; i--) {
            int score = dp[i + j][j - 1] + (arr[i + j] - arr[i]);
            dp[i][j] = std::max(dp[i][j], score);
        }
    }
    int max_score = dp[0][K];
    for (int i = 0; i < n; i++) {
        delete[] dp[i];
    }
    delete[] dp;
    return max_score;
}
```

### JavaScript
```javascript
function maxScore(arr, K) {
    let n = arr.length;
    let dp = new Array(n).fill().map(() => new Array(K + 1).fill(0));
    for (let i = 0; i < n; i++) {
        dp[i][0] = arr[i];
    }
    for (let j = 1; j <= K; j++) {
        for (let i = j - 1; i >= 0; i--) {
            let score = dp[i + j][j - 1] + (arr[i + j] - arr[i]);
            dp[i][j] = Math.max(dp[i][j], score);
        }
    }
    return dp[0][K];
}
```

Note that the optimized solutions are provided in Java, Python, C++, and JavaScript.