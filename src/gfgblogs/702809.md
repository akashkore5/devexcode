---
id: "702809"
title: "Happiest Triplet"
slug: "happiest-triplet2921"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Searching", "Sorting", "Data Structures", "Algorithms"]
---

# Happiest Triplet
## Slug: happiest-triplet2921
## Difficulty: Medium
## Id: 702809
## Topic Tags: Arrays, Searching, Sorting, Data Structures, Algorithms
## Company Tags: None

### Summary
Find three indices i, j, and k in an array such that the triplet (arr[i], arr[j], arr[k]) is the smallest possible. If no such triplet exists, return -1.

The problem involves manipulating arrays to find specific patterns, which requires efficient searching and sorting algorithms.

### Detailed Explanation

To solve this problem, we can use a simple approach by iterating through the array and keeping track of the minimum triplet found so far. We compare each triplet with the current minimum and update it if necessary.

Here's a step-by-step breakdown of the solution:

1. Initialize variables `min_triplet` to represent the smallest possible triplet (with arbitrary values), and `result` to store the final answer.
2. Iterate through the array using two nested loops: `i` as the outer loop, ranging from 0 to `arr.length - 2`, and `j` as the inner loop, ranging from `i + 1` to `arr.length - 1`.
3. For each pair `(i, j)`, calculate the sum of elements at indices `i`, `j`, and `k = arr.length - 1`. This represents a possible triplet.
4. Compare this new triplet with `min_triplet`. If it's smaller (or equal), update `min_triplet`.
5. After iterating through all pairs, return `result` if the minimum triplet was found; otherwise, return `-1`.

Time complexity: O(n^2) due to nested loops.
Space complexity: O(1) as we only use a few extra variables.

### Optimized Solutions

#### Java
```java
public int findHappiestTriplet(int[] arr) {
    int min_triplet = Integer.MAX_VALUE;
    for (int i = 0; i < arr.length - 2; i++) {
        for (int j = i + 1; j < arr.length - 1; j++) {
            int sum = arr[i] + arr[j] + arr[arr.length - 1];
            if (sum < min_triplet) {
                min_triplet = sum;
            }
        }
    }
    return min_triplet == Integer.MAX_VALUE ? -1 : min_triplet;
}
```

#### Python
```python
def find_happiest_triplet(arr):
    min_triplet = float('inf')
    for i in range(len(arr) - 2):
        for j in range(i + 1, len(arr) - 1):
            sum = arr[i] + arr[j] + arr[-1]
            if sum < min_triplet:
                min_triplet = sum
    return -1 if min_triplet == float('inf') else min_triplet
```

#### C++
```cpp
int findHappiestTriplet(int* arr, int n) {
    int min_triplet = INT_MAX;
    for (int i = 0; i < n - 2; i++) {
        for (int j = i + 1; j < n - 1; j++) {
            int sum = arr[i] + arr[j] + arr[n - 1];
            if (sum < min_triplet) {
                min_triplet = sum;
            }
        }
    }
    return min_triplet == INT_MAX ? -1 : min_triplet;
}
```

#### JavaScript
```javascript
function findHappiestTriplet(arr) {
    let min_triplet = Infinity;
    for (let i = 0; i < arr.length - 2; i++) {
        for (let j = i + 1; j < arr.length - 1; j++) {
            let sum = arr[i] + arr[j] + arr[arr.length - 1];
            if (sum < min_triplet) {
                min_triplet = sum;
            }
        }
    }
    return min_triplet === Infinity ? -1 : min_triplet;
}
```

Feel free to modify the code blocks as needed, but keep in mind that this is just one possible implementation.