---
id: "702865"
title: "Largest Permutation"
slug: "largest-permutation1351"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Greedy", "Data Structures", "Algorithms"]
---

# Largest Permutation
## Slug: largest-permutation1351
## Difficulty: Easy
## Id: 702865
## Topic Tags: Arrays, Greedy, Data Structures, Algorithms
## Company Tags: None

### Summary
Given a permutation of size n, the task is to find the largest possible permutation. A permutation is an arrangement of all integers from 1 to n in some order.

### Detailed Explanation

To solve this problem, we can use a greedy approach. We initialize our result with the maximum value (n) and then iterate over the range [n-1, 1]. For each iteration, we add the current value to our result if it's greater than or equal to the last element in our result. This ensures that our result is always increasing.

Here's a step-by-step breakdown of the solution:

* Initialize an empty list `result` and set its first element to `n`.
* Iterate over the range `[n-1, 1]` (inclusive).
* For each iteration, check if the current value is greater than or equal to the last element in `result`. If it is, add it to `result`.
* Return the `result`.

The time complexity of this solution is O(n), where n is the size of the permutation. The space complexity is also O(n) as we need to store the result.

Here's an ASCII art diagram illustrating the approach:
```
  n (max value)
  v
1, 2, ..., n-1 (range)

iterate over range:
  n-1: add if > last element in result
  n-2: add if > last element in result
  ...
  1: add if > last element in result

result = [n, n-1, ..., 2, 1]
```

### Optimized Solutions

#### Java
```java
public static int[] largestPermutation(int n) {
    int[] result = new int[n];
    for (int i = n - 1; i >= 0; i--) {
        if (i < result[i]) {
            result[i] = i + 1;
        }
    }
    return result;
}
```

#### Python
```python
def largest_permutation(n):
    result = [n]
    for i in range(n - 1, 0, -1):
        if i > result[-1]:
            result.append(i)
    return result
```

#### C++
```cpp
int* largestPermutation(int n) {
    int* result = new int[n];
    for (int i = n - 1; i >= 0; i--) {
        if (i < result[i]) {
            result[i] = i + 1;
        }
    }
    return result;
}
```

#### JavaScript
```javascript
function largestPermutation(n) {
    let result = [n];
    for (let i = n - 1; i >= 0; i--) {
        if (i > result[result.length - 1]) {
            result.push(i);
        }
    }
    return result;
}
```

Note that these solutions assume a 0-based indexing system, where the first element in the permutation is at index 0.