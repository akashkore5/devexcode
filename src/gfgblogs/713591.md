---
id: "713591"
title: "Prime List"
slug: "prime-list--170646"
difficulty: "Medium"
companyTags: []
tags: ["Linked List", "Mathematical", "Prime Number", "Data Structures", "Algorithms"]
---

**Prime List**
================

**Slug:** prime-list--170646
**Difficulty:** Medium
**Id:** 713591
**Topic Tags:** Linked List, Mathematical, Prime Number, Data Structures, Algorithms
**Company Tags:** None

## Summary
The problem involves generating a list of prime numbers. The key concept involved is the generation of prime numbers, which requires an understanding of mathematical concepts such as primality testing and sieve algorithms. The solution requires efficient data structures like linked lists to store and manipulate the prime numbers.

## Detailed Explanation
To solve this problem, we will use the Sieve of Eratosthenes algorithm, a popular method for generating prime numbers. This algorithm works by iteratively marking the multiples of each prime number starting from 2. The multiples of a given prime are generated as a sequence of numbers: `p`, `2p`, `3p`, `4p`, ...; these can be written in the form `nk`, where `n` is any positive integer, and `k` is the index of the multiple.

Here's a step-by-step breakdown of the solution:

1. Initialize an array or linked list to store prime numbers.
2. Start from 2 (the first prime number) and iterate until the desired limit.
3. For each number `i`, check if it is a prime by iterating from 2 to sqrt(`i`) and checking if `i` is divisible by any of these numbers.
4. If `i` is not divisible by any of these numbers, mark it as prime in the list.
5. Continue this process until the desired limit is reached.

Time complexity: O(n log log n) due to the use of the Sieve of Eratosthenes algorithm.
Space complexity: O(n) for storing the prime numbers in a linked list or array.

## Optimized Solutions
### Java
```java
import java.util.ArrayList;
import java.util.List;

public class PrimeList {
    public static List<Integer> generatePrimes(int n) {
        boolean[] isPrime = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isPrime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = true;
                }
            }
        }
        List<Integer> primes = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (!isPrime[i]) {
                primes.add(i);
            }
        }
        return primes;
    }
}
```

### Python
```python
def generate_primes(n):
    is_prime = [True] * (n + 1)
    for i in range(2, int(n ** 0.5) + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
    return [i for i in range(2, n + 1) if is_prime[i]]
```

### C++
```cpp
#include <vector>
#include <cmath>

std::vector<int> generatePrimes(int n) {
    std::vector<bool> isPrime(n + 1, true);
    for (int i = 2; i <= sqrt(n); i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    std::vector<int> primes;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push_back(i);
        }
    }
    return primes;
}
```

### JavaScript
```javascript
function generatePrimes(n) {
    let isPrime = new Array(n + 1).fill(true);
    for (let i = 2; Math.sqrt(i) <= n; i++) {
        if (isPrime[i]) {
            for (let j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    let primes = [];
    for (let i = 2; i <= n; i++) {
        if (isPrime[i]) {
            primes.push(i);
        }
    }
    return primes;
}
```

These solutions generate the list of prime numbers up to a given limit `n`. The time complexity is O(n log log n) due to the use of the Sieve of Eratosthenes algorithm.