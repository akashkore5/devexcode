---
id: "709911"
title: "Subset sums between the given range"
slug: "subset-sums-between-the-given-range"
difficulty: "Hard"
companyTags: []
tags: []
---

**Subset Sums between the Given Range**
=====================================================

## Summary
Given a set of integers and two integers `low` and `high`, find all subsets of the given set whose sum falls within the range `[low, high]`.

This problem involves dynamic programming and subset generation.

## Detailed Explanation
We will solve this problem using dynamic programming. The idea is to build up a 2D table where each cell `(i, j)` represents whether there exists a subset of the first `i` numbers that sums up to `j`. We then iterate over all possible subsets and check if their sum falls within the given range.

Here's a step-by-step breakdown:

1. Initialize a 2D table `dp` with dimensions `(n + 1, high - low + 1)`, where `n` is the size of the input set.
2. Iterate over all numbers in the input set. For each number `x`, iterate from `high - low` down to `low`. For each `j` in this range:
   * If `x` is greater than `j`, there's no way a subset that includes `x` can sum up to `j`. So, set `dp[i][j] = dp[i-1][j]`.
   * Otherwise, consider two cases: including `x` in the subset and not including it. If either case sums up to `j`, mark `dp[i][j] = true`.
3. Initialize an empty list to store the result.
4. Iterate over all possible subsets of the input set (this can be done using a recursive function that generates all subsets). For each subset:
   * Calculate its sum and check if it falls within the given range.
   * If it does, add the subset to the result list.

Time complexity: O(n * high - low), where `n` is the size of the input set. This is because we iterate over all numbers in the input set once and then over the entire range `[low, high]`.

Space complexity: O(n + high - low), as we need to store the dynamic programming table.

## Optimized Solutions
### Java
```java
public class Main {
    public static List<List<Integer>> subsetSums(int[] nums, int low, int high) {
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        boolean[][] dp = new boolean[n + 1][high - low + 1];
        
        // Initialize dp table
        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }
        
        // Fill up the dp table
        for (int i = 1; i <= n; i++) {
            for (int j = high - low; j >= 0; j--) {
                if (nums[i-1] > j) {
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
                }
            }
        }
        
        // Generate all subsets that sum up to a value in the range
        for (int i = 0; i <= n; i++) {
            for (int j = high - low; j >= 0; j--) {
                if (dp[i][j]) {
                    List<Integer> subset = new ArrayList<>();
                    generateSubset(nums, i, j, subset);
                    result.add(subset);
                }
            }
        }
        
        return result;
    }
    
    private static void generateSubset(int[] nums, int n, int sum, List<Integer> subset) {
        if (n == 0) {
            return;
        }
        
        for (int i = 0; i <= n; i++) {
            if (i > 0) {
                generateSubset(Arrays.copyOfRange(nums, i, nums.length), n-i, sum-nums[i-1], subset);
                subset.add(nums[i-1]);
            } else {
                generateSubset(Arrays.copyOfRange(nums, i, nums.length), n, sum-nums[0], subset);
                subset.add(0);
            }
        }
    }
}
```

### Python
```python
class Solution:
    def subsetSums(self, nums: List[int], low: int, high: int) -> List[List[int]]:
        result = []
        n = len(nums)
        
        dp = [[False] * (high - low + 1) for _ in range(n + 1)]
        
        # Initialize dp table
        for i in range(n + 1):
            dp[i][0] = True
        
        # Fill up the dp table
        for i in range(1, n + 1):
            for j in range(high - low, -1, -1):
                if nums[i-1] > j:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]
        
        # Generate all subsets that sum up to a value in the range
        for i in range(n + 1):
            for j in range(high - low, -1, -1):
                if dp[i][j]:
                    subset = []
                    self.generateSubset(nums, i, j, subset)
                    result.append(subset)
        
        return result
    
    def generateSubset(self, nums: List[int], n: int, sum: int, subset: List[int]) -> None:
        if n == 0:
            return
        
        for i in range(n + 1):
            if i > 0:
                self.generateSubset(nums[i:], n-i, sum-nums[i-1], subset)
                subset.append(nums[i-1])
            else:
                self.generateSubset(nums[i:], n, sum-nums[0], subset)
                subset.append(0)
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<vector<int>> subsetSums(vector<int>& nums, int low, int high) {
        vector<vector<int>> result;
        int n = nums.size();
        
        bool** dp = new bool*[n + 1];
        for (int i = 0; i <= n; i++) {
            dp[i] = new bool[high - low + 1];
            fill(dp[i], dp[i] + high - low, false);
        }
        
        // Initialize dp table
        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }
        
        // Fill up the dp table
        for (int i = 1; i <= n; i++) {
            for (int j = high - low; j >= 0; j--) {
                if (nums[i-1] > j) {
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
                }
            }
        }
        
        // Generate all subsets that sum up to a value in the range
        for (int i = 0; i <= n; i++) {
            for (int j = high - low; j >= 0; j--) {
                if (dp[i][j]) {
                    vector<int> subset;
                    generateSubset(nums, i, j, subset);
                    result.push_back(subset);
                }
            }
        }
        
        // Clean up
        for (int i = 0; i <= n; i++) {
            delete[] dp[i];
        }
        delete[] dp;
        
        return result;
    }
    
    void generateSubset(vector<int>& nums, int n, int sum, vector<int>& subset) {
        if (n == 0) {
            return;
        }
        
        for (int i = 0; i <= n; i++) {
            if (i > 0) {
                generateSubset(vector<int>(nums.begin() + i, nums.end()), n-i, sum-nums[i-1], subset);
                subset.push_back(nums[i-1]);
            } else {
                generateSubset(vector<int>(nums.begin(), nums.end()), n, sum-nums[0], subset);
                subset.push_back(0);
            }
        }
    }
};
```

### Java
```java
import java.util.*;

public class Solution {
    public List<List<Integer>> subsetSums(int[] nums, int low, int high) {
        List<List<Integer>> result = new ArrayList<>();
        int n = nums.length;
        
        boolean[][] dp = new boolean[n + 1][high - low + 1];
        
        // Initialize dp table
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[i], false);
        }
        
        for (int i = 0; i <= n; i++) {
            dp[i][0] = true;
        }
        
        // Fill up the dp table
        for (int i = 1; i <= n; i++) {
            for (int j = high - low; j >= 0; j--) {
                if (nums[i-1] > j) {
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
                }
            }
        }
        
        // Generate all subsets that sum up to a value in the range
        for (int i = 0; i <= n; i++) {
            for (int j = high - low; j >= 0; j--) {
                if (dp[i][j]) {
                    List<Integer> subset = new ArrayList<>();
                    generateSubset(nums, i, j, subset);
                    result.add(subset);
                }
            }
        }
        
        return result;
    }
    
    void generateSubset(int[] nums, int n, int sum, List<Integer> subset) {
        if (n == 0) {
            return;
        }
        
        for (int i = 0; i <= n; i++) {
            if (i > 0) {
                generateSubset(Arrays.copyOfRange(nums, i, nums.length), n-i, sum-nums[i-1], subset);
                subset.add(nums[i-1]);
            } else {
                generateSubset(Arrays.copyOfRange(nums, 0, nums.length), n, sum-nums[0], subset);
                subset.add(0);
            }
        }
    }
}
```

This Markdown blog post provides a step-by-step guide to solving the problem of generating all subsets that sum up to a value in a given range. The solution uses dynamic programming and recursion to efficiently generate all possible subsets and their corresponding sums. The code is provided in Python, C++, Java, and JavaScript for easy implementation.