---
id: "712209"
title: "Subset II"
slug: "subset-sum-ii"
difficulty: "Medium"
companyTags: []
tags: []
---

**Subset II**
=====================

## Summary
Given an array of integers, find all unique subsets that have a sum equal to a given target value. This problem is about generating all possible subsets of an array and checking their sums against a target value.

## Detailed Explanation
The approach to solve this problem involves using recursion and backtracking. We start by considering each element in the array as a potential subset and recursively generate all subsets that can be formed using this element. For each subset, we calculate its sum and check if it equals the target value. If it does, we add it to our result set.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty result set to store unique subsets with sums equal to the target value.
2. Define a recursive function `generateSubsets` that takes the array and the current subset as inputs.
3. For each element in the array, consider it as a potential subset and recursively generate all subsets that can be formed using this element.
4. For each generated subset, calculate its sum and check if it equals the target value.
5. If the sum equals the target value, add the subset to our result set.
6. Backtrack by removing the current element from the subset and continue generating subsets for the remaining elements.

Here's an ASCII art diagram illustrating the recursive process:

```
          +---------------+
          |  Array [1, 2, 3]  |
          +---------------+
                  |
                  | (1) Generate subsets using first element
                  |    -> [1], [1, 2], [1, 2, 3]
                  v
+---------------+       +---------------+       +---------------+
|  Subsets:      |       |  Subsets:     |       |  Subsets:    |
|  [1]          |       |  [1, 2]     |       |  [1, 2, 3]   |
|  [1, 2]      |       |  [1, 2, 3] |       |                |
+---------------+       +---------------+       +---------------+
                  |
                  | (2) Calculate sums and check against target
                  |    -> [1]: 1, [1, 2]: 3, [1, 2, 3]: 6
                  v
          +---------------+
          |  Result: [[1], [1, 2]]  |
          +---------------+
```

Time complexity: O(2^n), where n is the length of the array. This is because we generate all possible subsets and calculate their sums.
Space complexity: O(n), as we need to store the current subset being generated.

## Optimized Solutions

#### Java
```java
import java.util.*;

public class SubsetII {
    public List<List<Integer>> subsetSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, new ArrayList<>(), nums, 0, target);
        return result;
    }

    private void backtrack(List<List<Integer>> result, List<Integer> current, int[] nums, int start, int target) {
        if (target < 0) return; // sum exceeds the target
        if (target == 0) result.add(new ArrayList<>(current)); // found a subset with the target sum
        for (int i = start; i < nums.length; i++) {
            current.add(nums[i]);
            backtrack(result, current, nums, i + 1, target - nums[i]);
            current.remove(current.size() - 1);
        }
    }
}
```

#### Python
```python
def subset_sum(nums, target):
    result = []
    backtrack(result, [], nums, 0, target)
    return result

def backtrack(result, current, nums, start, target):
    if target < 0:
        return  # sum exceeds the target
    if target == 0:
        result.append(current[:])  # found a subset with the target sum
    for i in range(start, len(nums)):
        current.append(nums[i])
        backtrack(result, current, nums, i + 1, target - nums[i])
        current.pop()
```

#### C++
```cpp
#include <vector>
#include <list>

std::vector<std::vector<int>> subsetSum(std::vector<int>& nums, int target) {
    std::vector<std::vector<int>> result;
    backtrack(result, {}, nums, 0, target);
    return result;
}

void backtrack(std::vector<std::vector<int>>& result, std::vector<int>& current, const std::vector<int>& nums, int start, int target) {
    if (target < 0) return; // sum exceeds the target
    if (target == 0) result.push_back(current); // found a subset with the target sum
    for (int i = start; i < nums.size(); i++) {
        current.push_back(nums[i]);
        backtrack(result, current, nums, i + 1, target - nums[i]);
        current.pop_back();
    }
}
```

#### JavaScript
```javascript
function subsetSum(nums, target) {
    let result = [];
    backtrack(result, [], nums, 0, target);
    return result;
}

function backtrack(result, current, nums, start, target) {
    if (target < 0) return; // sum exceeds the target
    if (target == 0) result.push([...current]); // found a subset with the target sum
    for (let i = start; i < nums.length; i++) {
        current.push(nums[i]);
        backtrack(result, current, nums, i + 1, target - nums[i]);
        current.pop();
    }
}
```