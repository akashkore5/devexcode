---
id: "700635"
title: "Find n/k th node in Linked list"
slug: "find-nk-th-node-in-linked-list"
difficulty: "Easy"
companyTags: ["Hike", "SAP Labs"]
tags: ["Linked List", "Data Structures"]
---

Here is a detailed Markdown blog post for the problem "Find n/k th node in Linked list":

# Find n/k th node in Linked list
## Summary
Given a linked list and two integers `n` and `k`, find the `n/k`th node from the beginning of the linked list. This problem requires understanding of linked lists, traversal, and basic arithmetic operations.

## Detailed Explanation

To solve this problem, we will use a simple approach: traverse the linked list until we reach the desired node. We will keep track of the current node and increment a counter whenever we move to the next node.

Here is a step-by-step breakdown:

1. Initialize a variable `count` to 0 and a pointer `current` to the head of the linked list.
2. Traverse the linked list until `count` is greater than or equal to `n/k`.
3. Increment `count` by 1 for each node visited.
4. When `count` is greater than or equal to `n/k`, return the current node.

To ensure we reach the correct node, we can maintain an additional variable `k_count` to keep track of how many nodes have been traversed so far. We increment this counter whenever we move to the next node and reset it when we find a new multiple of `k`. This ensures that we don't miss any nodes.

Here's a diagram illustrating the traversal:
```
Head -> Node 1 -> Node 2 -> ... -> Node n/k
          ^     ^
          |     |
         k_count = 0
```
Time complexity: O(n) as we need to traverse the linked list once.
Space complexity: O(1) as we only use a constant amount of space to store the variables.

## Optimized Solutions

### Java
```java
public Node findNthNode(Node head, int n, int k) {
    Node current = head;
    int count = 0;
    int k_count = 0;

    while (current != null) {
        count++;
        if (count % k == 0) k_count++;

        if (k_count == n) return current;

        current = current.next;
    }

    return null; // not found
}
```

### Python
```python
def find_nth_node(head, n, k):
    current = head
    count = 0
    k_count = 0

    while current:
        count += 1
        if count % k == 0:
            k_count += 1

        if k_count == n:
            return current

        current = current.next

    return None  # not found
```

### C++
```cpp
Node* findNthNode(Node* head, int n, int k) {
    Node* current = head;
    int count = 0;
    int k_count = 0;

    while (current != nullptr) {
        count++;
        if (count % k == 0) k_count++;

        if (k_count == n) return current;

        current = current->next;
    }

    return nullptr; // not found
}
```

### JavaScript
```javascript
function findNthNode(head, n, k) {
    let current = head;
    let count = 0;
    let kCount = 0;

    while (current) {
        count++;
        if (count % k === 0) kCount++;

        if (kCount === n) return current;

        current = current.next;
    }

    return null; // not found
}
```

Note: The above solutions assume that the linked list nodes are numbered starting from 1. If the nodes are numbered starting from 0, you can adjust the condition in the while loop accordingly.