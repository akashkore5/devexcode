---
id: "716818"
title: "Making A Large Island"
slug: "making-a-large-island"
difficulty: "Hard"
companyTags: ["Intuit"]
tags: ["Matrix", "DFS", "BFS", "union-find"]
---

Here is the Markdown blog post for the problem:

# Making A Large Island
Slug: making-a-large-island
Difficulty: Hard
Id: 716818
Topic Tags: Matrix, DFS, BFS, union-find
Company Tags: Intuit

## Summary
In this problem, we are given a matrix where each cell can be either land (represented by '0') or water (represented by '1'). We need to find the size of the largest island in the given matrix. An island is defined as any group of connected '0's surrounded by '1's.

## Detailed Explanation
The approach to solve this problem involves using a union-find algorithm with depth-first search (DFS) and breadth-first search (BFS). The idea is to traverse the matrix and mark all connected land cells as visited. We start from each unvisited cell and explore its neighbors. If we find an unvisited neighbor, we mark it as visited and add its size to our current island's size.

Here is a step-by-step breakdown of the solution:

1. Initialize a variable `maxSize` to store the maximum size of an island.
2. Iterate through each cell in the matrix.
3. If the cell is land ('0'), perform DFS/BFS to find all connected land cells and mark them as visited.
4. Calculate the size of the current island by subtracting the number of visited cells from the total number of cells.
5. Update `maxSize` if the current island's size is greater than `maxSize`.
6. Repeat steps 2-5 for each cell in the matrix.

Time complexity: O(m*n) where m and n are the dimensions of the matrix, as we need to visit each cell once.

Space complexity: O(m*n) as we need to store the visited cells.

## Optimized Solutions
### Java
```java
public class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        int maxSize = 0, m = grid.length, n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    int islandSize = dfs(grid, i, j);
                    maxSize = Math.max(maxSize, islandSize);
                }
            }
        }
        return maxSize;
    }

    private int dfs(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) return 0;
        grid[i][j] = 0; // mark as visited
        int size = 1;
        for (int[][] dir : directions) {
            int ni = i + dir[0], nj = j + dir[1];
            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {
                size += dfs(grid, ni, nj);
            }
        }
        return size;
    }

    private static int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
}
```

### Python
```python
def maxAreaOfIsland(grid):
    if not grid:
        return 0
    m, n = len(grid), len(grid[0])
    maxSize = 0
    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                islandSize = dfs(grid, i, j)
                maxSize = max(maxSize, islandSize)

    return maxSize

def dfs(grid, i, j):
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0:
        return 0
    grid[i][j] = 0  # mark as visited
    size = 1
    for dir in directions:
        ni, nj = i + dir[0], j + dir[1]
        if (ni >= 0 and ni < len(grid) and nj >= 0 and nj < len(grid[0]) and grid[ni][nj] == 1):
            size += dfs(grid, ni, nj)
    return size

directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
```

### C++
```cpp
class Solution {
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        if (!grid.size()) return 0;
        int maxSize = 0, m = grid.size(), n = grid[0].size();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    int islandSize = dfs(grid, i, j);
                    maxSize = max(maxSize, islandSize);
                }
            }
        }
        return maxSize;
    }

    int dfs(vector<vector<int>>& grid, int i, int j) {
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0) return 0;
        grid[i][j] = 0; // mark as visited
        int size = 1;
        for (int[][] dir : directions) {
            int ni = i + dir[0], nj = j + dir[1];
            if (ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == 1) {
                size += dfs(grid, ni, nj);
            }
        }
        return size;
    }

    vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
};
```

### JavaScript
```javascript
function maxAreaOfIsland(grid) {
    if (!grid.length) return 0;
    let maxSize = 0, m = grid.length, n = grid[0].length;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                let islandSize = dfs(grid, i, j);
                maxSize = Math.max(maxSize, islandSize);
            }
        }
    }
    return maxSize;
}

function dfs(grid, i, j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) return 0;
    grid[i][j] = 0; // mark as visited
    let size = 1;
    for (let dir of directions) {
        let ni = i + dir[0], nj = j + dir[1];
        if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {
            size += dfs(grid, ni, nj);
        }
    }
    return size;
}

const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
```