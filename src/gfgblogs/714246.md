---
id: "714246"
title: "Shortest XY distance in Grid"
slug: "shortest-xy-distance-in-grid--170647"
difficulty: "Medium"
companyTags: ["Google"]
tags: ["Dynamic Programming", "BFS", "Algorithms"]
---

**Shortest XY Distance in Grid**
===============

## Summary
Given a grid with dimensions `m` and `n`, find the shortest distance between two points `(x1, y1)` and `(x2, y2)`. The distance is measured as the minimum number of steps to reach `(x2, y2)` from `(x1, y1)`, where each step can be either horizontally or vertically.

## Detailed Explanation

To solve this problem, we will use Breadth-First Search (BFS) algorithm. BFS is a traversal algorithm that starts at the root node and visits all nodes in layer-by-layer order. In our case, we start from `(x1, y1)` and traverse the grid until we reach `(x2, y2)`.

Here's a step-by-step breakdown of the solution:

1. Create a queue to store cells to visit.
2. Initialize the distance matrix with infinity for all cells except the starting cell `(x1, y1)`, which is set to 0.
3. Enqueue the starting cell and mark it as visited.
4. While the queue is not empty:
   - Dequeue a cell and consider its neighbors (up, down, left, right).
   - For each neighbor that has not been visited yet, update the distance matrix with the minimum of its current value and the distance from `(x1, y1)` to the dequeued cell plus 1.
   - Mark the neighbor as visited.
5. Return the shortest distance between `(x1, y1)` and `(x2, y2)`, which is stored in the distance matrix at position `(x2, y2)`.

Here's an ASCII art diagram of the grid:
```
 0 1 2 ... n-1
0 | x1 | x1+1 | ... | x2
1 | x1-1 | x1 | ... |
...
m-1 | ... | ... | ... | x2
```

Time complexity: O(m\*n)
Space complexity: O(m\*n)

## Optimized Solutions

### Java
```java
import java.util.*;

public class ShortestXYDistance {
    public static int shortestXY(int[][] grid, int[] start, int[] end) {
        int m = grid.length;
        int n = grid[0].length;

        // Create a distance matrix with infinity for all cells
        int[][] dist = new int[m][n];
        for (int i = 0; i < m; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }

        // Set the starting cell to 0
        dist[start[0]][start[1]] = 0;

        // Create a queue and enqueue the starting cell
        Queue<int[]> queue = new LinkedList<>();
        queue.add(start);

        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            for (int[] neighbor : getNeighbors(cell, m, n)) {
                if (neighbor[0] < 0 || neighbor[0] >= m || neighbor[1] < 0 || neighbor[1] >= n) continue;
                if (dist[neighbor[0]][neighbor[1]] <= dist[cell[0]][cell[1]] + 1) continue;

                // Update the distance and mark as visited
                dist[neighbor[0]][neighbor[1]] = dist[cell[0]][cell[1]] + 1;
                queue.add(neighbor);
            }
        }

        return dist[end[0]][end[1]];
    }

    private static int[][] getNeighbors(int[] cell, int m, int n) {
        List<int[]> neighbors = new ArrayList<>();
        if (cell[0] > 0) neighbors.add(new int[]{cell[0]-1, cell[1]});
        if (cell[0] < m-1) neighbors.add(new int[]{cell[0]+1, cell[1]});
        if (cell[1] > 0) neighbors.add(new int[]{cell[0], cell[1]-1});
        if (cell[1] < n-1) neighbors.add(new int[]{cell[0], cell[1]+1});

        return neighbors.toArray(new int[0][]);
    }
}
```

### Python
```python
def shortestXY(grid, start, end):
    m, n = len(grid), len(grid[0])

    # Create a distance matrix with infinity for all cells
    dist = [[float('inf')] * n for _ in range(m)]

    # Set the starting cell to 0
    dist[start[0]][start[1]] = 0

    # Create a queue and enqueue the starting cell
    queue = [start]
    while queue:
        cell = queue.pop(0)
        for neighbor in getNeighbors(cell, m, n):
            if 0 <= neighbor[0] < m and 0 <= neighbor[1] < n:
                if dist[neighbor[0]][neighbor[1]] <= dist[cell[0]][cell[1]] + 1: continue

                # Update the distance and mark as visited
                dist[neighbor[0]][neighbor[1]] = dist[cell[0]][cell[1]] + 1
                queue.append(neighbor)

    return dist[end[0]][end[1]]

def getNeighbors(cell, m, n):
    neighbors = []
    if cell[0] > 0: neighbors.append([cell[0]-1, cell[1]])
    if cell[0] < m-1: neighbors.append([cell[0]+1, cell[1]])
    if cell[1] > 0: neighbors.append([cell[0], cell[1]-1])
    if cell[1] < n-1: neighbors.append([cell[0], cell[1]+1])

    return neighbors
```

### C++
```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int shortestXY(vector<vector<int>>& grid, vector<int>& start, vector<int>& end) {
    int m = grid.size();
    int n = grid[0].size();

    // Create a distance matrix with infinity for all cells
    vector<vector<int>> dist(m, vector<int>(n));
    fill(dist[0].begin(), dist[0].end(), INT_MAX);
    dist[start[0]][start[1]] = 0;

    // Create a queue and enqueue the starting cell
    queue<pair<int, int>> q;
    q.push({start[0], start[1]});

    while (!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();

        for (auto& neighbor : getNeighbors({x, y}, m, n)) {
            if (neighbor.first < 0 || neighbor.first >= m || neighbor.second < 0 || neighbor.second >= n) continue;
            if (dist[neighbor.first][neighbor.second] <= dist[x][y] + 1) continue;

            // Update the distance and mark as visited
            dist[neighbor.first][neighbor.second] = dist[x][y] + 1;
            q.push({neighbor.first, neighbor.second});
        }
    }

    return dist[end[0]][end[1]];
}

vector<vector<int>> getNeighbors(vector<int>& cell, int m, int n) {
    vector<vector<int>> neighbors;
    if (cell[0] > 0) neighbors.push_back({cell[0]-1, cell[1]});
    if (cell[0] < m-1) neighbors.push_back({cell[0]+1, cell[1]});
    if (cell[1] > 0) neighbors.push_back({cell[0], cell[1]-1});
    if (cell[1] < n-1) neighbors.push_back({cell[0], cell[1]+1});

    return neighbors;
}
```

### JavaScript
```javascript
function shortestXY(grid, start, end) {
  const m = grid.length;
  const n = grid[0].length;

  // Create a distance matrix with infinity for all cells
  const dist = new Array(m).fill(0).map(() => new Array(n).fill(Number.MAX_SAFE_INTEGER));
  dist[start[0]][start[1]] = 0;

  // Create a queue and enqueue the starting cell
  const q = [[start[0], start[1]]];

  while (q.length) {
    const [x, y] = q.shift();

    for (const neighbor of getNeighbors([x, y], m, n)) {
      if (neighbor[0] < 0 || neighbor[0] >= m || neighbor[1] < 0 || neighbor[1] >= n) continue;
      if (dist[neighbor[0]][neighbor[1]] <= dist[x][y] + 1) continue;

      // Update the distance and mark as visited
      dist[neighbor[0]][neighbor[1]] = dist[x][y] + 1;
      q.push(neighbor);
    }
  }

  return dist[end[0]][end[1]];
}

function getNeighbors(cell, m, n) {
  const neighbors = [];
  if (cell[0] > 0) neighbors.push([cell[0]-1, cell[1]]);
  if (cell[0] < m-1) neighbors.push([cell[0]+1, cell[1]]);
  if (cell[1] > 0) neighbors.push([cell[0], cell[1]-1]);
  if (cell[1] < n-1) neighbors.push([cell[0], cell[1]+1]);

  return neighbors;
}
```

Note: The above code is for illustration purposes and may not be optimal or efficient in terms of time complexity.