---
id: "710278"
title: "LCP"
slug: "lcp--170637"
difficulty: "Medium"
companyTags: []
tags: ["Strings", "Sorting", "Data Structures", "Algorithms", "Trie"]
---

**LCP**
=====================================



## Summary
The LCP problem is about finding the Longest Common Prefix (LCP) between all strings in a given array. The problem involves using string manipulation and Trie data structure to solve it efficiently.

## Detailed Explanation
To solve this problem, we can use a Trie data structure to store all the strings in the array. Then, for each string in the array, we traverse the Trie from root to leaf, keeping track of the length of the common prefix at each node. This will give us the longest common prefix (LCP) between all strings.

Here's a step-by-step breakdown of the solution:

1. Create an empty Trie and insert all the strings in the array into it.
2. Initialize an empty string `lcp` to store the LCP.
3. Iterate through each string in the array:
	* For each string, traverse the Trie from root to leaf.
	* At each node, check if the character at that node is the same as the character in the current string. If it's not, break out of the loop and move on to the next string.
	* As you traverse the Trie, keep track of the length of the common prefix at each node.
4. Update `lcp` with the longest common prefix found so far.

The time complexity of this solution is O(N \* M), where N is the number of strings in the array and M is the average length of a string. The space complexity is O(M) for storing the Trie.

Here's an ASCII art diagram to illustrate the step-by-step process:

```
      +---------------+
      |  Root Node   |
      +---------------+
           |
           |
           v
      +---------------+
      |  Node 1 (a)    |
      +---------------+
           |
           |
           v
      +---------------+
      |  Node 2 (ab)   |
      +---------------+
           |
           |
           v
      +---------------+
      |  Leaf Node 3 (abc)|
      +---------------+
```

In this diagram, the Trie is represented as a tree with nodes labeled `a`, `ab`, and `abc`. The arrows represent the path taken by traversing the Trie from root to leaf.

## Optimized Solutions

### Java
```java
public class LCP {
    public static String longestCommonPrefix(String[] strs) {
        if (strs.length == 0) return "";
        
        StringBuilder lcp = new StringBuilder();
        int minLen = Integer.MAX_VALUE;
        for (String str : strs) {
            minLen = Math.min(minLen, str.length());
        }
        
        for (int i = 0; i < minLen; i++) {
            char c = strs[0].charAt(i);
            for (String str : strs) {
                if (str.charAt(i) != c) return lcp.toString();
            }
            lcp.append(c);
        }
        return lcp.toString();
    }
}
```

### Python
```python
def longest_common_prefix(strs):
    if not strs:
        return ""
    
    lcp = ""
    min_len = min(len(s) for s in strs)
    
    for i in range(min_len):
        c = strs[0][i]
        if all(s[i] == c for s in strs):
            lcp += c
        else:
            break
    return lcp
```

### C++
```cpp
class LCP {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if (strs.empty()) return "";
        
        string lcp = "";
        int minLen = INT_MAX;
        for (string str : strs) {
            minLen = min(minLen, str.length());
        }
        
        for (int i = 0; i < minLen; i++) {
            char c = strs[0][i];
            bool allMatch = true;
            for (string str : strs) {
                if (str[i] != c) {
                    allMatch = false;
                    break;
                }
            }
            if (!allMatch) return lcp;
            lcp += c;
        }
        return lcp;
    }
};
```

### JavaScript
```javascript
function longestCommonPrefix(strs) {
  if (strs.length === 0) return "";
  
  let lcp = "";
  let minLen = Math.max(...strs.map(s => s.length));
  
  for (let i = 0; i < minLen; i++) {
    let c = strs[0][i];
    let allMatch = true;
    for (let str of strs) {
      if (str[i] !== c) {
        allMatch = false;
        break;
      }
    }
    if (!allMatch) return lcp;
    lcp += c;
  }
  return lcp;
}
```

Note that the optimized solutions are provided in different programming languages, and they all use the same algorithmic approach described above.