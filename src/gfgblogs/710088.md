---
id: "710088"
title: "Assembly Line Scheduling"
slug: "assembly-line-scheduling"
difficulty: "Medium"
companyTags: []
tags: []
---

# Assembly Line Scheduling
## Slug: assembly-line-scheduling
## Difficulty: Medium
## Id: 710088
## Topic Tags: None
## Company Tags: None

### Summary
The Assembly Line Scheduling problem involves scheduling tasks on an assembly line to minimize the total time taken. Given a list of tasks with their respective processing times and dependencies, we need to find the optimal order in which these tasks should be performed to meet the deadlines while minimizing the overall processing time.

### Detailed Explanation
Let's break down the problem step by step:

1.  Initialize an empty queue `queue` and a priority queue `pq`.
2.  Iterate over each task `task` in the list of tasks.
3.  For each task, calculate its earliest start time `est` by iterating from the current time to the deadline and finding the latest point where it can be scheduled without violating any dependencies.
4.  Insert the task into the priority queue with a priority equal to its estimated start time.
5.  Once all tasks are inserted into the priority queue, pop tasks from the queue until it's empty.
6.  For each popped task `task`, calculate its actual start time `ast` by considering the earliest available time slot without violating any dependencies.
7.  Update the actual start time of dependent tasks by incrementing their actual start times by the processing time of the current task.
8.  Calculate the total processing time by summing up the processing times of all tasks.

Time Complexity: O(n log n), where `n` is the number of tasks.

Space Complexity: O(n), where `n` is the number of tasks.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class AssemblyLineScheduling {
    public static int minProcessingTime(int[] tasks, int[][] dependencies) {
        // Initialize queue and priority queue
        Queue<Integer> queue = new LinkedList<>();
        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> a.estimatedStartTime - b.estimatedStartTime);

        for (int task : tasks) {
            Job job = new Job(task);
            for (int dependency : dependencies) {
                if (job.id == dependency[0]) {
                    job.dependencies.add(dependency[1]);
                }
            }
            pq.offer(job);
        }

        int totalProcessingTime = 0;
        while (!pq.isEmpty()) {
            Job task = pq.poll();
            int actualStartTime = Math.max(0, task.estimatedStartTime - task.processingTime);
            totalProcessingTime += task.processingTime;

            for (int dependentTask : task.dependencies) {
                pq.peek().actualStartTime = Math.max(pq.peek().actualStartTime, actualStartTime + task.processingTime);
            }
        }

        return totalProcessingTime;
    }

    static class Job implements Comparable<Job> {
        int id;
        int processingTime;
        List<Integer> dependencies;
        int estimatedStartTime;
        int actualStartTime;

        Job(int id) {
            this.id = id;
            this.processingTime = id;
            this.dependencies = new ArrayList<>();
            this.estimatedStartTime = 0;
            this.actualStartTime = 0;
        }

        @Override
        public int compareTo(Job other) {
            return Integer.compare(this.estimatedStartTime, other.estimatedStartTime);
        }
    }
}
```

#### Python
```python
import heapq

def min_processing_time(tasks, dependencies):
    # Initialize queue and priority queue
    pq = [(task, 0) for task in tasks]
    heapq.heapify(pq)

    total_processing_time = 0
    while pq:
        task, est = heapq.heappop(pq)
        ast = max(0, est - task)
        total_processing_time += task

        for dependent_task in dependencies:
            if task == dependent_task[1]:
                dependent_task[0].estimated_start_time = max(dependent_task[0].estimated_start_time, ast + task)

    return total_processing_time
```

#### C++
```cpp
#include <queue>
#include <vector>

int minProcessingTime(int tasks[], int dependencies[][]) {
    // Initialize queue and priority queue
    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq;
    for (int task : tasks) {
        pq.push({task, 0});
    }

    int totalProcessingTime = 0;
    while (!pq.empty()) {
        int task, est;
        tie(task, est) = pq.top();
        pq.pop();

        int ast = std::max(0, est - task);
        totalProcessingTime += task;

        for (int dependentTask : dependencies) {
            if (task == dependentTask[1]) {
                dependentTask[0] = std::max(dependentTask[0], ast + task);
            }
        }
    }

    return totalProcessingTime;
}
```

#### JavaScript
```javascript
function minProcessingTime(tasks, dependencies) {
    // Initialize queue and priority queue
    const pq = tasks.map((task, index) => ({ task, estimatedStartTime: 0 }));
    pq.sort((a, b) => a.estimatedStartTime - b.estimatedStartTime);

    let totalProcessingTime = 0;
    while (pq.length > 0) {
        const task = pq.shift();
        const actualStartTime = Math.max(0, task.estimatedStartTime - task.task);
        totalProcessingTime += task.task;

        for (const dependentTask of dependencies) {
            if (task.task === dependentTask[1]) {
                dependentTask[0].estimated_start_time = Math.max(dependentTask[0].estimated_start_time, actualStartTime + task.task);
            }
        }
    }

    return totalProcessingTime;
}
```

Note: The above solutions are for illustration purposes only and might not be the most efficient or optimized solution.