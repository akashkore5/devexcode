---
id: "702680"
title: "Palindrome Array"
slug: "perfect-arrays4645"
difficulty: "Basic"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

**Palindromic Array**
=====================

### Summary
A palindrome array is an array where the first and last elements are the same, and the second and second-to-last elements are the same, and so on. In other words, the array reads the same when reversed. Given a list of integers as input, write a program to check if it forms a palindrome array or not.

### Detailed Explanation
To solve this problem, we can use a simple two-pointer approach. We initialize two pointers, one at the start of the array (i) and one at the end (j). We then compare the elements at these positions. If they are equal, we move both pointers towards the center of the array. If they are not equal, we return false as the array is not palindromic.

Here's a step-by-step breakdown of the solution:

1. Initialize two pointers i and j to 0 (start of the array) and length - 1 (end of the array), respectively.
2. Compare the elements at indices i and j. If they are equal, move both pointers towards the center of the array by incrementing i and decrementing j.
3. Repeat step 2 until either i exceeds j or the elements at indices i and j are not equal.
4. If the loop completes without finding any unequal pairs, return true as the array is palindromic.

Time complexity: O(n/2) = O(n), where n is the length of the array.

Space complexity: O(1), as we only use a few extra variables to store the pointers and do not allocate any additional space proportional to the input size.

### Optimized Solutions
Here are optimized solutions in different programming languages:

#### Java
```java
public boolean isPalindromeArray(int[] arr) {
    int i = 0, j = arr.length - 1;
    while (i < j) {
        if (arr[i] != arr[j]) return false;
        i++;
        j--;
    }
    return true;
}
```

#### Python
```python
def is_palindrome_array(arr):
    i = 0; j = len(arr) - 1
    while i < j:
        if arr[i] != arr[j]: return False
        i += 1; j -= 1
    return True
```

#### C++
```cpp
bool isPalindromeArray(int* arr, int n) {
    int i = 0, j = n - 1;
    while (i < j) {
        if (arr[i] != arr[j]) return false;
        i++;
        j--;
    }
    return true;
}
```

#### JavaScript
```javascript
function isPalindromeArray(arr) {
    let i = 0; let j = arr.length - 1;
    while (i < j) {
        if (arr[i] != arr[j]) return false;
        i++;
        j--;
    }
    return true;
}
```

These solutions all have the same time and space complexity as the original algorithm: O(n) time and O(1) space.