---
id: "880820"
title: "Delete Mid of a Stack"
slug: "delete-middle-element-of-a-stack--111318"
difficulty: "Easy"
companyTags: ["Amazon"]
tags: ["Recursion", "Stack", "STL", "Data Structures", "Algorithms"]
---

# Delete Mid of a Stack

## Summary
Delete mid of a stack problem involves deleting the middle element from a stack. The stack is represented as an array and elements are accessed in a last-in-first-out (LIFO) order.

## Detailed Explanation

To solve this problem, we can use recursion to delete the middle element. Here's a step-by-step breakdown of the solution:

1. Calculate the middle index of the stack by taking the length of the stack and dividing it by 2.
2. If the calculated index is out of bounds (i.e., less than 0 or greater than or equal to the length of the stack), return an error message or a special value indicating that there is no middle element.
3. Delete the element at the calculated index from the stack array.
4. Return the updated stack array.

Here's an example:

```
Stack: [1, 2, 3, 4, 5]
Middle Index: (length / 2) = 2
Delete Element at Index 2: [1, 2, 4, 5]
Updated Stack: [1, 2, 4, 5]
```

The time complexity of this solution is O(1), as we only need to calculate the middle index and delete an element. The space complexity is also O(1), as we are not using any additional space that scales with the input size.

## Optimized Solutions

### Java
```java
public static int[] deleteMid(int[] stack) {
    int n = stack.length;
    if (n <= 0) return new int[0];
    int midIndex = n / 2;
    if (midIndex < 0 || midIndex >= n) return stack; // no middle element
    int[] updatedStack = Arrays.copyOf(stack, n - 1);
    System.arraycopy(updatedStack, midIndex + 1, updatedStack, midIndex, n - midIndex - 1);
    return updatedStack;
}
```

### Python
```python
def delete_mid(stack):
    n = len(stack)
    if n <= 0:
        return []
    mid_index = n // 2
    if mid_index < 0 or mid_index >= n:
        return stack  # no middle element
    updated_stack = stack[:mid_index] + stack[mid_index+1:]
    return updated_stack
```

### C++
```cpp
#include <vector>

std::vector<int> deleteMid(std::vector<int>& stack) {
    int n = stack.size();
    if (n <= 0) return {};
    int midIndex = n / 2;
    if (midIndex < 0 || midIndex >= n) return stack; // no middle element
    std::vector<int> updatedStack(stack.begin(), stack.end());
    updatedStack.erase(updatedStack.begin() + midIndex);
    return updatedStack;
}
```

### JavaScript
```javascript
function deleteMid(stack) {
    let n = stack.length;
    if (n <= 0) return [];
    let midIndex = Math.floor(n / 2);
    if (midIndex < 0 || midIndex >= n) return stack; // no middle element
    let updatedStack = [...stack.slice(0, midIndex), ...stack.slice(midIndex + 1)];
    return updatedStack;
}
```

Note that the optimized solutions are not necessarily the most efficient way to solve this problem, but they demonstrate a recursive approach using the given tags.