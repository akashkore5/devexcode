---
id: "714218"
title: "Prefix Suffix String"
slug: "prefix-suffix-string--170647"
difficulty: "Medium"
companyTags: []
tags: ["Strings", "Trie", "Data Structures"]
---

**Prefix Suffix String**
=====================

## Summary
Given a string `S` and an integer `K`, find all substrings in `S` that have exactly `K` as their prefix and suffix. The problem involves strings, Trie data structure, and algorithmic thinking.

## Detailed Explanation
The approach to this problem is to construct a Trie using the characters of the input string. Then, traverse the Trie and for each node at level `K`, check if it has more than one child node (which means there's a suffix of length `K` present). If yes, then all substrings with prefix and suffix as the current character can be obtained by traversing down from that node.

Here is the step-by-step breakdown:

1. Construct a Trie using the characters of the input string.
2. Traverse the Trie and for each node at level `K`, check if it has more than one child node (which means there's a suffix of length `K` present).
3. If yes, then all substrings with prefix and suffix as the current character can be obtained by traversing down from that node.
4. For each node found in step 2, perform DFS to get all possible substrings.

Time complexity is O(N) where N is the length of the input string. Space complexity is also O(N) due to the Trie structure used.

## Optimized Solutions

### Java
```java
class Solution {
    public List<String> prefixSuffix(String S, int K) {
        TrieNode root = new TrieNode();
        for (char c : S.toCharArray()) {
            TrieNode node = root;
            for (int i = 0; i < K; i++) {
                if (!node.children.containsKey(c)) {
                    node.children.put(c, new TrieNode());
                }
                node = node.children.get(c);
            }
            node.isLeaf = true;
        }

        List<String> result = new ArrayList<>();
        for (Map.Entry<Character, TrieNode> entry : root.children.entrySet()) {
            if (entry.getValue().isLeaf) {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < K; i++) {
                    sb.append(entry.getKey());
                }
                result.add(sb.toString());
            }
        }

        return result;
    }
}

class TrieNode {
    Map<Character, TrieNode> children = new HashMap<>();
    boolean isLeaf;
}
```

### Python
```python
class Solution:
    def prefixSuffix(self, S: str, K: int) -> List[str]:
        root = {}
        for c in S:
            node = root
            for _ in range(K):
                if c not in node:
                    node[c] = {}
                node = node[c]
            node['#'] = True

        result = []
        for child in root.values():
            if '#' in child:
                sb = [c for c in range(K)]
                result.append(''.join(sb))

        return result
```

### C++
```cpp
class Solution {
public:
    vector<string> prefixSuffix(string S, int K) {
        TrieNode* root = new TrieNode();
        for (char c : S) {
            TrieNode* node = root;
            for (int i = 0; i < K; i++) {
                if (!node->children.count(c)) {
                    node->children[c] = new TrieNode();
                }
                node = node->children[c];
            }
            node->isLeaf = true;
        }

        vector<string> result;
        for (auto& child : root->children) {
            if (child.second.isLeaf) {
                string sb = "";
                for (int i = 0; i < K; i++) {
                    sb += static_cast<char>(child.first);
                }
                result.push_back(sb);
            }
        }

        return result;
    }
};

class TrieNode {
public:
    unordered_map<char, TrieNode*> children;
    bool isLeaf;
};
```

### JavaScript
```javascript
class Solution {
  prefixSuffix(S, K) {
    const root = {};
    for (const c of S) {
      let node = root;
      for (let i = 0; i < K; i++) {
        if (!node[c]) {
          node[c] = {};
        }
        node = node[c];
      }
      node['#'] = true;

      const result = [];
      for (const child in root) {
        if (root[child]['#']) {
          let sb = '';
          for (let i = 0; i < K; i++) {
            sb += c;
          }
          result.push(sb);
        }
      }

      return result;
    }
}
```

Note: These solutions assume that the input string does not contain any spaces or special characters.