---
id: "712214"
title: "Expression Add Operators"
slug: "expression-add-operators"
difficulty: "Hard"
companyTags: []
tags: ["Strings", "Recursion", "Backtracking", "Data Structures", "Algorithms"]
---

**Expression Add Operators**
=========================

### Slug: expression-add-operators
### Difficulty: Hard
### Id: 712214
### Topic Tags: Strings, Recursion, Backtracking, Data Structures, Algorithms
### Company Tags: None

## Summary
Given a string representation of an arithmetic expression, find all valid ways to add up operators (+) between the numbers to get the target sum. The input string will contain only digits and '+'.

## Detailed Explanation

The problem is about finding all possible combinations of adding operators between numbers in a given string to achieve a specific sum. This can be solved using backtracking and recursion.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty list `results` to store all valid combinations.
2. Define a recursive function `addOperators` that takes the input string, current sum, and the index of the current number as parameters.
3. Inside the `addOperators` function:
   - Iterate through the remaining characters in the input string starting from the current index.
   - For each character, check if it's a digit. If it is, append the corresponding number to the current sum and recursively call the `addOperators` function with the updated sum and the next index.
   - If the character is not a digit, it must be an operator. Check all possible combinations of adding operators between the current number and the next number (if any) to get the target sum.
   - For each valid combination, recursively call the `addOperators` function with the updated sum and the next index.
4. When the input string is fully processed or the target sum is reached, add the current combination to the `results` list.
5. Return the `results` list.

Time complexity: O(2^n \* n) where n is the length of the input string, as we're exploring all possible combinations.
Space complexity: O(n) for the recursive function call stack and the `results` list.

## Optimized Solutions

### Java
```java
import java.util.ArrayList;
import java.util.List;

public class ExpressionAddOperators {
    public List<String> addOperators(String num, int target) {
        List<String> results = new ArrayList<>();
        addOperators(num, 0, target, "", results);
        return results;
    }

    private void addOperators(String num, long currSum, int target, String expr, List<String> results) {
        if (currSum == target) {
            results.add(expr);
            return;
        }
        for (int i = 1; i <= num.length() - 3 && i + 3 <= num.length(); i++) {
            if (i > 1 && num.charAt(0) == '0') break;
            String subNum = num.substring(i, i + 3);
            long nextSum = currSum + Long.parseLong(subNum);
            if (nextSum == target) {
                results.add(expr + "+" + subNum);
                return;
            }
            addOperators(num.substring(i + 3), nextSum, target, expr + "+" + subNum, results);
        }
    }
}
```

### Python
```python
def addOperators(num, target):
    def add_operators(num, curr_sum, target, expr, results):
        if curr_sum == target:
            results.append(expr)
            return
        for i in range(1, len(num) - 2 + 1):
            sub_num = num[i:i+3]
            next_sum = curr_sum + int(sub_num)
            if next_sum == target:
                results.append(expr + "+" + sub_num)
                return
            add_operators(num[i+3:], next_sum, target, expr + "+" + sub_num, results)

    results = []
    add_operators(num, 0, target, "", results)
    return results
```

### C++
```cpp
#include <vector>
#include <string>

std::vector<std::string> expressionAddOperators(std::string num, int target) {
    std::vector<std::string> results;
    addOperators(num, 0, target, "", results);
    return results;
}

void addOperators(const std::string& num, long currSum, int target, const std::string& expr, std::vector<std::string>& results) {
    if (currSum == target) {
        results.push_back(expr);
        return;
    }
    for (int i = 1; i <= num.length() - 3 && i + 3 <= num.length(); i++) {
        if (i > 1 && num[0] == '0') break;
        std::string subNum = num.substr(i, 3);
        long nextSum = currSum + stol(subNum);
        if (nextSum == target) {
            results.push_back(expr + "+" + subNum);
            return;
        }
        addOperators(num.substr(i + 3), nextSum, target, expr + "+" + subNum, results);
    }
}
```

### JavaScript
```javascript
function expressionAddOperators(num, target) {
    function addOperators(num, currSum, target, expr, results) {
        if (currSum === target) {
            results.push(expr);
            return;
        }
        for (let i = 1; i <= num.length - 2 + 1; i++) {
            let subNum = num.slice(i, i + 3);
            let nextSum = currSum + parseInt(subNum);
            if (nextSum === target) {
                results.push(expr + "+" + subNum);
                return;
            }
            addOperators(num.slice(i + 3), nextSum, target, expr + "+" + subNum, results);
        }
    }

    const results = [];
    addOperators(num, 0, target, "", results);
    return results;
}
```

Note: The optimized solutions are provided in the respective programming languages.