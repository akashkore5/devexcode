---
id: "710294"
title: "Vertex Cover"
slug: "vertex-cover"
difficulty: "Hard"
companyTags: []
tags: []
---

# Vertex Cover

## Summary

The Vertex Cover problem is a classic algorithmic challenge that involves finding the smallest subset of vertices in an undirected graph, such that every edge in the graph has at least one vertex from this subset. This problem requires a deep understanding of graph theory and algorithm design.

## Detailed Explanation

Given an undirected graph G = (V, E), where V is the set of vertices and E is the set of edges, we need to find the smallest subset S ⊆ V such that every edge e ∈ E has at least one vertex from S. This subset S is called a Vertex Cover.

To solve this problem, we can use a greedy algorithm. The basic idea is to start with an empty set S and iteratively add vertices to S until all edges in the graph are covered. In each iteration, we choose the vertex that covers the most uncovered edges.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty set S.
2. For each edge e ∈ E:
   * Find the vertices v1 and v2 such that e = (v1, v2).
   * If both v1 and v2 are not in S, add the vertex that covers the most uncovered edges to S.
3. Return S as the Vertex Cover.

Time complexity analysis:

* The algorithm iterates over each edge in the graph once, resulting in a time complexity of O(|E|).
* For each edge, it performs a constant-time operation (finding the vertices and updating the set), so the overall time complexity is O(|E|).

Space complexity analysis:

* The algorithm uses a set S to store the Vertex Cover, which has a maximum size equal to the number of vertices in the graph. Therefore, the space complexity is O(|V|).

## Optimized Solutions

### Java
```java
import java.util.*;

public class VertexCover {
    public static List<Integer> findVertexCover(Graph graph) {
        List<Integer> vertexCover = new ArrayList<>();
        Set<Integer> uncoveredVertices = new HashSet<>(graph.getVertices());
        
        while (!uncoveredVertices.isEmpty()) {
            int maxCoverage = 0;
            int bestVertex = -1;
            
            for (int vertex : uncoveredVertices) {
                int coverage = 0;
                
                for (Integer neighbor : graph.getNeighbors(vertex)) {
                    if (!vertexCover.contains(neighbor)) {
                        coverage++;
                    }
                }
                
                if (coverage > maxCoverage) {
                    maxCoverage = coverage;
                    bestVertex = vertex;
                }
            }
            
            vertexCover.add(bestVertex);
            uncoveredVertices.remove(bestVertex);
        }
        
        return vertexCover;
    }

    public static class Graph {
        private Set<Integer> vertices;
        private Map<Integer, List<Integer>> neighbors;

        public Graph(Set<Integer> vertices, Map<Integer, List<Integer>> neighbors) {
            this.vertices = vertices;
            this.neighbors = neighbors;
        }

        public Set<Integer> getVertices() {
            return vertices;
        }

        public Map<Integer, List<Integer>> getNeighbors() {
            return neighbors;
        }
    }
}
```

### Python
```python
class VertexCover:
    def find_vertex_cover(self, graph):
        vertex_cover = []
        uncovered_vertices = set(graph.vertices)
        
        while uncovered_vertices:
            max_coverage = 0
            best_vertex = None
            
            for vertex in uncovered_vertices:
                coverage = 0
                
                for neighbor in graph.neighbors.get(vertex, []):
                    if neighbor not in vertex_cover:
                        coverage += 1
                
                if coverage > max_coverage:
                    max_coverage = coverage
                    best_vertex = vertex
                
            vertex_cover.append(best_vertex)
            uncovered_vertices.remove(best_vertex)
        
        return vertex_cover

class Graph:
    def __init__(self, vertices, neighbors):
        self.vertices = set(vertices)
        self.neighbors = {vertex: set(neighbors) for vertex in vertices}

    def get_vertices(self):
        return self.vertices

    def get_neighbors(self):
        return self.neighbors
```

### C++
```cpp
#include <iostream>
#include <unordered_set>
#include <unordered_map>

class VertexCover {
public:
    std::vector<int> findVertexCover(const Graph& graph) {
        std::vector<int> vertexCover;
        std::unordered_set<int> uncoveredVertices(graph.getVertices().begin(), graph.getVertices().end());
        
        while (!uncoveredVertices.empty()) {
            int maxCoverage = 0;
            int bestVertex = -1;
            
            for (const auto& vertex : uncoveredVertices) {
                int coverage = 0;
                
                for (const auto& neighbor : graph.getNeighborsAt(vertex)) {
                    if (std::find(vertexCover.begin(), vertexCover.end(), neighbor) == vertexCover.end()) {
                        coverage++;
                    }
                }
                
                if (coverage > maxCoverage) {
                    maxCoverage = coverage;
                    bestVertex = vertex;
                }
            }
            
            vertexCover.push_back(bestVertex);
            uncoveredVertices.erase(bestVertex);
        }
        
        return vertexCover;
    }
};

class Graph {
public:
    std::unordered_set<int> getVertices() const {
        return vertices_;
    }
    
    std::unordered_map<int, std::set<int>> getNeighbors() const {
        return neighbors_;
    }
    
private:
    std::unordered_set<int> vertices_;
    std::unordered_map<int, std::set<int>> neighbors_;
};

int main() {
    // Example usage
    Graph graph({1, 2, 3}, {{1, 2}, {2, 3}});
    VertexCover vertexCover;
    auto result = vertexCover.findVertexCover(graph);
    
    return 0;
}
```

### JavaScript
```javascript
class VertexCover {
  findVertexCover(graph) {
    const vertexCover = [];
    const uncoveredVertices = new Set(graph.vertices);

    while (uncoveredVertices.size > 0) {
      let maxCoverage = 0;
      let bestVertex = -1;

      for (const vertex of uncoveredVertices) {
        let coverage = 0;

        for (const neighbor of graph.neighbors.get(vertex, [])) {
          if (!vertexCover.includes(neighbor)) {
            coverage++;
          }
        }

        if (coverage > maxCoverage) {
          maxCoverage = coverage;
          bestVertex = vertex;
        }
      }

      vertexCover.push(bestVertex);
      uncoveredVertices.delete(bestVertex);
    }

    return vertexCover;
  }
}

class Graph {
  constructor(vertices, neighbors) {
    this.vertices = new Set(vertices);
    this.neighbors = new Map(Object.fromEntries(neighbors.map(([v1, v2]) => [v1, new Set([v2])])));

    this.getVertices = () => this.vertices;
    this.getNeighbors = () => this.neighbors;
  }
}

// Example usage
const graph = new Graph([1, 2, 3], [[1, 2], [2, 3]]);
const vertexCover = new VertexCover();
console.log(vertexCover.findVertexCover(graph));
```