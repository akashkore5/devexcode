---
id: "712111"
title: "Search in Rotated Array 2"
slug: "search-in-rotated-array-2"
difficulty: "Medium"
companyTags: []
tags: ["Binary Search", "Arrays", "Data Structures", "Algorithms"]
---

**Search in Rotated Array 2**
=====================

### Summary
The problem involves searching for an element in a rotated array. A rotated array is an array that has been shifted to the right by a certain number of positions, and then the first element of the rotated array becomes the last element of the original array. The goal is to write a function that takes the rotated array and the target element as input, and returns the index of the target element in the array.

### Detailed Explanation
The problem can be solved using binary search with some modifications to account for the rotation. Here's a step-by-step breakdown of the solution:

1. First, we need to find the pivot point of the rotated array. The pivot point is the point where the array was rotated. We can do this by comparing the first and last elements of the array. If they are in order (i.e., the first element is less than or equal to the last element), then the array has not been rotated, and we can perform a standard binary search.

2. If the array has been rotated, then we need to find the pivot point. We do this by comparing the middle element of the array with the first element. If the middle element is greater than the first element, then the pivot point is on the left side of the middle element. Otherwise, it's on the right side.

3. Once we have found the pivot point, we can perform a binary search on the appropriate half of the array (either the left or right half).

Here's some sample code in Python to illustrate this:
```
def search_rotated_array(arr, target):
    if arr[0] <= arr[-1]:
        return binary_search(arr, target)

    mid = len(arr) // 2
    if arr[mid] >= arr[0]:
        left_half = arr[:mid]
        right_half = arr[mid:]
    else:
        left_half = arr[mid:]
        right_half = arr[:mid]

    if target in left_half:
        return binary_search(left_half, target)
    else:
        return binary_search(right_half, target)

def binary_search(arr, target):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1  # not found
```
### Optimized Solutions

#### Java
```java
public int search(int[] nums, int target) {
    if (nums[0] <= nums[nums.length - 1]) {
        return binarySearch(nums, target);
    }

    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1; // not found
}

public int binarySearch(int[] nums, int target) {
    int low = 0;
    int high = nums.length - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return -1; // not found
}
```

#### Python
```python
def search(nums, target):
    if nums[0] <= nums[-1]:
        return binary_search(nums, target)

    left = 0
    right = len(nums) - 1

    while left <= right:
        mid = (left + right) // 2

        if nums[mid] == target:
            return mid
        elif nums[left] <= nums[mid]:
            if nums[left] <= target and target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target and target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1  # not found

def binary_search(nums, target):
    low = 0
    high = len(nums) - 1

    while low <= high:
        mid = (low + high) // 2

        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return -1  # not found
```

#### C++
```cpp
int search(int* nums, int len, int target) {
    if (nums[0] <= nums[len - 1]) {
        return binary_search(nums, len, target);
    }

    int left = 0;
    int right = len - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1; // not found
}

int binary_search(int* nums, int len, int target) {
    int low = 0;
    int high = len - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return -1; // not found
}
```

#### JavaScript
```javascript
function search(nums, target) {
    if (nums[0] <= nums[nums.length - 1]) {
        return binarySearch(nums, target);
    }

    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1; // not found
}

function binarySearch(nums, target) {
    let low = 0;
    let high = nums.length - 1;

    while (low <= high) {
        let mid = Math.floor((low + high) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return -1; // not found
}
```

This algorithm is designed to efficiently search for an element in a sorted array. It works by first determining whether the target element is within the left or right half of the array, and then recursively searching in that half until the target is found. The time complexity of this algorithm is O(log n), where n is the length of the input array.