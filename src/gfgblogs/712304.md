---
id: "712304"
title: "Delete all occurrences of a given key in a doubly linked list"
slug: "delete-all-occurrences-of-a-given-key-in-a-doubly-linked-list"
difficulty: "Medium"
companyTags: []
tags: ["doubly-linked-list"]
---

**Delete all occurrences of a given key in a doubly linked list**
=====================================================

### Summary
Delete all occurrences of a given key in a doubly linked list. The problem requires you to traverse the list and remove all nodes that have the specified key.

## Detailed Explanation
To solve this problem, we will use a simple traversal algorithm and remove each node that has the given key. We will start from one end of the list and move towards the other end, removing any nodes that match the target key.

Here is a step-by-step breakdown of the solution:

1.  Start at one end of the doubly linked list.
2.  Traverse the list until you reach the other end.
3.  For each node in the list:
    *   Check if the node's value matches the target key.
    *   If it does, remove the node from the list.

To remove a node from the list, we will need to update the `prev` and `next` pointers of its neighboring nodes.

Here is an ASCII art diagram representing the doubly linked list:
```
Node 1 <-> Node 2 <-> ... <-> Node N
```

Time complexity: O(n), where n is the number of nodes in the list. This is because we are traversing the entire list once and removing each node that matches the target key.

Space complexity: O(1), as we are only using a constant amount of space to store the current node and the target key.

## Optimized Solutions
### Java
```java
public void deleteKey(DoublyLinkedList list, int key) {
    Node current = list.head;
    while (current != null) {
        if (current.data == key) {
            removeNode(current);
        }
        current = current.next;
    }
}

private void removeNode(Node node) {
    if (node.prev != null) {
        node.prev.next = node.next;
    } else {
        list.head = node.next;
    }

    if (node.next != null) {
        node.next.prev = node.prev;
    } else {
        list.tail = node.prev;
    }
}
```

### Python
```python
def delete_key(self, key):
    current = self.head
    while current:
        if current.data == key:
            self.remove_node(current)
        current = current.next

def remove_node(self, node):
    if node.prev:
        node.prev.next = node.next
    else:
        self.head = node.next

    if node.next:
        node.next.prev = node.prev
    else:
        self.tail = node.prev
```

### C++
```cpp
void deleteKey(DoublyLinkedList* list, int key) {
    Node* current = list->head;
    while (current != nullptr) {
        if (current->data == key) {
            removeNode(current);
        }
        current = current->next;
    }
}

void removeNode(Node* node) {
    if (node->prev != nullptr) {
        node->prev->next = node->next;
    } else {
        list->head = node->next;
    }

    if (node->next != nullptr) {
        node->next->prev = node->prev;
    } else {
        list->tail = node->prev;
    }
}
```

### JavaScript
```javascript
deleteKey(list, key) {
  let current = list.head;
  while (current) {
    if (current.data === key) {
      removeNode(current);
    }
    current = current.next;
  }
}

removeNode(node) {
  if (node.prev) {
    node.prev.next = node.next;
  } else {
    list.head = node.next;
  }

  if (node.next) {
    node.next.prev = node.prev;
  } else {
    list.tail = node.prev;
  }
}
```

In each of the above solutions, we start by initializing a `current` variable to point to the head of the list. We then enter a loop that continues until we have traversed the entire list.

 Inside the loop, we check if the current node's data matches the target key. If it does, we call the `removeNode` function to remove the node from the list.

The `removeNode` function updates the `prev` and `next` pointers of the neighboring nodes to effectively "delete" the node from the list.