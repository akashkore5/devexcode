---
id: "713539"
title: "Minimum repeat to make substring"
slug: "minimum-times-a-has-to-be-repeated-such-that-b-is-a-substring-of-it--170645"
difficulty: "Medium"
companyTags: ["Google"]
tags: ["Searching", "Strings", "Pattern Searching", "Data Structures", "Algorithms"]
---

**Minimum Repeat to Make Substring**
==================================

## Summary
The problem is to find the minimum number of times a string has to be repeated such that another given string becomes a substring of it. This problem involves pattern searching and manipulation of strings, which are key concepts in computer science.

## Detailed Explanation
To solve this problem, we can start by considering the simplest case where the repeat count is 1. In this case, the first string must contain the second string as a substring. If the repeat count is more than 1, we need to consider repeating the first string multiple times until it contains the second string.

Here's a step-by-step approach to solve this problem:

1. Initialize a variable `repeatCount` to 1.
2. Repeat the first string `repeatCount` times and concatenate the repeated strings together.
3. Check if the concatenated string contains the second string as a substring. If it does, return `repeatCount`.
4. Increment `repeatCount` by 1 and repeat steps 2-3 until the concatenated string contains the second string as a substring.

The time complexity of this approach is O(n), where n is the length of the first string. The space complexity is also O(n) due to the repeated strings.

Here's an ASCII art diagram illustrating the repetition process:
```
a -> aa
aa -> aaa
aaa -> aaaa
...
```

## Optimized Solutions

### Java
```java
public int minRepeatTimes(String s1, String s2) {
    int repeatCount = 1;
    while (!s1.repeat(repeatCount).contains(s2)) {
        repeatCount++;
    }
    return repeatCount;
}
```

### Python
```python
def min_repeat_times(s1, s2):
    repeat_count = 1
    while not (s1 * repeat_count).find(s2) != -1:
        repeat_count += 1
    return repeat_count
```

### C++
```cpp
int minRepeatTimes(const std::string& s1, const std::string& s2) {
    int repeatCount = 1;
    while (!std::string(s1).repeat(repeatCount).find(s2) != std::string::npos) {
        repeatCount++;
    }
    return repeatCount;
}
```

### JavaScript
```javascript
function minRepeatTimes(s1, s2) {
    let repeatCount = 1;
    while (!((s1.repeat(repeatCount)).includes(s2))) {
        repeatCount++;
    }
    return repeatCount;
}
```
Note that these optimized solutions assume the existence of a `repeat` method in Java and Python, which repeats a string by a given number of times. In C++ and JavaScript, we use the `std::string` class's `repeat` method and the `includes` method, respectively.