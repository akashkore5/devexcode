---
id: "700045"
title: "Rearrange a linked list"
slug: "rearrange-a-linked-list"
difficulty: "Medium"
companyTags: ["Amazon", "Microsoft"]
tags: ["Linked List", "Data Structures"]
---

# Rearrange a Linked List
## Slug: rearrange-a-linked-list
## Difficulty: Medium
## Id: 700045
## Topic Tags: Linked List, Data Structures
## Company Tags: Amazon, Microsoft

### Summary
Given a linked list and an integer k, we need to reorder the nodes in the link list such that all nodes with indices divisible by k are moved to the beginning of the linked list followed by all nodes with indices not divisible by k. The problem is similar to the "Rotate Linked List" problem where we need to rotate the linked list by a certain number of steps.

### Detailed Explanation
The algorithm for this problem involves two main steps: 
1. First, calculate the length of the linked list and the new position of each node.
2. Second, rearrange the nodes in the linked list based on their indices.

Here is a step-by-step breakdown:

1. Calculate the length of the linked list (n).
2. Initialize three pointers: prev, curr, next.
3. Traverse the linked list starting from the head and keep track of the number of steps taken (i).
4. If i is divisible by k, set the prev pointer to the current node and continue with the next step.
5. Otherwise, increment the length counter for nodes not divisible by k.
6. Repeat steps 3-5 until the end of the linked list.
7. Initialize a new head and traverse the linked list again, this time based on the calculated positions.
8. If prev is null, set the new head to the current node and continue with the next step.
9. Otherwise, increment the length counter for nodes not divisible by k.
10. Repeat steps 3-5 until the end of the linked list.

The time complexity of this algorithm is O(n) where n is the number of nodes in the linked list. The space complexity is O(1) as we only use a constant amount of space to store the pointers and indices.

### Optimized Solutions

#### Java
```java
public class Solution {
    public void reorderList(ListNode head, int k) {
        int n = 0;
        ListNode curr = head;
        while (curr != null) {
            n++;
            curr = curr.next;
        }
        
        int pos = 0;
        ListNode prev = null;
        ListNode curr1 = head;
        while (pos < n) {
            if (pos % k == 0) {
                prev = curr1;
            } else {
                curr1 = curr1.next;
            }
            pos++;
        }
        
        ListNode newHead = null;
        ListNode curr2 = head;
        int count = 0;
        while (curr2 != null) {
            if (count % k == 0 || count >= n) {
                newHead = curr2;
            } else {
                if (newHead == null) {
                    newHead = curr2;
                } else {
                    ListNode temp = newHead;
                    while (temp.next != null) {
                        temp = temp.next;
                    }
                    temp.next = curr2;
                }
            }
            curr2 = curr2.next;
            count++;
        }
    }
}
```

#### Python
```python
class Solution:
    def reorderList(self, head: ListNode, k: int) -> None:
        n = 0
        curr = head
        while curr is not None:
            n += 1
            curr = curr.next
        
        pos = 0
        prev = None
        curr1 = head
        while pos < n:
            if pos % k == 0:
                prev = curr1
            else:
                curr1 = curr1.next
            pos += 1
        
        newHead = None
        curr2 = head
        count = 0
        while curr2 is not None:
            if count % k == 0 or count >= n:
                newHead = curr2
            elif newHead is None:
                newHead = curr2
            else:
                temp = newHead
                while temp.next is not None:
                    temp = temp.next
                temp.next = curr2
            curr2 = curr2.next
            count += 1
```

#### C++
```cpp
class Solution {
public:
    void reorderList(ListNode* head, int k) {
        int n = 0;
        ListNode* curr = head;
        while (curr != NULL) {
            n++;
            curr = curr->next;
        }
        
        int pos = 0;
        ListNode* prev = NULL;
        ListNode* curr1 = head;
        while (pos < n) {
            if (pos % k == 0) {
                prev = curr1;
            } else {
                curr1 = curr1->next;
            }
            pos++;
        }
        
        ListNode* newHead = NULL;
        ListNode* curr2 = head;
        int count = 0;
        while (curr2 != NULL) {
            if (count % k == 0 || count >= n) {
                newHead = curr2;
            } else {
                if (newHead == NULL) {
                    newHead = curr2;
                } else {
                    ListNode* temp = newHead;
                    while (temp->next != NULL) {
                        temp = temp->next;
                    }
                    temp->next = curr2;
                }
            }
            curr2 = curr2->next;
            count++;
        }
    }
};
```

#### JavaScript
```javascript
class Solution {
  reorderList(head, k) {
    let n = 0;
    let curr = head;
    while (curr) {
      n++;
      curr = curr.next;
    }
    
    let pos = 0;
    let prev = null;
    let curr1 = head;
    while (pos < n) {
      if (pos % k == 0) {
        prev = curr1;
      } else {
        curr1 = curr1.next;
      }
      pos++;
    }
    
    let newHead = null;
    let curr2 = head;
    let count = 0;
    while (curr2) {
      if (count % k == 0 || count >= n) {
        newHead = curr2;
      } else {
        if (!newHead) {
          newHead = curr2;
        } else {
          let temp = newHead;
          while (temp.next) {
            temp = temp.next;
          }
          temp.next = curr2;
        }
      }
      curr2 = curr2.next;
      count++;
    }
  }
}
```