---
id: "716016"
title: "Fraction pairs with sum 1"
slug: "fraction-pairs-with-sum-1"
difficulty: "Medium"
companyTags: ["Microsoft"]
tags: ["Mathematical", "Map"]
---

# Fraction Pairs with Sum 1

## Slug: fraction-pairs-with-sum-1
## Difficulty: Medium
## Id: 716016
## Topic Tags: Mathematical, Map
## Company Tags: Microsoft

### Summary

Given a list of fractions in the form [numerator/denominator], find all unique pairs of fractions that add up to 1. The problem is about finding fraction pairs with sum 1 and involves mathematical concepts like fractions and mapping.

### Detailed Explanation

To solve this problem, we can iterate through the list of fractions, considering each pair as a potential solution. We'll keep track of the fractions we've seen so far using a HashMap to store the denominators as keys and their corresponding numerators as values.

Here's the step-by-step breakdown:

1. Initialize an empty HashMap `fractionMap` to store the fractions.
2. Iterate through the list of fractions:
   - For each fraction, extract the numerator and denominator.
   - Calculate the reciprocal of the current fraction (i.e., swap the numerator and denominator).
   - Check if the reciprocal is already in the `fractionMap`. If it is, that means we've found a pair of fractions that add up to 1. Add this pair to our result set.
3. After iterating through all the fractions, return the result set containing all unique pairs of fractions with sum 1.

Time complexity: O(n), where n is the number of fractions in the list.
Space complexity: O(n), as we need to store the fractions and their denominators in the HashMap.

### Optimized Solutions

#### Java
```java
import java.util.*;

public class FractionPairs {
    public static List<List<Integer>> fractionPairs(int[][] fractions) {
        Map<Integer, Integer> fractionMap = new HashMap<>();
        Set<List<Integer>> result = new HashSet<>();

        for (int[] fraction : fractions) {
            int numerator = fraction[0];
            int denominator = fraction[1];

            int reciprocalNumerator = denominator;
            int reciprocalDenominator = numerator;

            if (!fractionMap.containsKey(reciprocalDenominator)) {
                fractionMap.put(reciprocalDenominator, reciprocalNumerator);
            } else {
                result.add(Arrays.asList(fraction[0], fraction[1], fractionMap.get(reciprocalDenominator), reciprocalDenominator));
            }
        }

        return new ArrayList<>(result);
    }
}
```

#### Python
```python
def fraction_pairs(fractions):
    fraction_map = {}
    result = set()

    for fraction in fractions:
        numerator, denominator = fraction
        reciprocal_numerator = denominator
        reciprocal_denominator = numerator

        if reciprocal_denominator not in fraction_map:
            fraction_map[reciprocal_denominator] = reciprocal_numerator
        else:
            result.add(tuple(sorted([numerator, denominator, *fraction_map[reciprocal_denominator]])))

    return [list(pair) for pair in result]
```

#### C++
```cpp
#include <iostream>
#include <map>
#include <vector>
#include <set>

std::vector<std::vector<int>> fractionPairs(std::vector<std::vector<int>>& fractions) {
    std::map<int, int> fractionMap;
    std::set<std::vector<int>> result;

    for (const auto& fraction : fractions) {
        int numerator = fraction[0];
        int denominator = fraction[1];

        int reciprocalNumerator = denominator;
        int reciprocalDenominator = numerator;

        if (!fractionMap.count(reciprocalDenominator)) {
            fractionMap[reciprocalDenominator] = reciprocalNumerator;
        } else {
            result.insert({numerator, denominator, fractionMap[reciprocalDenominator], reciprocalDenominator});
        }
    }

    return std::vector<std::vector<int>>(result.begin(), result.end());
}
```

#### JavaScript
```javascript
function fractionPairs(fractions) {
    const fractionMap = new Map();
    let result = new Set();

    for (const fraction of fractions) {
        const [numerator, denominator] = fraction;
        const reciprocalNumerator = denominator;
        const reciprocalDenominator = numerator;

        if (!fractionMap.has(reciprocalDenominator)) {
            fractionMap.set(reciprocalDenominator, reciprocalNumerator);
        } else {
            result.add([...new Set([numerator, denominator, ...fractionMap.get(reciprocalDenominator)])]);
        }
    }

    return [...result].map((pair) => pair.slice());
}
```

Note that the optimized solutions for each language are similar in structure, with slight variations depending on the specific language syntax and features.