---
id: "702811"
title: "Mr Modulo and Pairs"
slug: "mr-modulo-and-pairs5610"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Modular Arithmetic", "Data Structures", "Algorithms"]
---

**Mr Modulo and Pairs**
=====================

**Slug:** mr-modulo-and-pairs5610
**Difficulty:** Medium
**Id:** 702811
**Topic Tags:** Arrays, Modular Arithmetic, Data Structures, Algorithms
**Company Tags:** None

## Summary
Given a sorted array of integers, write an algorithm to find all pairs that have a remainder of 'k' when divided by 'm'. The pairs should be in non-decreasing order.

This problem involves arrays and modular arithmetic. We can use a two-pointer approach to solve this problem efficiently.

## Detailed Explanation
To solve this problem, we can use the two-pointer technique. Initialize two pointers, one at the start of the array (i) and one at the end of the array (j). Calculate the remainder of the pair i and j when divided by 'm'. If it's equal to 'k', add the pair to our result list.

If the remainder is less than 'k', increment the first pointer. This will make the remainder greater, which may become equal to 'k' in future iterations. If the remainder is greater than 'k', decrement the second pointer. This will make the remainder smaller, which may become equal to 'k' in future iterations.

Here's a step-by-step breakdown of the solution:

1. Initialize two pointers i and j at the start and end of the array respectively.
2. Calculate the remainder of the pair i and j when divided by 'm'. If it's equal to 'k', add the pair to our result list.
3. If the remainder is less than 'k', increment the first pointer (i). This will make the remainder greater, which may become equal to 'k' in future iterations.
4. If the remainder is greater than 'k', decrement the second pointer (j). This will make the remainder smaller, which may become equal to 'k' in future iterations.
5. Continue this process until i and j meet or cross each other.

Time complexity: O(n), where n is the length of the array. We are traversing the array once from both ends.

Space complexity: O(1), as we are not using any extra space apart from a few variables.

## Optimized Solutions

### Java
```java
import java.util.ArrayList;
import java.util.List;

public List<int[]> findPairs(int[] arr, int m, int k) {
    List<int[]> result = new ArrayList<>();
    int i = 0, j = arr.length - 1;
    
    while (i <= j) {
        int remainder = (arr[i] + arr[j]) % m;
        
        if (remainder == k) {
            result.add(new int[]{arr[i], arr[j]});
            i++;
            j--;
        } else if (remainder < k) {
            i++;
        } else {
            j--;
        }
    }
    
    return result;
}
```

### Python
```python
def find_pairs(arr, m, k):
    result = []
    i = 0; j = len(arr) - 1
    
    while i <= j:
        remainder = (arr[i] + arr[j]) % m
        
        if remainder == k:
            result.append([arr[i], arr[j]])
            i += 1
            j -= 1
        elif remainder < k:
            i += 1
        else:
            j -= 1
    
    return result
```

### C++
```cpp
#include <vector>
#include <algorithm>

std::vector<std::vector<int>> findPairs(std::vector<int>& arr, int m, int k) {
    std::vector<std::vector<int>> result;
    int i = 0, j = arr.size() - 1;
    
    while (i <= j) {
        int remainder = (arr[i] + arr[j]) % m;
        
        if (remainder == k) {
            result.push_back({arr[i], arr[j]});
            i++;
            j--;
        } else if (remainder < k) {
            i++;
        } else {
            j--;
        }
    }
    
    return result;
}
```

### JavaScript
```javascript
function findPairs(arr, m, k) {
    let result = [];
    let i = 0; let j = arr.length - 1;
    
    while (i <= j) {
        let remainder = (arr[i] + arr[j]) % m;
        
        if (remainder == k) {
            result.push([arr[i], arr[j]]);
            i++;
            j--;
        } else if (remainder < k) {
            i++;
        } else {
            j--;
        }
    }
    
    return result;
}
```