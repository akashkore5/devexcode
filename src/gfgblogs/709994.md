---
id: "709994"
title: "Insert an Element at the Bottom of a Stack"
slug: "insert-an-element-at-the-bottom-of-a-stack"
difficulty: "Easy"
companyTags: []
tags: ["Recursion", "Stack", "implementation", "Data Structures", "Algorithms"]
---

# Insert an Element at the Bottom of a Stack
## Slug: insert-an-element-at-the-bottom-of-a-stack
## Difficulty: Easy
## Id: 709994
## Topic Tags: Recursion, Stack, implementation, Data Structures, Algorithms
## Company Tags: None

## Summary
The problem is about implementing a stack data structure and inserting an element at the bottom of the stack. This requires manipulating the existing elements in the stack to make room for the new element, which involves recursive operations.

## Detailed Explanation
To solve this problem, we will implement a stack using a linked list, where each node represents an element in the stack. We will create a function `pushBottom` that takes the new element as input and inserts it at the bottom of the stack.

Here's the step-by-step breakdown:

1.  Start with the current top element of the stack.
2.  If the stack is empty (i.e., there are no elements), simply push the new element to become the first element in the stack.
3.  Otherwise, recursively call `pushBottom` on the next element until you reach the bottom of the stack.
4.  At the bottom of the stack, insert the new element and return.

Here's an ASCII art diagram representing the stack:
```
  +---------------+
  |   Top Element  |
  +---------------+
  |   ...          |
  +---------------+
  |   Bottom      |
  +---------------+
```

When inserting a new element at the bottom, it will look like this:
```
  +---------------+
  |   New Element  |
  +---------------+
  |   Top Element  |
  +---------------+
  |   ...          |
  +---------------+
  |   Old Bottom    |
  +---------------+
```

Time complexity: O(n), where n is the number of elements in the stack, as we need to traverse the entire stack to insert a new element at the bottom.
Space complexity: O(1), as we are only using a constant amount of space to store the new element.

## Optimized Solutions

### Java
```java
public class Stack {
    public void pushBottom(int x) {
        Node newNode = new Node(x);
        if (isEmpty()) {
            firstElement = newNode;
        } else {
            pushBottomHelper(firstElement, newNode);
        }
    }

    private void pushBottomHelper(Node current, Node newNode) {
        if (current.next == null) {
            current.next = newNode;
        } else {
            pushBottomHelper(current.next, newNode);
        }
    }
}
```

### Python
```python
class Stack:
    def __init__(self):
        self.top = None

    def push_bottom(self, x):
        new_node = Node(x)
        if not self.top:
            self.top = new_node
        else:
            self.push_bottom_helper(self.top, new_node)

    def push_bottom_helper(self, current, new_node):
        if not current.next:
            current.next = new_node
        else:
            self.push_bottom_helper(current.next, new_node)
```

### C++
```cpp
class Stack {
public:
    void pushBottom(int x) {
        Node* newNode = new Node(x);
        if (isEmpty()) {
            firstElement = newNode;
        } else {
            pushBottomHelper(firstElement, newNode);
        }
    }

    private:
    void pushBottomHelper(Node* current, Node* newNode) {
        if (current->next == nullptr) {
            current->next = newNode;
        } else {
            pushBottomHelper(current->next, newNode);
        }
    }
};
```

### JavaScript
```javascript
class Stack {
  constructor() {
    this.top = null;
  }

  pushBottom(x) {
    const newNode = { value: x, next: null };
    if (!this.top) {
      this.top = newNode;
    } else {
      this.pushBottomHelper(this.top, newNode);
    }
  }

  pushBottomHelper(current, new_node) {
    if (!current.next) {
      current.next = new_node;
    } else {
      this.pushBottomHelper(current.next, new_node);
    }
  }
}
```

Note that these optimized solutions are based on the problem description and tags provided. The actual implementation may vary depending on the specific requirements of your project or application.