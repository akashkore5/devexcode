---
id: "715966"
title: "Geekina Hate 1s"
slug: "geekina-hate-1s"
difficulty: "Hard"
companyTags: []
tags: ["Binary Search", "Bit Magic"]
---

**Geekina Hate 1s**
==================

### Summary
The problem is about finding all numbers in a given array that have an odd number of 1's in their binary representation. This requires a combination of binary search and bit manipulation techniques.

### Detailed Explanation
The key to this problem is understanding how to efficiently count the number of 1's in each number's binary representation. This can be done using bitwise operations, specifically the XOR operator (`^`). We'll use this technique to create a function that counts the number of 1's in a given integer.

Here's the step-by-step solution:

1. Initialize an empty list `result` to store the numbers with an odd number of 1's.
2. Iterate through each number `num` in the input array.
3. Use bitwise operations to count the number of 1's in `num`. This can be done by XORing `num` with itself, effectively canceling out all the bits that are not set (i.e., 0).
	```markdown
	num ^= num;
	while (num) {
		if ((num & 1) == 1) {
			num >>= 1;
		} else {
			break;
		}
	}
	count = num;
	```
4. Use binary search to find the first number in the input array that has an odd `count` of 1's. This is done by iterating through the array and checking each element's count.
5. Once we've found a number with an odd count, add it to the `result` list.
6. Continue this process until we've processed all numbers in the input array.
7. Return the `result` list.

Time complexity: O(n log n) due to the binary search
Space complexity: O(1) since we're only using a constant amount of space

### Optimized Solutions
#### Java
```java
import java.util.*;

public class GeekinaHate1s {
    public static List<Integer> geekinaHate1s(int[] arr) {
        List<Integer> result = new ArrayList<>();
        for (int num : arr) {
            int count = 0;
            num ^= num;
            while (num) {
                if ((num & 1) == 1) {
                    num >>= 1;
                } else {
                    break;
                }
            }
            if (count % 2 != 0) {
                result.add(num);
            }
        }
        return result;
    }
}
```
#### Python
```python
def geekina_hate_1s(arr):
    result = []
    for num in arr:
        count = 0
        while num:
            if (num & 1) == 1:
                num >>= 1
            else:
                break
            count += 1
        if count % 2 != 0:
            result.append(num)
    return result
```
#### C++
```cpp
#include <vector>
#include <algorithm>

std::vector<int> geekinaHate1s(int* arr, int n) {
    std::vector<int> result;
    for (int i = 0; i < n; i++) {
        int count = 0;
        int num = arr[i];
        while (num) {
            if ((num & 1) == 1) {
                num >>= 1;
            } else {
                break;
            }
        }
        if (count % 2 != 0) {
            result.push_back(num);
        }
    }
    return result;
}
```
#### JavaScript
```javascript
function geekinaHate1s(arr) {
    let result = [];
    for (let num of arr) {
        let count = 0;
        while (num) {
            if ((num & 1) == 1) {
                num >>= 1;
            } else {
                break;
            }
        }
        if (count % 2 !== 0) {
            result.push(num);
        }
    }
    return result;
}
```