---
id: "703845"
title: "Sub-arrays with equal number of occurences"
slug: "sub-arrays-with-equal-number-of-occurences3901"
difficulty: "Hard"
companyTags: []
tags: ["Arrays", "STL", "Data Structures"]
---

**Sub-arrays with equal number of occurrences**
==================================================

## Summary
The problem involves finding all sub-arrays in a given array that have an equal number of occurrences. This means, for each pair of elements in the array, you need to find all sub-arrays where these two elements appear equally many times.

## Detailed Explanation
To solve this problem, we can use a combination of frequency arrays and sliding window techniques. Here's a step-by-step breakdown:

1. Initialize an empty hash map `freqMap` to store the frequency of each element in the array.
2. Iterate through the array using two pointers, `start` and `end`, which represent the start and end indices of the current sub-array.
3. For each element at index `i`, increment its count in `freqMap`.
4. Calculate the frequency of the current sub-array by subtracting the counts of elements to the left of `start` from the total count.
5. If the frequency is equal to 0, it means all elements up to this point have been seen equally many times. Update the result with the current sub-array.
6. Slide the window by incrementing `end` and decrementing `start` until `end` reaches the end of the array.
7. Repeat steps 3-6 for each element in the array.

Time complexity: O(n^2), where n is the length of the array, because we're iterating through the array with two pointers.
Space complexity: O(n), as we need to store the frequency map and result arrays.

## Optimized Solutions
Here are optimized solutions in various languages:

### Java
```java
import java.util.HashMap;
import java.util.Map;

public class SubArray {
    public static void findSubArrays(int[] arr) {
        Map<Integer, Integer> freqMap = new HashMap<>();
        int start = 0, end = 0, maxFreq = 0, minFreq = Integer.MAX_VALUE;
        boolean equalCount = false;

        while (end < arr.length) {
            int currElement = arr[end];
            freqMap.put(currElement, freqMap.getOrDefault(currElement, 0) + 1);
            if (freqMap.get(currElement) == 0) {
                maxFreq = Math.max(maxFreq, end - start + 1);
                minFreq = Math.min(minFreq, end - start + 1);
                equalCount = maxFreq == minFreq;
            }
            while (!equalCount && freqMap.get(arr[start]) > 0) {
                freqMap.put(arr[start], freqMap.get(arr[start]) - 1);
                start++;
            }
            if (equalCount) {
                System.out.println("Sub-array from index " + start + " to " + end + ":");
                for (int i = start; i <= end; i++) {
                    System.out.print(arr[i] + " ");
                }
                System.out.println();
            }
            end++;
        }
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        findSubArrays(arr);
    }
}
```

### Python
```python
def find_subarrays(arr):
    freq_map = {}
    start = end = max_freq = min_freq = 0
    equal_count = False

    for i in range(len(arr)):
        curr_element = arr[i]
        if curr_element not in freq_map:
            freq_map[curr_element] = 1
        else:
            freq_map[curr_element] += 1

        if freq_map[curr_element] == 0:
            max_freq = max(max_freq, end - start + 1)
            min_freq = min(min_freq, end - start + 1)
            equal_count = max_freq == min_freq

        while not equal_count and arr[start] in freq_map and freq_map[arr[start]] > 0:
            freq_map[arr[start]] -= 1
            start += 1

        if equal_count:
            print(f"Sub-array from index {start} to {end}:")
            for j in range(start, end + 1):
                print(arr[j], end=" ")
            print()

    return

# Example usage
arr = [1, 2, 3, 4, 5]
find_subarrays(arr)
```

### C++
```cpp
#include <iostream>
#include <unordered_map>

void findSubArrays(int* arr, int n) {
    std::unordered_map<int, int> freqMap;
    int start = 0, end = 0, maxFreq = 0, minFreq = INT_MAX;
    bool equalCount = false;

    for (int i = 0; i < n; i++) {
        int currElement = arr[i];
        if (freqMap.find(currElement) == freqMap.end()) {
            freqMap[currElement] = 1;
        } else {
            freqMap[currElement]++;
        }

        if (freqMap[currElement] == 0) {
            maxFreq = std::max(maxFreq, end - start + 1);
            minFreq = std::min(minFreq, end - start + 1);
            equalCount = maxFreq == minFreq;
        }

        while (!equalCount && freqMap.find(arr[start]) != freqMap.end() && freqMap[arr[start]] > 0) {
            freqMap[arr[start]]--;
            start++;
        }

        if (equalCount) {
            std::cout << "Sub-array from index " << start << " to " << end << ":" << std::endl;
            for (int j = start; j <= end; j++) {
                std::cout << arr[j] << " ";
            }
            std::cout << std::endl;
        }
    }

    return;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    findSubArrays(arr, n);
    return 0;
}
```

### JavaScript
```javascript
function findSubArrays(arr) {
    const freqMap = new Map();
    let start = 0, end = 0, maxFreq = 0, minFreq = Infinity;
    let equalCount = false;

    for (let i = 0; i < arr.length; i++) {
        const currElement = arr[i];
        if (!freqMap.has(currElement)) {
            freqMap.set(currElement, 1);
        } else {
            freqMap.set(currElement, freqMap.get(currElement) + 1);
        }

        if (freqMap.get(currElement) === 0) {
            maxFreq = Math.max(maxFreq, end - start + 1);
            minFreq = Math.min(minFreq, end - start + 1);
            equalCount = maxFreq === minFreq;
        }

        while (!equalCount && freqMap.has(arr[start]) && freqMap.get(arr[start]) > 0) {
            freqMap.set(arr[start], freqMap.get(arr[start]) - 1);
            start++;
        }

        if (equalCount) {
            console.log(`Sub-array from index ${start} to ${end}:`);
            for (let j = start; j <= end; j++) {
                console.log(arr[j] + " ");
            }
            console.log();
        }
    }

    return;
}

// Example usage
const arr = [1, 2, 3, 4, 5];
findSubArrays(arr);
```

Note: These solutions assume that the input array is not null or empty. You may want to add additional error handling depending on your specific use case.