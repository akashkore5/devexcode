---
id: "703290"
title: "Longest Arithmetic Subsequence"
slug: "longest-arithmetic-progression1019"
difficulty: "Medium"
companyTags: ["Amazon", "Microsoft", "Snapdeal", "Google"]
tags: ["Arrays", "Dynamic Programming", "Data Structures", "Algorithms"]
---

**Longest Arithmetic Subsequence**
=====================================

**Slug:** longest-arithmetic-progression1019
**Difficulty:** Medium
**Id:** 703290
**Topic Tags:** Arrays, Dynamic Programming, Data Structures, Algorithms
**Company Tags:** Amazon, Microsoft, Snapdeal, Google

## Summary
Given an array of integers, find the length of the longest arithmetic subsequence. An arithmetic progression is a sequence of numbers where each term after the first is obtained by adding a fixed constant to the previous term.

## Detailed Explanation
To solve this problem, we can use dynamic programming. We initialize a 2D array `dp` with size `n * (max_val - min_val + 1)`, where `n` is the length of the input array and `max_val` and `min_val` are the maximum and minimum values in the array, respectively.

The idea is to iterate over all possible differences between consecutive elements in the array. For each difference, we check if there's a sequence ending at that point with the same difference. If there is, we increment its length by 1. The final answer will be the maximum length of any such sequence.

Here's the step-by-step breakdown:

1. Initialize `dp` and set all values to 0.
2. Iterate over the array:
	* For each element, calculate the possible differences with previous elements.
	* For each difference, check if there's a sequence ending at that point with the same difference.
	* If there is, increment its length by 1.
3. The final answer will be the maximum length of any such sequence.

Time complexity: O(n^2)
Space complexity: O(n \* (max_val - min_val + 1))

## Optimized Solutions

### Java
```java
public int longestArithSubseq(int[] nums) {
    int n = nums.length;
    int maxLen = 0;
    Map<Integer, Integer> dp = new HashMap<>();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            int diff = nums[i] - nums[j];
            if (!dp.containsKey(diff)) {
                dp.put(diff, 1);
            } else {
                dp.put(diff, dp.get(diff) + 1);
            }
            maxLen = Math.max(maxLen, dp.getOrDefault(diff, 0));
        }
    }
    return maxLen;
}
```

### Python
```python
def longestArithSubseq(nums):
    n = len(nums)
    max_len = 0
    dp = {}
    for i in range(n):
        for j in range(i):
            diff = nums[i] - nums[j]
            if diff not in dp:
                dp[diff] = 1
            else:
                dp[diff] += 1
            max_len = max(max_len, dp.get(diff, 0))
    return max_len
```

### C++
```cpp
int longestArithSubseq(vector<int> nums) {
    int n = nums.size();
    int maxLen = 0;
    unordered_map<int, int> dp;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            int diff = nums[i] - nums[j];
            if (!dp.count(diff)) {
                dp[diff] = 1;
            } else {
                dp[diff]++;
            }
            maxLen = max(maxLen, dp[diff]);
        }
    }
    return maxLen;
}
```

### JavaScript
```javascript
function longestArithSubseq(nums) {
    let n = nums.length;
    let maxLen = 0;
    const dp = {};
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            let diff = nums[i] - nums[j];
            if (!dp[diff]) {
                dp[diff] = 1;
            } else {
                dp[diff]++;
            }
            maxLen = Math.max(maxLen, dp[diff]);
        }
    }
    return maxLen;
}
```