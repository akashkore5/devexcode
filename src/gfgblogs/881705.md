---
id: "881705"
title: "Heapify the vector"
slug: "heapify-the-vector--102013"
difficulty: "Basic"
companyTags: []
tags: ["STL"]
---

**Heapify the Vector**
=====================

### Slug: heapify-the-vector--102013
### Difficulty: Basic
### Id: 881705
### Topic Tags: STL
### Company Tags: None

## Summary
The problem is to heapify a given vector, where heapifying means transforming the vector into a min-heap. This involves rearranging the elements of the vector such that each parent node is less than or equal to its children.

## Detailed Explanation
To solve this problem, we can use the `make_heap` function from the `<algorithm>` library in C++. This function takes a random access iterator as input and heapifies the range [first, last).

Here's the step-by-step breakdown of the solution:

1. Include the necessary header files: `<algorithm>` and `<vector>`.
2. Use the `make_heap` function to heapify the vector.
3. The time complexity of this algorithm is O(n log n), where n is the size of the vector, because `make_heap` uses the Heapsort algorithm internally.
4. The space complexity is O(1) as we are not using any extra space.

Here's an example ASCII art diagram to illustrate the process:

```
     5
   /    \
 3       8
/ \    / \
2   4 6   9
```

In this diagram, the vector `[5, 3, 8, 2, 4, 6, 9]` is heapified to form a min-heap.

## Optimized Solutions

### Java
```java
import java.util.Vector;
import java.util.Arrays;

public class Heapify {
    public static void main(String[] args) {
        Vector<Integer> vec = new Vector<>();
        // Add elements to the vector
        Arrays.fill(vec, 1, 7, i -> (int)(Math.random() * 100));
        make_heap(vec);
        System.out.println("Heapified vector: " + vec);
    }

    public static void make_heap(Vector<Integer> vec) {
        for (int i = vec.size() / 2 - 1; i >= 0; i--) {
            heapify(vec, i, vec.size() - 1);
        }
    }

    public static void heapify(Vector<Integer> vec, int i, int n) {
        int largest = i;
        int l = 2 * i + 1;
        int r = 2 * i + 2;

        if (l <= n && vec.get(l) > vec.get(largest))
            largest = l;

        if (r <= n && vec.get(r) > vec.get(largest))
            largest = r;

        if (largest != i) {
            int temp = vec.get(i);
            vec.set(i, vec.get(largest));
            vec.set(largest, temp);

            heapify(vec, largest, n);
        }
    }
}
```

### Python
```python
import random

def heapify(vector):
    for i in range(len(vector) // 2 - 1, -1, -1):
        heapify_helper(vector, i, len(vector))

def heapify_helper(vector, i, n):
    largest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and vector[l] > vector[largest]:
        largest = l

    if r < n and vector[r] > vector[largest]:
        largest = r

    if largest != i:
        vector[i], vector[largest] = vector[largest], vector[i]
        heapify_helper(vector, largest, n)

# Example usage
vector = [random.randint(0, 100) for _ in range(7)]
heapify(vector)
print("Heapified vector:", vector)
```

### C++
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

void make_heap(std::vector<int>& vec) {
    for (int i = vec.size() / 2 - 1; i >= 0; i--) {
        heapify(vec, i, vec.size() - 1);
    }
}

void heapify(std::vector<int>& vec, int i, int n) {
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;

    if (l <= n && vec.at(l) > vec.at(largest))
        largest = l;

    if (r <= n && vec.at(r) > vec.at(largest))
        largest = r;

    if (largest != i) {
        int temp = vec.at(i);
        vec.at(i) = vec.at(largest);
        vec.at(largest) = temp;

        heapify(vec, largest, n);
    }
}

int main() {
    std::vector<int> vec;
    // Add elements to the vector
    for (int i = 0; i < 7; i++) {
        vec.push_back((rand() % 100));
    }
    make_heap(vec);
    std::cout << "Heapified vector: ";
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

### JavaScript
```javascript
function heapify(vector, i, n) {
  let largest = i;
  const l = 2 * i + 1;
  const r = 2 * i + 2;

  if (l <= n && vector[l] > vector[largest])
    largest = l;

  if (r <= n && vector[r] > vector[largest])
    largest = r;

  if (largest !== i) {
    [vector[i], vector[largest]] = [vector[largest], vector[i]];
    heapify(vector, largest, n);
  }
}

function make_heap(vector) {
  for (let i = Math.floor(vector.length / 2 - 1); i >= 0; i--) {
    heapify(vector, i, vector.length - 1);
  }
}

// Example usage
const vector = [];
for (let i = 0; i < 7; i++) {
  vector.push(Math.floor(Math.random() * 100));
}
make_heap(vector);
console.log("Heapified vector:", vector);
```

Note: The above solutions are not optimized and have a time complexity of O(n log n) due to the use of `make_heap` or manual heapification. A more optimized solution would be to use a priority queue, which has a time complexity of O(log n).