---
id: "713194"
title: "Minimum Number Of Sprinkler"
slug: "minimum-number-of-sprinkler--170645"
difficulty: "Hard"
companyTags: []
tags: ["Dynamic Programming", "Data Structures", "Algorithms"]
---

**Minimum Number Of Sprinkler**
======================================================

## Summary
The problem is about finding the minimum number of sprinklers needed to cover a given area with rectangular shapes. The sprinklers have different dimensions and can be rotated to fit the area. The goal is to use the fewest number of sprinklers possible while covering the entire area.

Tags: Dynamic Programming, Data Structures, Algorithms

## Detailed Explanation
The problem involves dynamic programming as it requires finding the minimum number of sprinklers needed to cover a given area with rectangular shapes. The approach is to start by dividing the area into smaller sub-areas and then recursively solving the problem for each sub-area.

Here's a step-by-step breakdown of the solution:

1. Initialize a 2D array `dp` of size `(width + 1) x (height + 1)` where `width` and `height` are the dimensions of the area.
2. Set `dp[0][j] = dp[i][0] = 0` for all `i, j`, as there is no need to place any sprinklers at the boundaries.
3. For each sub-area `(i, j)` where `1 <= i <= width` and `1 <= j <= height`, calculate the minimum number of sprinklers needed to cover it by considering three cases:
	* Case 1: Place a horizontal sprinkler at position `(i, j)`. Calculate the area covered by this sprinkler (`w * h`) and subtract it from the sub-area. Recursively call `dp` for the remaining sub-area.
	* Case 2: Place a vertical sprinkler at position `(i, j)`. Calculate the area covered by this sprinkler (`w * h`) and subtract it from the sub-area. Recursively call `dp` for the remaining sub-area.
	* Case 3: Do not place any sprinklers in this sub-area. The minimum number of sprinklers needed is the same as the minimum number of sprinklers needed to cover the previous sub-area (`dp[i-1][j]` or `dp[i][j-1]`, depending on which direction has more remaining area).
4. The minimum number of sprinklers needed to cover the entire area is stored in `dp[width][height]`.

Time complexity: O(width * height)
Space complexity: O(width * height)

## Optimized Solutions
### Java
```
java
public class MinimumSprinkler {
    public static int minSprinklers(int width, int height) {
        int[][] dp = new int[width + 1][height + 1];
        for (int i = 0; i <= width; i++) {
            dp[i][0] = dp[0][i] = 0;
        }
        for (int i = 1; i <= width; i++) {
            for (int j = 1; j <= height; j++) {
                int min = Math.min(i, j);
                if (min > 0) {
                    dp[i][j] = min + 1;
                } else {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
        }
        return dp[width][height];
    }
}
```
### Python
```
python
def min_sprinklers(width, height):
    dp = [[0] * (height + 1) for _ in range(width + 1)]
    for i in range(width + 1):
        dp[i][0] = dp[0][i] = 0
    for i in range(1, width + 1):
        for j in range(1, height + 1):
            min_val = min(i, j)
            if min_val > 0:
                dp[i][j] = min_val + 1
            else:
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    return dp[width][height]
```
### C++
```
cpp
#include <iostream>
using namespace std;

int minSprinklers(int width, int height) {
    int dp[width + 1][height + 1];
    for (int i = 0; i <= width; i++) {
        dp[i][0] = dp[0][i] = 0;
    }
    for (int i = 1; i <= width; i++) {
        for (int j = 1; j <= height; j++) {
            int min = min(i, j);
            if (min > 0) {
                dp[i][j] = min + 1;
            } else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
    }
    return dp[width][height];
}

int main() {
    int width, height;
    cin >> width >> height;
    cout << minSprinklers(width, height) << endl;
    return 0;
}
```
### JavaScript
```
javascript
function minSprinklers(width, height) {
    let dp = new Array(width + 1).fill().map(() => new Array(height + 1).fill(0));
    for (let i = 0; i <= width; i++) {
        dp[i][0] = dp[0][i] = 0;
    }
    for (let i = 1; i <= width; i++) {
        for (let j = 1; j <= height; j++) {
            let min = Math.min(i, j);
            if (min > 0) {
                dp[i][j] = min + 1;
            } else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
    }
    return dp[width][height];
}
```