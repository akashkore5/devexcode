---
id: "700561"
title: "Perfect Binary Tree"
slug: "perfect-binary-tree"
difficulty: "Easy"
companyTags: ["FactSet"]
tags: ["Tree", "Data Structures"]
---

**Perfect Binary Tree**
======================

### Summary
A perfect binary tree is a tree in which every internal node has exactly two children. This problem requires you to check if a given binary tree is perfect or not.

### Detailed Explanation
To solve this problem, we can start by finding the maximum height of the tree and then calculate the number of nodes at each level. If the number of nodes at each level starts from 1 and doubles at each subsequent level until it reaches the last level which has only one node (the leaf), then the binary tree is perfect.

Here's a step-by-step breakdown:

1. Start by calculating the maximum height of the tree.
2. Calculate the number of nodes at each level. The number of nodes at the first level will be 1, and it will double at each subsequent level until you reach the last level which has only one node (the leaf).
3. Compare the calculated number of nodes with the actual number of nodes at each level.
4. If the calculated number of nodes matches the actual number of nodes at each level for all levels except the last, then the binary tree is perfect.

Here's an example of how this would work:

```
       1
     /   \
    2     3
   / \   / \
  4   5 6   7
 / \
8   9
```

The maximum height of this tree is 3. The number of nodes at each level are: 1, 2, 4, and 8. This matches the formula for a perfect binary tree, where the number of nodes at each level doubles.

Time complexity: O(n), where n is the number of nodes in the tree.
Space complexity: O(1).

### Optimized Solutions

#### Java
```java
public class Main {
    public static void main(String[] args) {
        Node node = new Node(1);
        node.left = new Node(2);
        node.right = new Node(3);
        node.left.left = new Node(4);
        node.left.right = new Node(5);
        node.right.left = new Node(6);
        node.right.right = new Node(7);
        node.left.left.left = new Node(8);
        node.left.left.right = new Node(9);

        if (isPerfectBinaryTree(node)) {
            System.out.println("The binary tree is perfect.");
        } else {
            System.out.println("The binary tree is not perfect.");
        }
    }

    public static boolean isPerfectBinaryTree(Node node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.left;
        }

        int numNodesAtLevel = (int) Math.pow(2, height - 1);
        for (int i = 1; i < height; i++) {
            if (numNodesAtLevel != getNumNodesAtLevel(node, i)) {
                return false;
            }
            numNodesAtLevel *= 2;
        }

        return true;
    }

    public static int getNumNodesAtLevel(Node node, int level) {
        int numNodes = 0;
        for (int i = 1; i <= level; i++) {
            if (node == null) {
                break;
            }
            if (i == level) {
                numNodes++;
            }
            node = (node.left != null) ? node.left : node.right;
        }

        return numNodes;
    }

    public static class Node {
        int val;
        Node left, right;

        public Node(int val) {
            this.val = val;
        }
    }
}
```

#### Python
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def is_perfect_binary_tree(node):
    height = 0
    while node:
        height += 1
        node = node.left

    num_nodes_at_level = 2 ** (height - 1)
    for i in range(1, height):
        if num_nodes_at_level != get_num_nodes_at_level(node, i):
            return False
        num_nodes_at_level *= 2

    return True

def get_num_nodes_at_level(node, level):
    num_nodes = 0
    for _ in range(level):
        if node:
            if _ == level - 1:
                num_nodes += 1
            node = node.left if node.left else node.right
        else:
            break

    return num_nodes

node = Node(1)
node.left = Node(2)
node.right = Node(3)
node.left.left = Node(4)
node.left.right = Node(5)
node.right.left = Node(6)
node.right.right = Node(7)
node.left.left.left = Node(8)
node.left.left.right = Node(9)

if is_perfect_binary_tree(node):
    print("The binary tree is perfect.")
else:
    print("The binary tree is not perfect.")
```

#### C++
```cpp
#include <iostream>
using namespace std;

struct Node {
    int val;
    Node* left, *right;

    Node(int val) : val(val), left(nullptr), right(nullptr) {}
};

bool isPerfectBinaryTree(Node* node) {
    int height = 0;
    while (node) {
        height++;
        node = node->left;
    }

    int numNodesAtLevel = (1 << (height - 1));
    for (int i = 1; i < height; i++) {
        if (numNodesAtLevel != getNumNodesAtLevel(node, i)) {
            return false;
        }
        numNodesAtLevel *= 2;
    }

    return true;
}

int getNumNodesAtLevel(Node* node, int level) {
    int numNodes = 0;
    for (int i = 1; i <= level; i++) {
        if (!node) {
            break;
        }
        if (i == level) {
            numNodes++;
        }
        node = (node->left) ? node->left : node->right;
    }

    return numNodes;
}

int main() {
    Node* node = new Node(1);
    node->left = new Node(2);
    node->right = new Node(3);
    node->left->left = new Node(4);
    node->left->right = new Node(5);
    node->right->left = new Node(6);
    node->right->right = new Node(7);
    node->left->left->left = new Node(8);
    node->left->left->right = new Node(9);

    if (isPerfectBinaryTree(node)) {
        cout << "The binary tree is perfect." << endl;
    } else {
        cout << "The binary tree is not perfect." << endl;
    }

    return 0;
}
```

#### JavaScript
```javascript
class Node {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

function isPerfectBinaryTree(node) {
    let height = 0;
    while (node) {
        height++;
        node = node.left;
    }

    let numNodesAtLevel = Math.pow(2, height - 1);
    for (let i = 1; i < height; i++) {
        if (numNodesAtLevel !== getNumNodesAtLevel(node, i)) {
            return false;
        }
        numNodesAtLevel *= 2;
    }

    return true;
}

function getNumNodesAtLevel(node, level) {
    let numNodes = 0;
    for (let i = 1; i <= level; i++) {
        if (!node) {
            break;
        }
        if (i === level) {
            numNodes++;
        }
        node = node.left ? node.left : node.right;
    }

    return numNodes;
}

const node = new Node(1);
node.left = new Node(2);
node.right = new Node(3);
node.left.left = new Node(4);
node.left.right = new Node(5);
node.right.left = new Node(6);
node.right.right = new Node(7);
node.left.left.left = new Node(8);
node.left.left.right = new Node(9);

if (isPerfectBinaryTree(node)) {
    console.log("The binary tree is perfect.");
} else {
    console.log("The binary tree is not perfect.");
}
```

Note: The above code assumes that the input node is a leaf node. You may need to modify it depending on your specific use case.