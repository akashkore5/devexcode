---
id: "700585"
title: "Identical Linked Lists"
slug: "identical-linked-lists"
difficulty: "Basic"
companyTags: []
tags: ["Linked List", "Data Structures", "Algorithms"]
---

**Identical Linked Lists**
=====================

### Summary

Given two singly linked lists, determine if they are identical. Two linked lists are considered identical if they have the same nodes in the same order. This problem involves manipulating and comparing linked list nodes.

### Detailed Explanation

To solve this problem, we can use a simple iterative approach that traverses both linked lists simultaneously. We compare each node of one linked list with its corresponding node in the other linked list. If all nodes match, then the linked lists are identical.

Here's a step-by-step breakdown of the solution:

1. Initialize two pointers, `p` and `q`, to point to the head nodes of both linked lists.
2. Traverse both linked lists using these pointers. At each step, compare the current node of one linked list with its corresponding node in the other linked list.
3. If all nodes match, then the linked lists are identical. If any mismatch is found, return false.

Here's an ASCII art diagram to illustrate this process:
```
          L1: 1 -> 2 -> 3 -> NULL
          L2: 1 -> 2 -> 3 -> NULL

         p        q
       +-----+   +-----+
       |     |   |     |
       |  1  |   |  1  |
       +-----+   +-----+
       |     |   |     |
       |  2  |   |  2  |
       +-----+   +-----+
       |     |   |     |
       |  3  |   |  3  |
       +-----+   +-----+
```
The time complexity of this solution is O(n), where n is the number of nodes in the linked lists, since we need to traverse both lists once. The space complexity is O(1), as we only use a few extra variables to store the pointers.

### Optimized Solutions

#### Java
```java
public boolean areIdentical(Node head1, Node head2) {
    while (head1 != null && head2 != null) {
        if (head1.data != head2.data) {
            return false;
        }
        head1 = head1.next;
        head2 = head2.next;
    }
    return head1 == null && head2 == null;
}
```

#### Python
```python
def are_identical(head1, head2):
    while head1 and head2:
        if head1.data != head2.data:
            return False
        head1 = head1.next
        head2 = head2.next
    return head1 is None and head2 is None
```

#### C++
```cpp
bool areIdentical(Node* head1, Node* head2) {
    while (head1 && head2) {
        if (head1->data != head2->data) {
            return false;
        }
        head1 = head1->next;
        head2 = head2->next;
    }
    return head1 == nullptr && head2 == nullptr;
}
```

#### JavaScript
```javascript
function areIdentical(head1, head2) {
    while (head1 && head2) {
        if (head1.data !== head2.data) {
            return false;
        }
        head1 = head1.next;
        head2 = head2.next;
    }
    return head1 === null && head2 === null;
}
```
Note that these optimized solutions are written in the respective languages and follow the same iterative approach as described earlier.