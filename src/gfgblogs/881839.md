---
id: "881839"
title: "Pattern searching"
slug: "pattern-searching5231--150028"
difficulty: "Easy"
companyTags: []
tags: ["STL"]
---

**Pattern Searching**
=====================

**Slug**: pattern-searching5231--150028
**Difficulty**: Easy
**Id**: 881839
**Topic Tags**: STL

## Summary
The problem is about searching a given text for a specific pattern. The key concepts involved are string manipulation, pattern matching, and algorithmic approaches.

## Detailed Explanation
To solve this problem, we can use the Knuth-Morris-Pratt (KMP) algorithm, which is an efficient way to search for a pattern in a text. The KMP algorithm preprocesses the pattern to create a lookup table that helps us skip over non-matching characters at the beginning of the text.

Here's a step-by-step breakdown of the solution:

1. Preprocess the pattern to create a lookup table called `lps` (longest proper prefix suffix). This table stores the length of the longest proper prefix that is also a proper suffix for each prefix of the pattern.
2. Initialize two pointers, `textIndex` and `patternIndex`, to 0. These pointers will be used to iterate through the text and the pattern respectively.
3. Compare the character at the current position in the text with the character at the current position in the pattern.
4. If they match, move both pointers forward by 1 character.
5. If they don't match, use the `lps` table to determine how many characters we can skip over in the text without losing our chance of finding the pattern. This is done by looking up the length of the longest proper prefix that is also a proper suffix for the current prefix of the pattern.
6. Repeat steps 3-5 until we find the pattern or reach the end of the text.

Time complexity: O(n + m), where n is the length of the text and m is the length of the pattern.
Space complexity: O(m) for the `lps` table.

## Optimized Solutions

### Java
```java
public int search(String text, String pattern) {
    int[] lps = computeLPSArray(pattern);
    int textIndex = 0;
    int patternIndex = 0;

    while (textIndex < text.length()) {
        if (pattern.charAt(patternIndex) == text.charAt(textIndex)) {
            textIndex++;
            patternIndex++;
        }

        if (patternIndex == pattern.length()) {
            return textIndex - patternIndex;
        }

        else if (textIndex < text.length() && pattern.charAt(patternIndex) != text.charAt(textIndex)) {
            if (patternIndex != 0) {
                patternIndex = lps[patternIndex - 1];
            } else {
                textIndex++;
            }
        }
    }

    return -1;
}

private int[] computeLPSArray(String pattern) {
    int[] lps = new int[pattern.length()];
    int length = 0;

    lps[0] = 0;

    for (int i = 1; i < pattern.length(); i++) {
        while (length > 0 && pattern.charAt(i) != pattern.charAt(length)) {
            length = lps[length - 1];
        }

        if (pattern.charAt(i) == pattern.charAt(length)) {
            length++;
        }

        lps[i] = length;
    }

    return lps;
}
```

### Python
```python
def search(text, pattern):
    lps = compute_lps_array(pattern)
    text_index = 0
    pattern_index = 0

    while text_index < len(text):
        if pattern[pattern_index] == text[text_index]:
            text_index += 1
            pattern_index += 1

        if pattern_index == len(pattern):
            return text_index - pattern_index

        elif text_index < len(text) and pattern[pattern_index] != text[text_index]:
            if pattern_index != 0:
                pattern_index = lps[pattern_index - 1]
            else:
                text_index += 1

    return -1

def compute_lps_array(pattern):
    lps = [0] * len(pattern)
    length = 0

    lps[0] = 0

    for i in range(1, len(pattern)):
        while length > 0 and pattern[i] != pattern[length]:
            length = lps[length - 1]

        if pattern[i] == pattern[length]:
            length += 1

        lps[i] = length

    return lps
```

### C++
```cpp
int search(const std::string& text, const std::string& pattern) {
    int* lps = computeLPSArray(pattern);
    int textIndex = 0;
    int patternIndex = 0;

    while (textIndex < text.length()) {
        if (pattern[patternIndex] == text[textIndex]) {
            textIndex++;
            patternIndex++;
        }

        if (patternIndex == pattern.length()) {
            return textIndex - patternIndex;
        }

        else if (textIndex < text.length() && pattern[patternIndex] != text[textIndex]) {
            if (patternIndex != 0) {
                patternIndex = lps[patternIndex - 1];
            } else {
                textIndex++;
            }
        }
    }

    delete[] lps;
    return -1;
}

int* computeLPSArray(const std::string& pattern) {
    int* lps = new int[pattern.length()];
    int length = 0;

    lps[0] = 0;

    for (int i = 1; i < pattern.length(); i++) {
        while (length > 0 && pattern[i] != pattern[length]) {
            length = lps[length - 1];
        }

        if (pattern[i] == pattern[length]) {
            length++;
        }

        lps[i] = length;
    }

    return lps;
}
```

### JavaScript
```javascript
function search(text, pattern) {
    let lps = computeLPSArray(pattern);
    let textIndex = 0;
    let patternIndex = 0;

    while (textIndex < text.length) {
        if (pattern[patternIndex] === text[textIndex]) {
            textIndex++;
            patternIndex++;
        }

        if (patternIndex === pattern.length) {
            return textIndex - patternIndex;
        }

        else if (textIndex < text.length && pattern[patternIndex] !== text[textIndex]) {
            if (patternIndex !== 0) {
                patternIndex = lps[patternIndex - 1];
            } else {
                textIndex++;
            }
        }
    }

    return -1;
}

function computeLPSArray(pattern) {
    let lps = new Array(pattern.length());
    let length = 0;

    lps[0] = 0;

    for (let i = 1; i < pattern.length; i++) {
        while (length > 0 && pattern[i] !== pattern[length]) {
            length = lps[length - 1];
        }

        if (pattern[i] === pattern[length]) {
            length++;
        }

        lps[i] = length;
    }

    return lps;
}
```