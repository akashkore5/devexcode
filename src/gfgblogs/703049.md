---
id: "703049"
title: "Reverse sub array"
slug: "reverse-sub-array5620"
difficulty: "Basic"
companyTags: ["Amazon"]
tags: ["Arrays", "Data Structures"]
---

# Reverse Sub Array

## Slug: reverse-sub-array5620
## Difficulty: Basic
## Id: 703049
## Topic Tags: Arrays, Data Structures
## Company Tags: Amazon


### Summary

Given an array and a start index, reverse the subarray from that start index to the end of the array. The problem is about manipulating arrays in-place, which involves modifying the original array without creating a new one.

### Detailed Explanation

To solve this problem, we can iterate through the array starting from the given start index to the end of the array. For each element, we swap it with the corresponding element at the end of the array minus the distance from the start index. We continue this process until we have processed the entire subarray.

Here's a step-by-step breakdown of the solution:

1. Start at the given start index `i`.
2. Calculate the distance `dist` between the current position and the end of the array.
3. Swap the element at the current position with the element `dist` positions away from the end of the array.
4. Move to the next position by incrementing `i` and decrementing `dist`.
5. Repeat steps 2-4 until we have processed the entire subarray.

### Optimized Solutions

#### Java
```java
public static void reverseSubArray(int[] arr, int start) {
    int n = arr.length;
    for (int i = start; i < n; i++) {
        int j = n - 1 - (i - start);
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

#### Python
```python
def reverse_sub_array(arr, start):
    n = len(arr)
    for i in range(start, n):
        j = n - 1 - (i - start)
        arr[i], arr[j] = arr[j], arr[i]
```

#### C++
```cpp
void reverseSubArray(int* arr, int n, int start) {
    for (int i = start; i < n; i++) {
        int j = n - 1 - (i - start);
        swap(arr[i], arr[j]);
    }
}
```

#### JavaScript
```javascript
function reverseSubArray(arr, start) {
    let n = arr.length;
    for (let i = start; i < n; i++) {
        let j = n - 1 - (i - start);
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}
```

All solutions have a time complexity of O(n), where n is the length of the array. The space complexity is O(1) because we only use a constant amount of extra memory to store temporary values during the swapping process.