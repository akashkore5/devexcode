---
id: "703179"
title: "Maximum Sum Path in Two Arrays"
slug: "maximum-sum-path-in-two-arrays5314"
difficulty: "Medium"
companyTags: []
tags: ["Arrays", "Data Structures"]
---

Here is the detailed Markdown blog post for the GeeksforGeeks problem "Maximum Sum Path in Two Arrays":

**Maximum Sum Path in Two Arrays**
=============================

## Summary
Given two arrays of integers, find the maximum sum path that starts from the first element of each array and ends at the last element of each array. The path can only move from one array to another if the current elements are equal.

## Detailed Explanation
The problem requires us to find the maximum sum of a path that alternates between two arrays, starting from the first element of each array and ending at the last element of each array. To solve this problem, we can use dynamic programming.

Here's the step-by-step breakdown:

1. Initialize a 2D table `dp` with dimensions `(n + 1) x (m + 1)`, where `n` is the length of the first array and `m` is the length of the second array.
2. Fill the first row and first column of `dp` with values from the first array and second array, respectively.
3. Iterate over the table, considering each element at position `(i, j)`. If the current elements in both arrays are equal (`arr1[i] == arr2[j]`), we can consider two options:
	* Move to the next element in the same array (left or up).
	* Move to the corresponding element in the other array.
4. Calculate the maximum sum for each option and store it in `dp[i][j]`.
5. The maximum sum path is stored in the bottom-right corner of the table (`dp[n][m]`).

Here's an ASCII art diagram illustrating the dynamic programming approach:
```
  +---------------+
  | arr1[0]  |   |
  +---------------+
  | arr2[0]  |   |
  +---------------+
  ...
  | arr1[i-1] | dp[i][j-1] |
  +---------------+
  | arr2[j-1] | dp[i-1][j]  |
  +---------------+
  ...
  | arr1[n-1] | dp[n][m-1] |
  +---------------+
  | arr2[m-1] | dp[n-1][m]  |
  +---------------+
```
Time complexity: O(n \* m)
Space complexity: O(n \* m)

## Optimized Solutions
Here are optimized solutions in various programming languages:

### Java
```java
public class Main {
    public static int maxSumPath(int[] arr1, int[] arr2) {
        int n = arr1.length;
        int m = arr2.length;
        int[][] dp = new int[n + 1][m + 1];

        for (int i = 0; i <= n; i++) {
            dp[i][0] = arr1[i];
        }

        for (int j = 0; j <= m; j++) {
            dp[0][j] = arr2[j];
        }

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (arr1[i - 1] == arr2[j - 1]) {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[n][m];
    }
}
```

### Python
```python
def max_sum_path(arr1, arr2):
    n = len(arr1)
    m = len(arr2)
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    for i in range(n + 1):
        dp[i][0] = arr1[i]

    for j in range(m + 1):
        dp[0][j] = arr2[j]

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if arr1[i - 1] == arr2[j - 1]:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    return dp[n][m]
```

### C++
```cpp
#include <iostream>
using namespace std;

int maxSumPath(int arr1[], int arr2[], int n, int m) {
    int dp[n + 1][m + 1];

    for (int i = 0; i <= n; i++) {
        dp[i][0] = arr1[i];
    }

    for (int j = 0; j <= m; j++) {
        dp[0][j] = arr2[j];
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (arr1[i - 1] == arr2[j - 1]) {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[n][m];
}

int main() {
    int arr1[] = {1, 2, 3};
    int arr2[] = {4, 5, 6};

    int n = sizeof(arr1) / sizeof(arr1[0]);
    int m = sizeof(arr2) / sizeof(arr2[0]);

    cout << "Maximum sum path: " << maxSumPath(arr1, arr2, n, m) << endl;

    return 0;
}
```

### JavaScript
```javascript
function maxSumPath(arr1, arr2) {
    let n = arr1.length;
    let m = arr2.length;
    let dp = new Array(n + 1).fill(0).map(() => new Array(m + 1).fill(0));

    for (let i = 0; i <= n; i++) {
        dp[i][0] = arr1[i];
    }

    for (let j = 0; j <= m; j++) {
        dp[0][j] = arr2[j];
    }

    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (arr1[i - 1] === arr2[j - 1]) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[n][m];
}
```
Note: The optimized solutions are provided for illustration purposes only. In a real-world scenario, you would want to optimize the solution further by reducing redundant calculations and using more efficient data structures.