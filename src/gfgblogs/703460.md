---
id: "703460"
title: "Palindromic Series"
slug: "palindromic-series5346"
difficulty: "Easy"
companyTags: []
tags: ["Arrays", "Strings", "Numbers", "palindrome", "alphabets", "Data Structures"]
---

**Palindromic Series**
==================================

### Summary

Given an array of integers, find all palindromic series (sequences) in it. A palindromic series is a sequence of integers that reads the same backward as forward. For example, [1, 2, 3, 4] and [5, 6, 7, 8, 9, 0] are not palindromic series, but [1, 2, 2, 1], [1, 3, 3, 1], etc. are.

### Detailed Explanation

To solve this problem, we will iterate through the array and for each element, check if there is a palindrome sequence ending at that position. We can do this by iterating from both ends of the sequence towards the center. If the elements at the two ends are equal, we move towards the center until they become unequal or we reach the middle.

Here's the step-by-step breakdown:

1. Initialize an empty list to store the palindromic series.
2. Iterate through the array. For each element:
	* Check if there is a palindrome sequence ending at that position by iterating from both ends towards the center.
	* If the elements at the two ends are equal, move towards the center until they become unequal or we reach the middle.
	* Add the palindrome sequence to the list.
3. Return the list of palindromic series.

The time complexity for this algorithm is O(n^2) where n is the length of the array, because we are checking every possible pair of elements in the worst case scenario. The space complexity is O(n) as we need to store all the palindrome sequences found.

### Optimized Solutions

#### Java
```java
import java.util.ArrayList;
import java.util.List;

public class PalindromicSeries {
    public List<List<Integer>> findPalindromicSeries(int[] arr) {
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < arr.length; i++) {
            for (int j = i; j < arr.length; j++) {
                boolean isPalindrome = true;
                int left = i, right = j;
                while (left <= right) {
                    if (arr[left] != arr[right]) {
                        isPalindrome = false;
                        break;
                    }
                    left++;
                    right--;
                }
                if (isPalindrome) {
                    result.add(new ArrayList<>(Arrays.asList(arr.subArray(i, j + 1))));
                }
            }
        }
        return result;
    }
}
```

#### Python
```python
def find_palindromic_series(arr):
    result = []
    for i in range(len(arr)):
        for j in range(i, len(arr)):
            is_palindrome = True
            left = i
            right = j
            while left <= right:
                if arr[left] != arr[right]:
                    is_palindrome = False
                    break
                left += 1
                right -= 1
            if is_palindrome:
                result.append(arr[i:j+1])
    return result
```

#### C++
```cpp
#include <vector>
#include <algorithm>

std::vector<std::vector<int>> findPalindromicSeries(const std::vector<int>& arr) {
    std::vector<std::vector<int>> result;
    for (int i = 0; i < arr.size(); i++) {
        for (int j = i; j < arr.size(); j++) {
            bool isPalindrome = true;
            int left = i, right = j;
            while (left <= right) {
                if (arr[left] != arr[right]) {
                    isPalindrome = false;
                    break;
                }
                left++;
                right--;
            }
            if (isPalindrome) {
                result.push_back(std::vector<int>(arr.begin() + i, arr.begin() + j + 1));
            }
        }
    }
    return result;
}
```

#### JavaScript
```javascript
function findPalindromicSeries(arr) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        for (let j = i; j < arr.length; j++) {
            let isPalindrome = true;
            let left = i, right = j;
            while (left <= right) {
                if (arr[left] !== arr[right]) {
                    isPalindrome = false;
                    break;
                }
                left++;
                right--;
            }
            if (isPalindrome) {
                result.push(arr.slice(i, j + 1));
            }
        }
    }
    return result;
}
```

Note that the optimized solutions are provided in different programming languages. The approach remains the same across all languages, but the implementation details may vary.