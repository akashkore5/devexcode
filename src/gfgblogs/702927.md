---
id: "702927"
title: "Alternative Sorting"
slug: "alternative-sorting1311"
difficulty: "Basic"
companyTags: ["Zoho"]
tags: ["Arrays", "Sorting", "Data Structures", "Algorithms"]
---

**Alternative Sorting**
===============

**Slug:** alternative-sorting1311
**Difficulty:** Basic
**Id:** 702927
**Topic Tags:** Arrays, Sorting, Data Structures, Algorithms
**Company Tags:** Zoho

## Summary
The problem requires you to sort an array of integers using a different approach. The traditional sorting algorithms like Bubble Sort, Selection Sort, Insertion Sort are not allowed in this problem. You need to find a unique way to sort the array without using these standard algorithms.

## Detailed Explanation
To solve this problem, we will use a combination of two popular sorting algorithms - Radix Sort and Counting Sort. The idea is to first group the numbers based on their most significant digit (MSD) using Radix Sort. Then, for each group, sort the numbers based on the MSDs within that group using Counting Sort.

Here's how you can do it:

1.  Initialize an array `buckets` of size 10 to store the numbers grouped by their MSD.
2.  Iterate through the input array and place each number in its corresponding bucket based on its MSD.
3.  Now, for each non-empty bucket, use Counting Sort to sort the numbers within that bucket based on their MSDs.
4.  Combine all the sorted buckets to get the final sorted array.

Here's a step-by-step breakdown of the solution:

*   Initialize an array `buckets` of size 10 with all elements set to 0.
*   Iterate through the input array and place each number in its corresponding bucket based on its MSD.
    *   For example, if the current number is 142, it will be placed in the bucket at index 1 (since its MSD is 1).
*   Now, for each non-empty bucket, use Counting Sort to sort the numbers within that bucket based on their MSDs.
*   Combine all the sorted buckets to get the final sorted array.

Time Complexity: O(n + k), where n is the size of the input array and k is the number of unique digits in the input array (in this case, 10).
Space Complexity: O(n + k), as we need extra space for the buckets and counting arrays.

## Optimized Solutions

### Java
```java
public int[] alternativeSorting(int[] arr) {
    int n = arr.length;
    int max = getMax(arr);
    int[] buckets = new int[10];
    
    // Group numbers based on MSD using Radix Sort
    for (int i : arr) {
        buckets[i / (max / 10)]++;
    }
    
    // Sort numbers within each bucket using Counting Sort
    for (int i = 0; i < 10; i++) {
        int[] temp = new int[buckets[i]];
        for (int j = 0; j < buckets[i]; j++) {
            temp[j] = arr[i * (max / 10) + j];
        }
        Arrays.sort(temp);
        
        // Place the sorted numbers back in their original positions
        int k = 0;
        for (int j = i * (max / 10); j < i * (max / 10) + buckets[i]; j++) {
            arr[j] = temp[k++];
        }
    }
    
    return arr;
}

// Helper function to get the maximum number
public int getMax(int[] arr) {
    int max = arr[0];
    for (int i : arr) {
        if (i > max)
            max = i;
    }
    return max;
}
```

### Python
```python
def alternative_sorting(arr):
    n = len(arr)
    max_val = max(arr)
    
    # Group numbers based on MSD using Radix Sort
    buckets = [0] * 10
    for num in arr:
        digit = (num // (max_val // 10))
        buckets[digit] += 1
    
    # Sort numbers within each bucket using Counting Sort
    sorted_arr = []
    for i in range(10):
        temp = [num for j, num in enumerate(arr) if (j // (max_val // 10)) == i]
        temp.sort()
        
        # Place the sorted numbers back in their original positions
        k = 0
        for j in range(i * (max_val // 10), (i + 1) * (max_val // 10)):
            arr[j] = temp[k]; k += 1
    
    return arr
```

### C++
```cpp
#include <iostream>
#include <algorithm>

int* alternative_sorting(int* arr, int n) {
    int max = *std::max_element(arr, arr + n);
    
    // Group numbers based on MSD using Radix Sort
    int buckets[10] = {0};
    for (int i = 0; i < n; i++) {
        int digit = (arr[i] / (max / 10));
        buckets[digit]++;
    }
    
    // Sort numbers within each bucket using Counting Sort
    int* sorted_arr = new int[n];
    int k = 0;
    for (int i = 0; i < 10; i++) {
        int temp[1][buckets[i]];
        for (int j = 0; j < buckets[i]; j++) {
            temp[j][0] = arr[k++];
        }
        std::sort(temp, temp + buckets[i]);
        
        // Place the sorted numbers back in their original positions
        k = 0;
        for (int j = i * (max / 10); j < (i + 1) * (max / 10); j++) {
            arr[j] = temp[k++][0];
        }
    }
    
    return arr;
}
```

### JavaScript
```javascript
function alternativeSorting(arr) {
    const n = arr.length;
    let max = Math.max(...arr);
    
    // Group numbers based on MSD using Radix Sort
    let buckets = new Array(10).fill(0);
    for (let i = 0; i < n; i++) {
        let digit = Math.floor(arr[i] / (max / 10));
        buckets[digit]++;
    }
    
    // Sort numbers within each bucket using Counting Sort
    let sortedArr = [];
    for (let i = 0; i < 10; i++) {
        let temp = arr.slice().filter((num, j) => Math.floor(num / (max / 10)) === i);
        temp.sort((a, b) => a - b);
        
        // Place the sorted numbers back in their original positions
        let k = 0;
        for (let j = i * (max / 10); j < (i + 1) * (max / 10); j++) {
            arr[j] = temp[k++];
        }
    }
    
    return arr;
}
```