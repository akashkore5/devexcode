---
id: "876295"
title: "Count words in a Trie"
slug: "count-words-in-a-trie"
difficulty: "Medium"
companyTags: []
tags: ["Advanced Data Structure", "Strings", "Trie"]
---

**Count Words in a Trie**
===============

### Summary
Given a Trie, count the frequency of each word stored in the Trie. The words are considered case-insensitive and should be counted together.

This problem involves working with an Advanced Data Structure (Trie) and Strings.

### Detailed Explanation

To solve this problem, we need to traverse the Trie and for each node that represents a complete word, increment its frequency count. We start by initializing an empty map to store the frequency of each word.

Here's a step-by-step breakdown of the solution:

1.  Initialize an empty map `wordFrequency` to store the frequency of each word.
2.  Traverse the Trie in an in-order manner (i.e., visit all nodes at the current level before moving on to the next level).
3.  For each node that represents a complete word, increment its frequency count in the `wordFrequency` map. Since we are considering case-insensitive words, convert both the node's value and the map key to lowercase.
4.  After traversing the Trie, return the `wordFrequency` map.

Here is an ASCII art diagram of the Trie for better understanding:
```
       *
      / \
     *   *
    / \ / \
   a b c d
  /
 e f
/
o p
```

Time Complexity: O(T), where T is the number of nodes in the Trie. Space Complexity: O(1) since we only use a constant amount of space to store the `wordFrequency` map.

### Optimized Solutions

#### Java
```java
import java.util.HashMap;
import java.util.Map;

public class CountWordsInTrie {
    public Map<String, Integer> countWords(TrieNode root) {
        Map<String, Integer> wordFrequency = new HashMap<>();
        traverse(root, "", wordFrequency);
        return wordFrequency;
    }

    private void traverse(TrieNode node, String word, Map<String, Integer> wordFrequency) {
        if (node == null) {
            return;
        }
        word += node.value.toLowerCase();
        if (node.children.isEmpty()) {
            wordFrequency.put(word, wordFrequency.getOrDefault(word, 0) + 1);
        } else {
            for (TrieNode child : node.children) {
                traverse(child, word, wordFrequency);
            }
        }
    }
}
```

#### Python
```python
class TrieNode:
    def __init__(self):
        self.value = ''
        self.children = []

def count_words_in_trie(root):
    word_frequency = {}
    traverse(root, '', word_frequency)
    return word_frequency

def traverse(node, word, word_frequency):
    if node is None:
        return
    word += node.value.lower()
    if not node.children:
        word_frequency[word] = word_frequency.get(word, 0) + 1
    else:
        for child in node.children:
            traverse(child, word, word_frequency)
```

#### C++
```cpp
#include <map>
#include <string>

using namespace std;

class TrieNode {
public:
    char value;
    vector<TrieNode*> children;

    TrieNode(char val) : value(val), children({}) {}
};

class CountWordsInTrie {
public:
    map<string, int> countWords(TrieNode* root) {
        map<string, int> wordFrequency;
        traverse(root, "", wordFrequency);
        return wordFrequency;
    }

    void traverse(TrieNode* node, string word, map<string, int>& wordFrequency) {
        if (node == nullptr) {
            return;
        }
        word += tolower(node->value);
        if (node->children.empty()) {
            wordFrequency[word] = wordFrequency.get(word, 0) + 1;
        } else {
            for (TrieNode* child : node->children) {
                traverse(child, word, wordFrequency);
            }
        }
    }
};
```

#### JavaScript
```javascript
class TrieNode {
  constructor(val) {
    this.value = val;
    this.children = [];
  }
}

function countWordsInTrie(root) {
  const wordFrequency = {};
  traverse(root, "", wordFrequency);
  return wordFrequency;
}

function traverse(node, word, wordFrequency) {
  if (node === null) {
    return;
  }
  word += node.value.toLowerCase();
  if (!node.children.length) {
    wordFrequency[word] = (wordFrequency[word] || 0) + 1;
  } else {
    for (const child of node.children) {
      traverse(child, word, wordFrequency);
    }
  }
}
```