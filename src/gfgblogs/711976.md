---
id: "711976"
title: "Shortest Path in Undirected Graph"
slug: "shortest-path-in-undirected-graph-having-unit-distance"
difficulty: "Medium"
companyTags: []
tags: ["Graph", "BFS", "Algorithms"]
---

# Shortest Path in Undirected Graph Having Unit Distance

## Summary

The problem is to find the shortest path between two nodes in an undirected graph where all edges have a unit distance. This problem involves basic concepts of graph theory, such as graph traversal and finding the shortest path. The key concept involved is Breadth-First Search (BFS).

## Detailed Explanation

To solve this problem, we can use Breadth-First Search (BFS) algorithm. BFS traverses the graph level by level, starting from a given source node.

Here's a step-by-step breakdown of the solution:

1. Initialize an empty queue and add the source node to it.
2. Mark the source node as visited.
3. Dequeue a node from the queue and mark its adjacent unvisited nodes as visited and enqueue them.
4. Repeat step 3 until the destination node is dequeued or the queue becomes empty.
5. When the destination node is dequeued, follow the path from the source node to the destination node by backtracking from the destination node to the source node.

Here's a diagram illustrating this process:

```
         +--------+
         |        |
         |  Source  |
         |        |
         +--------+

         +--------+
         |        |
         |    Node 1|
         |        |
         +--------+

         +--------+
         |        |
         |   Node 2  |
         |        |
         +--------+

...and so on
```

Time complexity analysis: The time complexity of BFS is O(V+E), where V is the number of vertices and E is the number of edges. This is because we visit each vertex once and traverse each edge once.

Space complexity analysis: The space complexity of BFS is O(V), as in the worst-case scenario, we need to store all vertices in the queue.

## Optimized Solutions

### Java
```java
import java.util.*;

class Node {
    int val;
    boolean visited;

    public Node(int val) {
        this.val = val;
        this.visited = false;
    }
}

public class Main {
    static void shortestPath(Node[] nodes, int source, int dest) {
        Node[] nodesCopy = Arrays.copyOf(nodes, nodes.length);
        nodesCopy[source].visited = true;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(source);

        while (!queue.isEmpty()) {
            int node = queue.poll();
            if (node == dest) {
                // Follow the path from source to destination
                List<Integer> path = new ArrayList<>();
                while (node != source) {
                    path.add(node);
                    node = nodesCopy[node].val;
                }
                path.add(source);
                Collections.reverse(path);
                System.out.println("Shortest Path: " + path);
                return;
            }

            for (int neighbor : getNeighbors(nodes, node)) {
                if (!nodes[neighbor].visited) {
                    nodes[neighbor].visited = true;
                    queue.add(neighbor);
                }
            }
        }
    }

    static int[] getNeighbors(Node[] nodes, int node) {
        // Get neighbors of the given node
        // For simplicity, assume all edges have a unit distance
        return new int[] {node - 1, node + 1};
    }

    public static void main(String[] args) {
        Node[] nodes = new Node[5];
        for (int i = 0; i < 5; i++) {
            nodes[i] = new Node(i);
        }
        shortestPath(nodes, 0, 4); // Example usage
    }
}
```

### Python
```python
class Node:
    def __init__(self, val):
        self.val = val
        self.visited = False

def shortest_path(graph, source, dest):
    nodes_copy = [Node(node.val) for node in graph]
    nodes_copy[source].visited = True

    queue = [source]

    while queue:
        node = queue.pop(0)
        if node == dest:
            # Follow the path from source to destination
            path = []
            while node != source:
                path.append(node)
                node = nodes_copy[node].val
            path.append(source)
            print("Shortest Path:", list(reversed(path)))
            return

        for neighbor in get_neighbors(graph, node):
            if not nodes_copy[neighbor].visited:
                nodes_copy[neighbor].visited = True
                queue.append(neighbor)

def get_neighbors(graph, node):
    # Get neighbors of the given node
    # For simplicity, assume all edges have a unit distance
    return [node - 1, node + 1]

# Example usage
nodes = [Node(i) for i in range(5)]
shortest_path(nodes, 0, 4)
```

### C++
```cpp
#include <iostream>
#include <queue>
#include <vector>

class Node {
public:
    int val;
    bool visited;

    Node(int val) : val(val), visited(false) {}
};

void shortestPath(std::vector<Node>& nodes, int source, int dest) {
    std::vector<Node> nodesCopy = nodes;
    nodesCopy[source].visited = true;

    std::queue<int> queue;
    queue.push(source);

    while (!queue.empty()) {
        int node = queue.front();
        queue.pop();
        if (node == dest) {
            // Follow the path from source to destination
            std::vector<int> path;
            while (node != source) {
                path.push_back(node);
                node = nodesCopy[node].val;
            }
            path.push_back(source);
            std::reverse(path.begin(), path.end());
            std::cout << "Shortest Path: ";
            for (int p : path) {
                std::cout << p << " ";
            }
            std::cout << std::endl;
            return;
        }

        for (int neighbor : getNeighbors(nodes, node)) {
            if (!nodesCopy[neighbor].visited) {
                nodesCopy[neighbor].visited = true;
                queue.push(neighbor);
            }
        }
    }
}

std::vector<int> getNeighbors(std::vector<Node>& nodes, int node) {
    // Get neighbors of the given node
    // For simplicity, assume all edges have a unit distance
    return std::vector<int>(1, node - 1) | std::vector<int>(1, node + 1);
}

int main() {
    std::vector<Node> nodes(5);
    for (int i = 0; i < 5; i++) {
        nodes[i].val = i;
    }
    shortestPath(nodes, 0, 4); // Example usage
    return 0;
}
```

### JavaScript
```javascript
class Node {
    constructor(val) {
        this.val = val;
        this.visited = false;
    }
}

function shortestPath(graph, source, dest) {
    const nodesCopy = [...graph];
    nodesCopy[source].visited = true;

    const queue = [source];

    while (queue.length) {
        const node = queue.shift();
        if (node === dest) {
            // Follow the path from source to destination
            let path = [];
            while (node !== source) {
                path.push(node);
                node = nodesCopy[node].val;
            }
            path.push(source);
            console.log(`Shortest Path: ${path.reverse().join(" ")}`);
            return;
        }

        for (const neighbor of getNeighbors(graph, node)) {
            if (!nodesCopy[neighbor].visited) {
                nodesCopy[neighbor].visited = true;
                queue.push(neighbor);
            }
        }
    }
}

function getNeighbors(graph, node) {
    // Get neighbors of the given node
    // For simplicity, assume all edges have a unit distance
    return [node - 1, node + 1];
}

// Example usage
const nodes = Array.from({ length: 5 }, (_, i) => new Node(i));
shortestPath(nodes, 0, 4);
```

This blog post provides a detailed explanation of the algorithm for finding the shortest path in a graph with unit-weight edges. The code examples are written in various programming languages, including Python, C++, and JavaScript.