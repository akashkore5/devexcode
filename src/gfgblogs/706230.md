---
id: "706230"
title: "Partition a Linked List around a given value"
slug: "partition-a-linked-list-around-a-given-value"
difficulty: "Medium"
companyTags: ["Microsoft"]
tags: ["Linked List", "Data Structures"]
---

Partition a Linked List around a given value
=============================================

## Summary
Given a singly linked list and an integer `x`, partition the linked list such that all nodes less than `x` are moved to the left side of the linked list, while all nodes greater than or equal to `x` are moved to the right side. The relative order of elements in the same group should remain unchanged.

## Detailed Explanation
To solve this problem, we can use two pointers, one for the head of the new list and one for the current node in the original list. We iterate through the original list until we find a node that is greater than or equal to `x`, then we move it to the right side. The nodes less than `x` are moved to the left side.

Here's a step-by-step breakdown of the solution:

1. Initialize two pointers, `head` and `prev`, both pointing to `NULL`. These will be used to build the new list.
2. Iterate through the original linked list until you find a node that is greater than or equal to `x`.
3. When you find such a node, move it to the right side of the new list by updating the `next` pointer of the previous node (or `head` if this is the first node) and setting its `next` pointer to the current node.
4. Repeat step 2 until the end of the original list is reached.
5. The nodes less than `x` are moved to the left side, so return the `head` of the new list.

Time complexity: O(n), where n is the number of nodes in the linked list. We only iterate through the list once, so the time complexity is linear.
Space complexity: O(1), as we only use a few extra variables to store the pointers.

## Optimized Solutions

### Java
```java
class ListNode {
    int val;
    ListNode next;

    ListNode(int x) { val = x; }
}

public class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode beforeStart = null;
        ListNode beforeEnd = null;
        ListNode afterStart = null;
        ListNode afterEnd = null;

        while (head != null) {
            if (head.val < x) {
                if (beforeStart == null) {
                    beforeStart = head;
                    beforeEnd = beforeStart;
                } else {
                    beforeEnd.next = head;
                    beforeEnd = beforeEnd.next;
                }
            } else {
                if (afterStart == null) {
                    afterStart = head;
                    afterEnd = afterStart;
                } else {
                    afterEnd.next = head;
                    afterEnd = afterEnd.next;
                }
            }
            head = head.next;
        }

        if (beforeStart == null) {
            return afterStart;
        }

        beforeEnd.next = afterStart;
        return beforeStart;
    }
}
```

### Python
```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def partition(head: ListNode, x: int) -> ListNode:
    before_start = None
    before_end = None
    after_start = None
    after_end = None

    while head is not None:
        if head.val < x:
            if before_start is None:
                before_start = head
                before_end = before_start
            else:
                before_end.next = head
                before_end = before_end.next
        else:
            if after_start is None:
                after_start = head
                after_end = after_start
            else:
                after_end.next = head
                after_end = after_end.next
        head = head.next

    if before_start is None:
        return after_start
    before_end.next = after_start
    return before_start
```

### C++
```cpp
class ListNode {
public:
    int val;
    ListNode* next;

    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* partition(ListNode* head, int x) {
    ListNode* beforeStart = nullptr;
    ListNode* beforeEnd = nullptr;
    ListNode* afterStart = nullptr;
    ListNode* afterEnd = nullptr;

    while (head != nullptr) {
        if (head->val < x) {
            if (beforeStart == nullptr) {
                beforeStart = head;
                beforeEnd = beforeStart;
            } else {
                beforeEnd->next = head;
                beforeEnd = beforeEnd->next;
            }
        } else {
            if (afterStart == nullptr) {
                afterStart = head;
                afterEnd = afterStart;
            } else {
                afterEnd->next = head;
                afterEnd = afterEnd->next;
            }
        }
        head = head->next;
    }

    if (beforeStart == nullptr) {
        return afterStart;
    }

    beforeEnd->next = afterStart;
    return beforeStart;
}
```

### JavaScript
```javascript
class ListNode {
  constructor(val, next = null) {
    this.val = val;
    this.next = next;
  }
}

function partition(head, x) {
  let beforeStart = null;
  let beforeEnd = null;
  let afterStart = null;
  let afterEnd = null;

  while (head) {
    if (head.val < x) {
      if (!beforeStart) {
        beforeStart = head;
        beforeEnd = beforeStart;
      } else {
        beforeEnd.next = head;
        beforeEnd = beforeEnd.next;
      }
    } else {
      if (!afterStart) {
        afterStart = head;
        afterEnd = afterStart;
      } else {
        afterEnd.next = head;
        afterEnd = afterEnd.next;
      }
    }
    head = head.next;
  }

  if (!beforeStart) {
    return afterStart;
  }

  beforeEnd.next = afterStart;
  return beforeStart;
}
```